{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155Upgradeable.sol\";\nimport \"./IERC1155ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC1155MetadataURIUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC1155Upgradeable, IERC1155MetadataURIUpgradeable {\n    using AddressUpgradeable for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal onlyInitializing {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal onlyInitializing {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC1155Upgradeable).interfaceId ||\n            interfaceId == type(IERC1155MetadataURIUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155ReceiverUpgradeable(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/IERC1155MetadataURIUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Upgradeable.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURIUpgradeable is IERC1155Upgradeable {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../extensions/draft-IERC20PermitUpgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20PermitUpgradeable token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/BlueBerryBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./utils/BlueBerryConst.sol\" as Constants;\nimport \"./utils/BlueBerryErrors.sol\" as Errors;\nimport \"./utils/EnsureApprove.sol\";\nimport \"./utils/ERC1155NaiveReceiver.sol\";\nimport \"./interfaces/IBank.sol\";\nimport \"./interfaces/ICoreOracle.sol\";\nimport \"./interfaces/ISoftVault.sol\";\nimport \"./interfaces/IHardVault.sol\";\nimport \"./interfaces/compound/ICErc20.sol\";\nimport \"./libraries/BBMath.sol\";\n\n /// @title BlueberryBank\n /// @author BlueberryProtocol\n /// @notice Blueberry Bank is the main contract that stores user's positions and track the borrowing of tokens\ncontract BlueBerryBank is\n    OwnableUpgradeable,\n    ERC1155NaiveReceiver,\n    IBank,\n    EnsureApprove\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Constants for internal usage.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n    uint256 private constant _NO_ID = type(uint256).max;\n    address private constant _NO_ADDRESS = address(1);\n\n    /// Temporary variables used across functions.\n    uint256 public _GENERAL_LOCK;      // TEMPORARY: re-entrancy lock guard.\n    uint256 public _IN_EXEC_LOCK;      // TEMPORARY: exec lock guard.\n    uint256 public POSITION_ID;        // TEMPORARY: position ID currently under execution.\n    address public SPELL;              // TEMPORARY: spell currently under execution.\n\n    /// Configurations and oracle addresses.\n    IProtocolConfig public config;     /// @dev The protocol config address.\n    ICoreOracle public oracle;         /// @dev The main oracle address.\n\n    /// State variables for position and bank.\n    uint256 public nextPositionId;        /// Next available position ID, starting from 1 (see initialize).\n    uint256 public bankStatus;            /// Each bit stores certain bank status, e.g. borrow allowed, repay allowed\n    uint256 public repayResumedTimestamp; /// Timestamp that repay is allowed or resumed\n\n    /// Collections of banks and positions.\n    address[] public allBanks;                     /// The list of all listed banks.\n    mapping(address => Bank) public banks;         /// Mapping from token to bank data.\n    mapping(address => bool) public bTokenInBank;  /// Mapping from bToken to its existence in bank.\n    mapping(uint256 => Position) public positions; /// Mapping from position ID to position data.\n\n    /// Flags and whitelists\n    bool public allowContractCalls; // The boolean status whether to allow call from contract (false = onlyEOA)\n    mapping(address => bool) public whitelistedTokens;        /// Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedWrappedTokens; /// Mapping from token to whitelist status\n    mapping(address => bool) public whitelistedSpells;        /// Mapping from spell to whitelist status\n    mapping(address => bool) public whitelistedContracts;     /// Mapping from user to whitelist status\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Ensure that the function is called from EOA\n    /// when allowContractCalls is set to false and caller is not whitelisted\n    modifier onlyEOAEx() {\n        if (!allowContractCalls && !whitelistedContracts[msg.sender]) {\n            if (AddressUpgradeable.isContract(msg.sender))\n                revert Errors.NOT_EOA(msg.sender);\n        }\n        _;\n    }\n\n    /// @dev Ensure that the token is already whitelisted\n    modifier onlyWhitelistedToken(address token) {\n        if (!whitelistedTokens[token])\n            revert Errors.TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Ensure that the wrapped ERC1155 is already whitelisted\n    modifier onlyWhitelistedERC1155(address token) {\n        if (!whitelistedWrappedTokens[token])\n            revert Errors.TOKEN_NOT_WHITELISTED(token);\n        _;\n    }\n\n    /// @dev Reentrancy lock guard.\n    modifier lock() {\n        if (_GENERAL_LOCK != _NOT_ENTERED) revert Errors.LOCKED();\n        _GENERAL_LOCK = _ENTERED;\n        _;\n        _GENERAL_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the function is called from within the execution scope.\n    modifier inExec() {\n        if (POSITION_ID == _NO_ID) revert Errors.NOT_IN_EXEC();\n        if (SPELL != msg.sender) revert Errors.NOT_FROM_SPELL(msg.sender);\n        if (_IN_EXEC_LOCK != _NOT_ENTERED) revert Errors.LOCKED();\n        _IN_EXEC_LOCK = _ENTERED;\n        _;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n    }\n\n    /// @dev Ensure that the interest rate of the given token is accrued.\n    modifier poke(address token) {\n        accrue(token);\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Initialize the bank smart contract, using msg.sender as the first governor.\n    /// @dev Emits a {SetOracle} event.\n    /// @param oracle_ The oracle smart contract address.\n    /// @param config_ The Protocol config address\n    function initialize(\n        ICoreOracle oracle_,\n        IProtocolConfig config_\n    ) external initializer {\n        __Ownable_init();\n        if (address(oracle_) == address(0) || address(config_) == address(0)) {\n            revert Errors.ZERO_ADDRESS();\n        }\n        _GENERAL_LOCK = _NOT_ENTERED;\n        _IN_EXEC_LOCK = _NOT_ENTERED;\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        config = config_;\n        oracle = oracle_;\n\n        nextPositionId = 1;\n        bankStatus = 15; // 0x1111: allow borrow, repay, lend, withdrawLend as default\n\n        emit SetOracle(address(oracle_));\n    }\n\n    /// @notice Fetches the executor of the current position.\n    /// @dev An executor is the owner of the current position.\n    /// @return Address of the executor.\n    function EXECUTOR() external view override returns (address) {\n        uint256 positionId = POSITION_ID;\n        if (positionId == _NO_ID) {\n            revert Errors.NOT_UNDER_EXECUTION();\n        }\n        return positions[positionId].owner;\n    }\n\n    /// @dev Toggles the allowance of contract calls.\n    /// @param ok If true, contract calls are allowed. Otherwise, only EOA calls are allowed.\n    function setAllowContractCalls(bool ok) external onlyOwner {\n        allowContractCalls = ok;\n    }\n\n    /// @dev Sets whitelist statuses for various contracts.\n    /// @param contracts List of contract addresses.\n    /// @param statuses Corresponding list of whitelist statuses to set.\n    function whitelistContracts(\n        address[] calldata contracts,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (contracts.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < contracts.length; idx++) {\n            if (contracts[idx] == address(0)) {\n                revert Errors.ZERO_ADDRESS();\n            }\n            whitelistedContracts[contracts[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set the whitelist status for specific spells.\n    /// @param spells Array of spell addresses to change their whitelist status.\n    /// @param statuses Array of boolean values indicating the desired whitelist status for each spell.\n    function whitelistSpells(\n        address[] calldata spells,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (spells.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < spells.length; idx++) {\n            if (spells[idx] == address(0)) {\n                revert Errors.ZERO_ADDRESS();\n            }\n            whitelistedSpells[spells[idx]] = statuses[idx];\n        }\n    }\n\n    /// @dev Set the whitelist status for specific tokens.\n    /// @param tokens Array of token addresses to change their whitelist status.\n    /// @param statuses Array of boolean values indicating the desired whitelist status for each token.\n    function whitelistTokens(\n        address[] calldata tokens,\n        bool[] calldata statuses\n    ) external onlyOwner {\n        if (tokens.length != statuses.length) {\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        }\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (statuses[idx] && !oracle.isTokenSupported(tokens[idx]))\n                revert Errors.ORACLE_NOT_SUPPORT(tokens[idx]);\n            whitelistedTokens[tokens[idx]] = statuses[idx];\n            emit SetWhitelistToken(tokens[idx], statuses[idx]);\n        }\n    }\n\n    /// @dev Set the whitelist status for specific wrapped tokens (ERC1155).\n    /// @param tokens Array of wrapped token addresses to set their whitelist status.\n    /// @param ok Boolean indicating the desired whitelist status for the provided tokens.\n    function whitelistERC1155(\n        address[] memory tokens,\n        bool ok\n    ) external onlyOwner {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            address token = tokens[idx];\n            if (token == address(0)) revert Errors.ZERO_ADDRESS();\n            whitelistedWrappedTokens[token] = ok;\n            emit SetWhitelistERC1155(token, ok);\n        }\n    }\n\n    /// @dev Add a new bank entity with associated vaults.\n    /// @dev Emits a {AddBank} event.\n    /// @param token Address of the underlying token for the bank.\n    /// @param softVault Address of the softVault.\n    /// @param hardVault Address of the hardVault.\n    /// @param liqThreshold Liquidation threshold.\n    function addBank(\n        address token,\n        address softVault,\n        address hardVault,\n        uint256 liqThreshold\n    ) external onlyOwner onlyWhitelistedToken(token) {\n        if (softVault == address(0) || hardVault == address(0))\n            revert Errors.ZERO_ADDRESS();\n        if (liqThreshold > Constants.DENOMINATOR)\n            revert Errors.LIQ_THRESHOLD_TOO_HIGH(liqThreshold);\n        if (liqThreshold < Constants.MIN_LIQ_THRESHOLD)\n            revert Errors.LIQ_THRESHOLD_TOO_LOW(liqThreshold);\n\n        Bank storage bank = banks[token];\n        address bToken = address(ISoftVault(softVault).bToken());\n\n        if (bTokenInBank[bToken]) revert Errors.BTOKEN_ALREADY_ADDED();\n        if (bank.isListed) revert Errors.BANK_ALREADY_LISTED();\n        if (allBanks.length >= 256) revert Errors.BANK_LIMIT();\n\n        bTokenInBank[bToken] = true;\n        bank.isListed = true;\n        bank.index = uint8(allBanks.length);\n        bank.bToken = bToken;\n        bank.softVault = softVault;\n        bank.hardVault = hardVault;\n        bank.liqThreshold = liqThreshold;\n\n        IHardVault(hardVault).setApprovalForAll(hardVault, true);\n        allBanks.push(token);\n\n        emit AddBank(token, bToken, softVault, hardVault);\n    }\n\n    /// @dev Update the bank's operational status flags.\n    /// @param _bankStatus The new status flags for the bank.\n    function setBankStatus(uint256 _bankStatus) external onlyOwner {\n        bool repayAllowedStatusBefore = isRepayAllowed();\n        bankStatus = _bankStatus;\n        bool repayAllowedStatusAfter = isRepayAllowed();\n\n        /// If the repayAllowed status changes from \"off\" to \"on\", update the timestamp.\n        if (!repayAllowedStatusBefore && repayAllowedStatusAfter) {\n            repayResumedTimestamp = block.timestamp;\n        }\n    }\n\n    /// @dev Determine if borrowing is currently allowed based on the bank's status flags.\n    /// @notice Check the last bit of bankStatus.\n    /// @return A boolean indicating whether borrowing is permitted.\n    function isBorrowAllowed() public view returns (bool) {\n        return (bankStatus & 0x01) > 0;\n    }\n\n    /// @dev Determine if repayments are currently allowed based on the bank's status flags.\n    /// @notice Check the second-to-last bit of bankStatus.\n    /// @return A boolean indicating whether repayments are permitted.\n    function isRepayAllowed() public view returns (bool) {\n        return (bankStatus & 0x02) > 0;\n    }\n\n    /// @dev Determine if lending is currently allowed based on the bank's status flags.\n    /// @notice Check the third-to-last bit of bankStatus.\n    /// @return A boolean indicating whether lending is permitted.\n    function isLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x04) > 0;\n    }\n\n    /// @dev Determine if withdrawing from lending is currently allowed based on the bank's status flags.\n    /// @notice Check the fourth-to-last bit of bankStatus.\n    /// @return A boolean indicating whether withdrawing from lending is permitted.\n    function isWithdrawLendAllowed() public view returns (bool) {\n        return (bankStatus & 0x08) > 0;\n    }\n\n    /// @dev Get the current FeeManager interface from the configuration.\n    /// @return An interface representing the current FeeManager.\n    function feeManager() public view returns (IFeeManager) {\n        return config.feeManager();\n    }\n\n    /// @dev Trigger interest accrual for a specific bank.\n    /// @param token The address of the underlying token to trigger the interest accrual.\n    function accrue(address token) public override {\n        Bank storage bank = banks[token];\n        if (!bank.isListed) revert Errors.BANK_NOT_LISTED(token);\n        ICErc20(bank.bToken).borrowBalanceCurrent(address(this));\n    }\n\n    /// @dev Convenient function to trigger interest accrual for multiple banks.\n    /// @param tokens An array of token addresses to trigger interest accrual for.\n    function accrueAll(address[] memory tokens) external {\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            accrue(tokens[idx]);\n        }\n    }\n\n    /// @dev Internal function to return the current borrow balance of the given token.\n    /// @param token The token address to query for borrow balance.\n    function _borrowBalanceStored(\n        address token\n    ) internal view returns (uint256) {\n        return ICErc20(banks[token].bToken).borrowBalanceStored(address(this));\n    }\n\n    /// @dev Trigger interest accrual and return the current debt balance for a specific position.\n    /// @param positionId The ID of the position to query for the debt balance.\n    /// The current debt balance for the specified position.\n    function currentPositionDebt(\n        uint256 positionId\n    )\n        external\n        override\n        poke(positions[positionId].debtToken)\n        returns (uint256)\n    {\n        return getPositionDebt(positionId);\n    }\n\n    /// @notice Retrieve the debt of a given position, considering the stored debt interest.\n    /// @dev Should call accrue first to obtain the current debt.\n    /// @param positionId The ID of the position to query.\n    function getPositionDebt(\n        uint256 positionId\n    ) public view returns (uint256 debt) {\n        Position memory pos = positions[positionId];\n        Bank memory bank = banks[pos.debtToken];\n        if (pos.debtShare == 0 || bank.totalShare == 0) {\n            return 0;\n        }\n        debt = (pos.debtShare * _borrowBalanceStored(pos.debtToken)).divCeil(\n            bank.totalShare\n        );\n    }\n\n    /// @dev Retrieve information about a specific bank.\n    /// @param token The token address to query for bank information.\n    /// @return isListed Whether the bank is listed or not.\n    /// @return bToken The address of the bToken associated with the bank.\n    /// @return totalShare The total shares in the bank.\n    function getBankInfo(\n        address token\n    )\n        external\n        view\n        override\n        returns (bool isListed, address bToken, uint256 totalShare)\n    {\n        Bank memory bank = banks[token];\n        return (bank.isListed, bank.bToken, bank.totalShare);\n    }\n\n    /// @dev Fetches details about a specific position using its ID.\n    /// @param positionId Unique identifier of the position.\n    /// @return Position object containing all details about the position.\n    function getPositionInfo(\n        uint256 positionId\n    ) external view override returns (Position memory) {\n        return positions[positionId];\n    }\n\n    /// @dev Fetches details about the current active position.\n    /// @notice This function assumes the presence of an active position and will revert if there's none.\n    /// @return Position object containing all details about the current position.\n    function getCurrentPositionInfo()\n        external\n        view\n        override\n        returns (Position memory)\n    {\n        if (POSITION_ID == _NO_ID) revert Errors.BAD_POSITION(POSITION_ID);\n        return positions[POSITION_ID];\n    }\n\n    /// @dev Computes the total USD value of the collateral of a given position.\n    /// @notice The returned value includes both the collateral and any pending rewards.\n    /// @param positionId ID of the position to compute the value for.\n    /// @return positionValue Total USD value of the collateral and pending rewards.\n    function getPositionValue(\n        uint256 positionId\n    ) public override returns (uint256 positionValue) {\n        Position memory pos = positions[positionId];\n        if (pos.collateralSize == 0) {\n            return 0;\n        } else {\n            if (pos.collToken == address(0))\n                revert Errors.BAD_COLLATERAL(positionId);\n            uint256 collValue = oracle.getWrappedTokenValue(\n                pos.collToken,\n                pos.collId,\n                pos.collateralSize\n            );\n\n            uint rewardsValue;\n            (address[] memory tokens, uint256[] memory rewards) = IERC20Wrapper(\n                pos.collToken\n            ).pendingRewards(pos.collId, pos.collateralSize);\n            for (uint256 i; i < tokens.length; i++) {\n                if (oracle.isTokenSupported(tokens[i])) {\n                    rewardsValue += oracle.getTokenValue(tokens[i], rewards[i]);\n                }\n            }\n\n            return collValue + rewardsValue;\n        }\n    }\n\n    /// @dev Computes the total USD value of the debt of a given position.\n    /// @notice Ensure to call `accrue` beforehand to account for any interest changes.\n    /// @param positionId ID of the position to compute the debt value for.\n    /// @return debtValue Total USD value of the position's debt.\n    function getDebtValue(\n        uint256 positionId\n    ) public override returns (uint256 debtValue) {\n        Position memory pos = positions[positionId];\n        uint256 debt = getPositionDebt(positionId);\n        debtValue = oracle.getTokenValue(pos.debtToken, debt);\n    }\n\n    /// @dev Computes the USD value of the isolated collateral for a given position.\n    /// @notice Ensure to call `accrue` beforehand to get the most recent value.\n    /// @param positionId ID of the position to compute the isolated collateral value for.\n    /// @return icollValue USD value of the isolated collateral.\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) public override returns (uint256 icollValue) {\n        Position memory pos = positions[positionId];\n        /// NOTE: exchangeRateStored has 18 decimals.\n        uint256 underlyingAmount;\n        if (_isSoftVault(pos.underlyingToken)) {\n            underlyingAmount =\n                (ICErc20(banks[pos.debtToken].bToken).exchangeRateStored() *\n                    pos.underlyingVaultShare) /\n                Constants.PRICE_PRECISION;\n        } else {\n            underlyingAmount = pos.underlyingVaultShare;\n        }\n        icollValue = oracle.getTokenValue(\n            pos.underlyingToken,\n            underlyingAmount\n        );\n    }\n\n    /// @dev Computes the risk ratio of a specified position.\n    /// @notice A higher risk ratio implies greater risk associated with the position.\n    ///         when:  riskRatio = (ov - pv) / cv\n    ///         where: riskRatio = (debt - positionValue) / isolatedCollateralValue\n    /// @param positionId ID of the position to assess risk for.\n    /// @return risk The risk ratio of the position (based on a scale of 1e4).\n    function getPositionRisk(uint256 positionId) public returns (uint256 risk) {\n        uint256 pv = getPositionValue(positionId);\n        uint256 ov = getDebtValue(positionId);\n        uint256 cv = getIsolatedCollateralValue(positionId);\n\n        if (\n            (cv == 0 && pv == 0 && ov == 0) || pv >= ov /// Closed position or Overcollateralized position\n        ) {\n            risk = 0;\n        } else if (cv == 0) {\n            /// Sth bad happened to isolated underlying token\n            risk = Constants.DENOMINATOR;\n        } else {\n            risk = ((ov - pv) * Constants.DENOMINATOR) / cv;\n        }\n    }\n\n    /// @dev Determines if a given position can be liquidated based on its risk ratio.\n    /// @param positionId ID of the position to check.\n    /// @return True if the position can be liquidated; otherwise, false.\n    function isLiquidatable(uint256 positionId) public returns (bool) {\n        return\n            getPositionRisk(positionId) >=\n            banks[positions[positionId].underlyingToken].liqThreshold;\n    }\n\n    /// @dev Liquidates a position by repaying its debt and taking the collateral.\n    /// @dev Emits a {Liquidate} event.\n    /// @notice Liquidation can only be triggered if the position is deemed liquidatable \n    ///         and other conditions are met.\n    /// @param positionId The unique identifier of the position to liquidate.\n    /// @param debtToken The token in which the debt is denominated.\n    /// @param amountCall The amount of debt to be repaid when calling transferFrom.\n    function liquidate(\n        uint256 positionId,\n        address debtToken,\n        uint256 amountCall\n    ) external override lock poke(debtToken) {\n        /// Ensures repayments are allowed at the moment of calling this function.\n        if (!isRepayAllowed()) revert Errors.REPAY_NOT_ALLOWED();\n        /// Ensures a non-zero repayment amount is specified.\n        if (amountCall == 0) revert Errors.ZERO_AMOUNT();\n        /// Ensures the position is liquidatable.\n        if (!isLiquidatable(positionId))\n            revert Errors.NOT_LIQUIDATABLE(positionId);\n\n        /// Retrieve the position and associated bank data.\n        Position storage pos = positions[positionId];\n        Bank memory bank = banks[pos.underlyingToken];\n        /// Ensure the position has valid collateral.\n        if (pos.collToken == address(0))\n            revert Errors.BAD_COLLATERAL(positionId);\n\n        /// Revert liquidation if the repayment hasn't been warmed up \n        /// following the last state where repayments were paused.\n        if (\n            block.timestamp <\n            repayResumedTimestamp + Constants.LIQUIDATION_REPAY_WARM_UP_PERIOD\n        ) revert Errors.REPAY_ALLOW_NOT_WARMED_UP();\n\n        /// Repay the debt and get details of repayment.\n        uint256 oldShare = pos.debtShare;\n        (uint256 amountPaid, uint256 share) = _repay(\n            positionId,\n            debtToken,\n            amountCall\n        );\n\n        /// Calculate the size of collateral and underlying vault share that the liquidator will get.\n        uint256 liqSize = (pos.collateralSize * share) / oldShare;\n        uint256 uVaultShare = (pos.underlyingVaultShare * share) / oldShare;\n\n        /// Adjust the position's debt and collateral after liquidation.\n        pos.collateralSize -= liqSize;\n        pos.underlyingVaultShare -= uVaultShare;\n\n        /// Transfer the liquidated collateral (Wrapped LP Tokens) to the liquidator.\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            liqSize,\n            \"\"\n        );\n        /// Transfer underlying collaterals(vault share tokens) to liquidator\n        if (_isSoftVault(pos.underlyingToken)) {\n            IERC20Upgradeable(bank.softVault).safeTransfer(\n                msg.sender,\n                uVaultShare\n            );\n        } else {\n            IERC1155Upgradeable(bank.hardVault).safeTransferFrom(\n                address(this),\n                msg.sender,\n                uint256(uint160(pos.underlyingToken)),\n                uVaultShare,\n                \"\"\n            );\n        }\n\n        /// Emit an event capturing details of the liquidation process.\n        emit Liquidate(\n            positionId,\n            msg.sender,\n            debtToken,\n            amountPaid,\n            share,\n            liqSize,\n            uVaultShare\n        );\n    }\n\n    /// @dev Executes a specific action on a position.\n    /// @dev Emit an {Execute} event.\n    /// @notice This can be used for various operations like adjusting collateral, repaying debt, etc.\n    /// @param positionId Unique identifier of the position, or zero for a new position.\n    /// @param spell Address of the contract (\"spell\") that contains the logic for the action to be executed.\n    /// @param data Data payload to pass to the spell for execution.\n    function execute(\n        uint256 positionId,\n        address spell,\n        bytes memory data\n    ) external lock onlyEOAEx returns (uint256) {\n        if (!whitelistedSpells[spell])\n            revert Errors.SPELL_NOT_WHITELISTED(spell);\n        if (positionId == 0) {\n            positionId = nextPositionId++;\n            positions[positionId].owner = msg.sender;\n        } else {\n            if (positionId >= nextPositionId)\n                revert Errors.BAD_POSITION(positionId);\n            if (msg.sender != positions[positionId].owner)\n                revert Errors.NOT_FROM_OWNER(positionId, msg.sender);\n        }\n        POSITION_ID = positionId;\n        SPELL = spell;\n\n        (bool ok, bytes memory returndata) = SPELL.call(data);\n        if (!ok) {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(\"bad cast call\");\n            }\n        }\n\n        if (isLiquidatable(positionId)) revert Errors.INSUFFICIENT_COLLATERAL();\n\n        POSITION_ID = _NO_ID;\n        SPELL = _NO_ADDRESS;\n\n        emit Execute(positionId, msg.sender);\n\n        return positionId;\n    }\n\n    /// @dev Lend tokens to the bank as isolated collateral.\n    /// @dev Emit a {Lend} event.\n    /// @notice The tokens lent will be used as collateral in the bank and might earn interest or other rewards.\n    /// @param token The address of the token to lend.\n    /// @param amount The number of tokens to lend.\n    function lend(\n        address token,\n        uint256 amount\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        if (!isLendAllowed()) revert Errors.LEND_NOT_ALLOWED();\n\n        Position storage pos = positions[POSITION_ID];\n        Bank storage bank = banks[token];\n        if (pos.underlyingToken != address(0)) {\n            /// already have isolated collateral, allow same isolated collateral\n            if (pos.underlyingToken != token)\n                revert Errors.INCORRECT_UNDERLYING(token);\n        } else {\n            pos.underlyingToken = token;\n        }\n\n        IERC20Upgradeable(token).safeTransferFrom(\n            pos.owner,\n            address(this),\n            amount\n        );\n        _ensureApprove(token, address(feeManager()), amount);\n        amount = feeManager().doCutDepositFee(token, amount);\n\n        if (_isSoftVault(token)) {\n            _ensureApprove(token, bank.softVault, amount);\n            pos.underlyingVaultShare += ISoftVault(bank.softVault).deposit(\n                amount\n            );\n        } else {\n            _ensureApprove(token, bank.hardVault, amount);\n            pos.underlyingVaultShare += IHardVault(bank.hardVault).deposit(\n                token,\n                amount\n            );\n        }\n\n        emit Lend(POSITION_ID, msg.sender, token, amount);\n    }\n\n    /// @dev Withdraw isolated collateral tokens previously lent to the bank.\n    /// @dev Emit a {WithdrawLend} event.\n    /// @notice This will reduce the isolated collateral and might also reduce the position's overall health.\n    /// @param token The address of the isolated collateral token to withdraw.\n    /// @param shareAmount The number of vault share tokens to withdraw.\n    function withdrawLend(\n        address token,\n        uint256 shareAmount\n    ) external override inExec poke(token) {\n        if (!isWithdrawLendAllowed()) revert Errors.WITHDRAW_LEND_NOT_ALLOWED();\n        Position storage pos = positions[POSITION_ID];\n        Bank memory bank = banks[token];\n        if (token != pos.underlyingToken) revert Errors.INVALID_UTOKEN(token);\n        if (shareAmount == type(uint256).max) {\n            shareAmount = pos.underlyingVaultShare;\n        }\n\n        uint256 wAmount;\n        if (_isSoftVault(token)) {\n            _ensureApprove(bank.softVault, bank.softVault, shareAmount);\n            wAmount = ISoftVault(bank.softVault).withdraw(shareAmount);\n        } else {\n            wAmount = IHardVault(bank.hardVault).withdraw(token, shareAmount);\n        }\n\n        pos.underlyingVaultShare -= shareAmount;\n\n        _ensureApprove(token, address(feeManager()), wAmount);\n        wAmount = feeManager().doCutWithdrawFee(token, wAmount);\n\n        IERC20Upgradeable(token).safeTransfer(msg.sender, wAmount);\n\n        emit WithdrawLend(POSITION_ID, msg.sender, token, wAmount);\n    }\n\n    /// @notice Allows users to borrow tokens from the specified bank.\n    /// @dev This function must only be called from a spell while under execution.\n    /// @dev Emit a {Borrow} event.\n    /// @param token The token to borrow from the bank.\n    /// @param amount The amount of tokens the user wishes to borrow.\n    /// @return borrowedAmount Returns the actual amount borrowed from the bank.\n    function borrow(\n        address token,\n        uint256 amount\n    )\n        external\n        override\n        inExec\n        poke(token)\n        onlyWhitelistedToken(token)\n        returns (uint256 borrowedAmount)\n    {\n        if (!isBorrowAllowed()) revert Errors.BORROW_NOT_ALLOWED();\n        Bank storage bank = banks[token];\n        Position storage pos = positions[POSITION_ID];\n        if (pos.debtToken != address(0)) {\n            /// already have some debts, allow same debt token\n            if (pos.debtToken != token) revert Errors.INCORRECT_DEBT(token);\n        } else {\n            pos.debtToken = token;\n        }\n\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = _borrowBalanceStored(token);\n        uint256 share = totalShare == 0\n            ? amount\n            : (amount * totalShare).divCeil(totalDebt);\n        if (share == 0) revert Errors.BORROW_ZERO_SHARE(amount);\n        bank.totalShare += share;\n        pos.debtShare += share;\n\n        borrowedAmount = _doBorrow(token, amount);\n        IERC20Upgradeable(token).safeTransfer(msg.sender, borrowedAmount);\n\n        emit Borrow(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @notice Allows users to repay their borrowed tokens to the bank.\n    /// @dev This function must only be called while under execution.\n    /// @dev Emit a {Repay} event.\n    /// @param token The token to repay to the bank.\n    /// @param amountCall The amount of tokens to be repaid.\n    function repay(\n        address token,\n        uint256 amountCall\n    ) external override inExec poke(token) onlyWhitelistedToken(token) {\n        if (!isRepayAllowed()) revert Errors.REPAY_NOT_ALLOWED();\n        (uint256 amount, uint256 share) = _repay(\n            POSITION_ID,\n            token,\n            amountCall\n        );\n        emit Repay(POSITION_ID, msg.sender, token, amount, share);\n    }\n\n    /// @notice Internal function that handles the logic for repaying tokens.\n    /// @param positionId The position ID which determines the debt to be repaid.\n    /// @param token The bank token used to repay the debt.\n    /// @param amountCall The amount specified by the caller to repay by calling `transferFrom`, or -1 for debt size.\n    /// @return Returns the actual repaid amount and the reduced debt share.\n    function _repay(\n        uint256 positionId,\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256, uint256) {\n        Bank storage bank = banks[token];\n        Position storage pos = positions[positionId];\n        if (pos.debtToken != token) revert Errors.INCORRECT_DEBT(token);\n        uint256 totalShare = bank.totalShare;\n        uint256 totalDebt = _borrowBalanceStored(token);\n        uint256 oldShare = pos.debtShare;\n        uint256 oldDebt = (oldShare * totalDebt).divCeil(totalShare);\n        if (amountCall > oldDebt) {\n            amountCall = oldDebt;\n        }\n        amountCall = _doERC20TransferIn(token, amountCall);\n        uint256 paid = _doRepay(token, amountCall);\n        if (paid > oldDebt) revert Errors.REPAY_EXCEEDS_DEBT(paid, oldDebt); /// prevent share overflow attack\n        uint256 lessShare = paid == oldDebt\n            ? oldShare\n            : (paid * totalShare) / totalDebt;\n        bank.totalShare -= lessShare;\n        pos.debtShare -= lessShare;\n        return (paid, lessShare);\n    }\n\n    /// @notice Allows users to provide additional collateral.\n    /// @dev Must only be called during execution.\n    /// @param collToken The ERC1155 token wrapped for collateral (i.e., Wrapped token of LP).\n    /// @param collId The token ID for collateral (i.e., uint256 format of LP address).\n    /// @param amountCall The amount of tokens to add as collateral.\n    function putCollateral(\n        address collToken,\n        uint256 collId,\n        uint256 amountCall\n    ) external override inExec onlyWhitelistedERC1155(collToken) {\n        Position storage pos = positions[POSITION_ID];\n        if (pos.collToken != collToken || pos.collId != collId) {\n            if (!oracle.isWrappedTokenSupported(collToken, collId))\n                revert Errors.ORACLE_NOT_SUPPORT_WTOKEN(collToken);\n            if (pos.collateralSize > 0)\n                revert Errors.DIFF_COL_EXIST(pos.collToken);\n            pos.collToken = collToken;\n            pos.collId = collId;\n        }\n        uint256 amount = _doERC1155TransferIn(collToken, collId, amountCall);\n        pos.collateralSize += amount;\n        emit PutCollateral(\n            POSITION_ID,\n            pos.owner,\n            msg.sender,\n            collToken,\n            collId,\n            amount\n        );\n    }\n\n    /// @notice Allows users to withdraw a portion of their collateral.\n    /// @dev Must only be called during execution.\n    /// @param amount The amount of tokens to be withdrawn as collateral.\n    /// @return Returns the amount of collateral withdrawn.\n    function takeCollateral(\n        uint256 amount\n    ) external override inExec returns (uint256) {\n        Position storage pos = positions[POSITION_ID];\n        if (amount == type(uint256).max) {\n            amount = pos.collateralSize;\n        }\n        pos.collateralSize -= amount;\n        IERC1155Upgradeable(pos.collToken).safeTransferFrom(\n            address(this),\n            msg.sender,\n            pos.collId,\n            amount,\n            \"\"\n        );\n        emit TakeCollateral(\n            POSITION_ID,\n            msg.sender,\n            pos.collToken,\n            pos.collId,\n            amount\n        );\n\n        return amount;\n    }\n\n    /// @notice Internal function that handles the borrowing logic.\n    /// @dev Borrows the specified amount of tokens and returns the actual borrowed amount.\n    /// NOTE: Caller must ensure that bToken interest was already accrued up to this block.\n    /// @param token The token to borrow.\n    /// @param amountCall The amount of tokens to be borrowed.\n    /// @return borrowAmount The actual amount borrowed.\n    function _doBorrow(\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256 borrowAmount) {\n        address bToken = banks[token].bToken;\n\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        if (ICErc20(bToken).borrow(amountCall) != 0)\n            revert Errors.BORROW_FAILED(amountCall);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        borrowAmount = uBalanceAfter - uBalanceBefore;\n    }\n\n    /// @dev Internal function to handle repayment to the bank. Returns the actual repaid amount.\n    /// @param token The token used for the repayment.\n    /// @param amountCall The specified amount for the repay action.\n    /// NOTE: The caller should ensure that the bToken's interest is updated up to the current block.\n    function _doRepay(\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256 repaidAmount) {\n        address bToken = banks[token].bToken;\n        _ensureApprove(token, bToken, amountCall);\n        uint256 beforeDebt = _borrowBalanceStored(token);\n        if (ICErc20(bToken).repayBorrow(amountCall) != 0)\n            revert Errors.REPAY_FAILED(amountCall);\n        uint256 newDebt = _borrowBalanceStored(token);\n        repaidAmount = beforeDebt - newDebt;\n    }\n\n    /// @dev Internal function to handle the transfer of ERC20 tokens into the contract. \n    /// @param token The ERC20 token to perform transferFrom action.\n    /// @param amountCall The amount use in the transferFrom call.\n    /// @return The actual recieved amount.\n    function _doERC20TransferIn(\n        address token,\n        uint256 amountCall\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amountCall\n        );\n        uint256 balanceAfter = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Internal function to handle the transfer of ERC1155 tokens into the contract.\n    /// @param token The ERC1155 token contract address.\n    /// @param id The specific token ID to be transferred within the ERC1155 contract.\n    /// @param amountCall The expected amount of the specific token ID to be transferred.\n    /// @return The amount of tokens received.\n    function _doERC1155TransferIn(\n        address token,\n        uint256 id,\n        uint256 amountCall\n    ) internal returns (uint256) {\n        uint256 balanceBefore = IERC1155Upgradeable(token).balanceOf(\n            address(this),\n            id\n        );\n        IERC1155Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            id,\n            amountCall,\n            \"\"\n        );\n        uint256 balanceAfter = IERC1155Upgradeable(token).balanceOf(\n            address(this),\n            id\n        );\n        return balanceAfter - balanceBefore;\n    }\n\n    /// @dev Return if the given vault token is soft vault or hard vault\n    /// @param token The underlying token of the vault to be checked.\n    /// @return bool True if it's a Soft Vault, False if it's a Hard Vault.\n    function _isSoftVault(address token) internal view returns (bool) {\n        return address(ISoftVault(banks[token].softVault).uToken()) == token;\n    }\n}\n"
    },
    "contracts/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./interfaces/IProtocolConfig.sol\";\nimport \"./utils/BlueBerryConst.sol\" as Constants;\nimport \"./utils/BlueBerryErrors.sol\" as Errors;\n\n/// @title FeeManager\n/// @author BlueberryProtocol\n/// @notice The FeeManager contract is responsible for processing and distributing fees\n///         within the BlueberryProtocol ecosystem.\ncontract FeeManager is OwnableUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    IProtocolConfig public config;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Initializes the FeeManager contract\n    /// @param config_ Address of the protocol config.\n    function initialize(IProtocolConfig config_) external initializer {\n        __Ownable_init();\n\n        if (address(config_) == address(0)) revert Errors.ZERO_ADDRESS();\n        config = config_;\n    }\n\n    /// @notice Calculates and transfers deposit fee when lending\n    ///         isolated underlying assets to Blueberry Money Market.\n    /// @param token Address of the underlying token.\n    /// @param amount Amount of tokens being deposited.\n    /// @return The net amount after deducting the fee.\n    function doCutDepositFee(\n        address token,\n        uint256 amount\n    ) external returns (uint256) {\n        return _doCutFee(token, amount, config.depositFee());\n    }\n\n    /// @notice Calculates and transfers withdrawal fee when redeeming \n    ///         isolated underlying tokens from Blueberry Money Market.\n    /// @param token Address of the underlying token.\n    /// @param amount Amount of tokens being withdrawn.\n    /// @return The net amount after deducting the fee.\n    function doCutWithdrawFee(\n        address token,\n        uint256 amount\n    ) external returns (uint256) {\n        return _doCutFee(token, amount, config.withdrawFee());\n    }\n\n    /// @notice Calculates and transfers the performance fee from the rewards generated from the leveraged position.\n    /// @param token Address of the reward token.\n    /// @param amount Amount of rewards.\n    /// @return The net rewards after deducting the fee.\n    function doCutRewardsFee(\n        address token,\n        uint256 amount\n    ) external returns (uint256) {\n        return _doCutFee(token, amount, config.rewardFee());\n    }\n\n    /// @notice Cut vault withdraw fee when perform withdraw from Blueberry Money Market within the given window\n    /// @param token Address of the underlying token.\n    /// @param amount Amount of tokens being withdrawn.\n    /// @return The net amount after deducting the fee if within the fee window, else returns the original amount.\n    function doCutVaultWithdrawFee(\n        address token,\n        uint256 amount\n    ) external returns (uint256) {\n        /// Calculate the fee if it's within the fee window, otherwise return the original amount.\n        if (\n            block.timestamp <\n            config.withdrawVaultFeeWindowStartTime() +\n                config.withdrawVaultFeeWindow()\n        ) {\n            return _doCutFee(token, amount, config.withdrawVaultFee());\n        } else {\n            return amount;\n        }\n    }\n\n    /// @dev Cut fee from given amount with given rate and send fee to the treasury\n    /// @param token Address of the token from which the fee will be cut.\n    /// @param amount Total amount from which the fee will be cut.\n    /// @param feeRate Fee rate as a percentage (base 10000, so 100 means 1%).\n    /// @return The net amount after deducting the fee.\n    function _doCutFee(\n        address token,\n        uint256 amount,\n        uint256 feeRate\n    ) internal returns (uint256) {\n        address treasury = config.treasury();\n        if (treasury == address(0)) revert Errors.NO_TREASURY_SET();\n\n        /// Calculate the fee based on the provided rate.\n        uint256 fee = (amount * feeRate) / Constants.DENOMINATOR;\n        /// Transfer the fee to the treasury if it's non-zero.\n        if (fee > 0) {\n            IERC20Upgradeable(token).safeTransferFrom(\n                msg.sender,\n                treasury,\n                fee\n            );\n        }\n        return amount - fee; /// Return the net amount after deducting the fee.\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol';\n"
    },
    "contracts/interfaces/aura/IAura.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ninterface IAura is IERC20MetadataUpgradeable {\n    function INIT_MINT_AMOUNT() external view returns (uint256);\n\n    function reductionPerCliff() external view returns (uint256);\n\n    function totalCliffs() external view returns (uint256);\n\n    function EMISSIONS_MAX_SUPPLY() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/aura/IAuraExtraRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IAuraExtraRewarder {\n    function getReward() external;\n}\n"
    },
    "contracts/interfaces/aura/IAuraPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IAuraPools {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool);\n\n    function forceAddPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool);\n\n    function shutdownPool(uint256 _pid) external returns (bool);\n\n    function poolInfo(\n        uint256\n    )\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    function poolLength() external view returns (uint256);\n\n    function gaugeMap(address) external view returns (bool);\n\n    function setPoolManager(address _poolM) external;\n\n    function shutdownSystem() external;\n\n    function setUsedAddress(address[] memory) external;\n\n    function REWARD_MULTIPLIER_DENOMINATOR() external view returns (uint256);\n\n    function getRewardMultipliers(address) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/aura/IAuraRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IAuraRewarder {\n    function balanceOf(address) external view returns (uint256);\n\n    function withdraw(uint256, bool) external;\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function stakingToken() external view returns (address);\n\n    function rewardToken() external view returns (address);\n\n    function earned(address account) external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/balancer/IAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}\n"
    },
    "contracts/interfaces/balancer/IBalancerPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IBalancerPool {\n    function getRate() external view returns (uint256);\n\n    function getVault() external view returns (address);\n\n    function getPoolId() external view returns (bytes32);\n\n    function totalSupply() external view returns (uint256);\n\n    function getActualSupply() external view returns (uint256);\n\n    function getNormalizedWeights() external view returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/balancer/IBalancerVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport {IAsset} from \"./IAsset.sol\";\n\ninterface IBalancerVault {\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IAsset asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    struct JoinPoolRequest {\n        address[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    struct ExitPoolRequest {\n        address[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    function getPoolTokens(\n        bytes32 poolId\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        );\n\n    function getPool(\n        bytes32 pid\n    ) external view returns (address pool, uint256 poolType);\n\n    function manageUserBalance(UserBalanceOp[] memory ops) external;\n}\n"
    },
    "contracts/interfaces/band/IStdReference.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IStdReference {\n    /// A structure returned whenever someone requests for standard reference data.\n    struct ReferenceData {\n        uint256 rate; // base/quote exchange rate, multiplied by 1e18.\n        uint256 lastUpdatedBase; // UNIX epoch of the last time when base price gets updated.\n        uint256 lastUpdatedQuote; // UNIX epoch of the last time when quote price gets updated.\n    }\n\n    /// @dev Returns the price data for the given base/quote pair. Revert if not available.\n    function getReferenceData(string memory _base, string memory _quote)\n        external\n        view\n        returns (ReferenceData memory);\n\n    /// @dev Similar to getReferenceData, but with multiple base/quote pairs at once.\n    function getReferenceDataBulk(\n        string[] memory _bases,\n        string[] memory _quotes\n    ) external view returns (ReferenceData[] memory);\n}\n"
    },
    "contracts/interfaces/chainlink/IFeedRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IFeedRegistry {\n    function decimals(\n        address base,\n        address quote\n    ) external view returns (uint8);\n\n    function latestRoundData(\n        address base,\n        address quote\n    )\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/chainlink/ISequencerUptimeFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ISequencerUptimeFeed {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/compound/ICErc20_2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICErc20_2 {\n    function underlying() external returns (address);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function setMintRate(uint256 mintRate) external;\n}\n"
    },
    "contracts/interfaces/compound/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICErc20 {\n    function decimals() external view returns (uint8);\n\n    function underlying() external view returns (address);\n\n    function balanceOf(address user) external view returns (uint256);\n\n    function borrowBalanceStored(\n        address account\n    ) external view returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/compound/ICEtherEx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\n// Export ICEther interface for mainnet-fork testing.\ninterface ICEtherEx {\n    function mint() external payable;\n}\n"
    },
    "contracts/interfaces/compound/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IComptroller {\n    function _setCreditLimit(\n        address protocol,\n        address market,\n        uint256 creditLimit\n    ) external;\n\n    function _supportMarket(address bToken, uint8 version) external;\n\n    function enterMarkets(\n        address[] memory bTokens\n    ) external returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/convex/IConvex.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ninterface IConvex is IERC20MetadataUpgradeable {\n    function reductionPerCliff() external view returns (uint256);\n\n    function totalCliffs() external view returns (uint256);\n\n    function maxSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/convex/ICvxExtraRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICvxExtraRewarder {\n    function getReward() external;\n}\n"
    },
    "contracts/interfaces/convex/ICvxPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICvxPools {\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n\n    function withdraw(uint256 _pid, uint256 _amount) external returns (bool);\n\n    function addPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool);\n\n    function forceAddPool(\n        address _lptoken,\n        address _gauge,\n        uint256 _stashVersion\n    ) external returns (bool);\n\n    function shutdownPool(uint256 _pid) external returns (bool);\n\n    function poolInfo(\n        uint256\n    )\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    function poolLength() external view returns (uint256);\n\n    function gaugeMap(address) external view returns (bool);\n\n    function setPoolManager(address _poolM) external;\n\n    function shutdownSystem() external;\n\n    function setUsedAddress(address[] memory) external;\n}\n"
    },
    "contracts/interfaces/convex/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IRewarder {\n    function balanceOf(address) external view returns (uint256);\n\n    function withdraw(uint256, bool) external;\n\n    function extraRewards(uint256) external view returns (address);\n\n    function extraRewardsLength() external view returns (uint256);\n\n    function stakingToken() external view returns (address);\n\n    function rewardToken() external view returns (address);\n\n    function earned(address account) external view returns (uint256);\n\n    function rewardPerToken() external view returns (uint256);\n\n    function stakeFor(address _for, uint256 _amount) external returns (bool);\n}\n"
    },
    "contracts/interfaces/curve/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurveAddressProvider {\n    function get_registry() external view returns (address);\n\n    function get_id_info(\n        uint256\n    )\n        external\n        view\n        returns (\n            address addr,\n            bool is_active,\n            uint256 version,\n            uint256 last_modified,\n            string memory description\n        );\n\n    function get_address(uint256 id) external view returns (address);\n}\n"
    },
    "contracts/interfaces/curve/ICurveCryptoFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurveCryptoFactory {\n    function get_coins(address lp) external view returns (address[2] memory);\n}\n"
    },
    "contracts/interfaces/curve/ICurveCryptoSwapRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurveCryptoSwapRegistry {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function pool_list(uint256 id) external view returns (address);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function get_virtual_price_from_lp_token(\n        address lp\n    ) external view returns (uint256);\n\n    function get_gauges(\n        address pool\n    ) external view returns (address[10] memory, uint128[10] memory);\n}\n"
    },
    "contracts/interfaces/curve/ICurveFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurveFactory {\n    function get_n_coins(address lp) external view returns (uint256);\n\n    function pool_list(uint256 id) external view returns (address);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_gauges(\n        address pool\n    ) external view returns (address[10] memory, uint128[10] memory);\n\n    function get_token(address pool) external view returns (address);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n}\n"
    },
    "contracts/interfaces/curve/ICurveGaugeController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurveGaugeController {\n    function gauges(uint256) external view returns (address);\n}\n"
    },
    "contracts/interfaces/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurvePool {\n    function add_liquidity(uint256[2] calldata, uint256) external;\n\n    function add_liquidity(uint256[3] calldata, uint256) external;\n\n    function add_liquidity(uint256[4] calldata, uint256) external;\n\n    function remove_liquidity(uint256, uint256[2] calldata) external;\n\n    function remove_liquidity(uint256, uint256[3] calldata) external;\n\n    function remove_liquidity(uint256, uint256[4] calldata) external;\n\n    function remove_liquidity_imbalance(uint256[2] calldata, uint256) external;\n\n    function remove_liquidity_imbalance(uint256[3] calldata, uint256) external;\n\n    function remove_liquidity_imbalance(uint256[4] calldata, uint256) external;\n\n    function remove_liquidity_one_coin(uint256, int128, uint256) external;\n\n    function get_virtual_price() external view returns (uint256);\n\n    function lp_token() external view returns (address); // v1\n\n    function token() external view returns (address); // v2\n\n    function balances(uint256 i) external view returns (uint256);\n\n    function withdraw_admin_fees() external;\n\n    function claim_admin_fees() external;\n\n    function get_dy(\n        uint256 i,\n        uint256 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/curve/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ICurveRegistry {\n    function get_n_coins(address lp) external view returns (uint256, uint256);\n\n    function pool_list(uint256 id) external view returns (address);\n\n    function get_coins(address pool) external view returns (address[8] memory);\n\n    function get_pool_from_lp_token(address lp) external view returns (address);\n\n    function get_virtual_price_from_lp_token(\n        address lp\n    ) external view returns (uint256);\n\n    function get_gauges(\n        address pool\n    ) external view returns (address[10] memory, uint128[10] memory);\n\n    function get_lp_token(address pool) external view returns (address);\n}\n"
    },
    "contracts/interfaces/curve/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface ILiquidityGauge {\n    function minter() external view returns (address);\n\n    function crv_token() external view returns (address);\n\n    function lp_token() external view returns (address);\n\n    function balanceOf(address addr) external view returns (uint256);\n\n    function deposit(uint256 value) external;\n\n    function withdraw(uint256 value) external;\n\n    function claimable_tokens(address user) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/IBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"./IProtocolConfig.sol\";\nimport \"./IFeeManager.sol\";\nimport \"./ICoreOracle.sol\";\n\n/// @title IBank\n/// @notice Interface for the bank operations, including lending, borrowing, and management of collateral positions.\ninterface IBank {\n    /*//////////////////////////////////////////////////////////////////////////\n                                       STRUCTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Represents the configuration and current state of a bank.\n    struct Bank {\n        bool isListed;             /// Indicates if this bank is active.\n        uint8 index;               /// Index for reverse lookups.\n        address hardVault;         /// Address of the hard vault.\n        address softVault;         /// Address of the soft vault.\n        address bToken;            /// Address of the bToken associated with the bank.\n        uint256 totalShare;        /// Total shares of debt across all open positions.\n        uint256 liqThreshold;      /// Liquidation threshold (e.g., 85% for volatile tokens, \n                                   /// 90% for stablecoins). Base: 1e4\n    }\n\n    /// Represents a position in the bank, including both debt and collateral.\n    struct Position {\n        address owner;                /// Address of the position's owner.\n        address collToken;            /// Address of the ERC1155 token used as collateral.\n        address underlyingToken;      /// Address of the isolated underlying collateral token.\n        address debtToken;            /// Address of the debt token.\n        uint256 underlyingVaultShare; /// Amount of vault share for isolated underlying collateral.\n        uint256 collId;               /// Token ID of the ERC1155 collateral.\n        uint256 collateralSize;       /// Amount of wrapped token used as collateral.\n        uint256 debtShare;            /// Debt share of the given debt token for the bank.\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                       EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new bank is added by the owner.\n    event AddBank(\n        address token,        /// The primary token associated with the bank.\n        address bToken,       /// The corresponding bToken for the bank.\n        address softVault,    /// Address of the soft vault.\n        address hardVault             /// Address of the hard vault.\n    );\n\n    /// @notice Emitted when the oracle's address is updated by the owner.\n    event SetOracle(address oracle);  /// New address of the oracle.\n\n    /// @notice Emitted when a Wrapped ERC1155 token is whitelisted or removed by the owner.\n    event SetWhitelistERC1155(\n        address indexed token,      /// Address of the Wrapped ERC1155 token.\n        bool isWhitelisted          /// True if whitelisted, false otherwise.\n    );\n\n    /// @notice Emitted when a token is whitelisted or removed by the owner.\n    event SetWhitelistToken(\n        address indexed token,     /// Address of the token.\n        bool isWhitelisted         /// True if whitelisted, false otherwise.\n    );\n\n    /// @notice Emitted when tokens are lent to the bank.\n    event Lend(\n        uint256 positionId,        /// Position ID associated with the lending.\n        address caller,    /// Address of the spell caller.\n        address token,     /// Address of the lent token.\n        uint256 amount             /// Amount of tokens lent.\n    );\n\n    /// @notice Emitted when lent tokens are withdrawn from the bank.\n    event WithdrawLend(\n        uint256 positionId,        /// Position ID associated with the withdrawal.\n        address caller,    /// Address of the spell caller.\n        address token,     ///Address of the token being withdrawn.\n        uint256 amount             /// Amount of tokens withdrawn.\n    );\n\n    /// @notice Emitted when a user borrows tokens from a bank.\n    event Borrow(\n        uint256 positionId,        /// Position ID associated with the borrowing.\n        address caller,    /// Address of the spell caller that initiates the borrowing.\n        address token,     /// Token being borrowed.\n        uint256 amount,            /// Amount of tokens borrowed.\n        uint256 share              /// Debt share associated with the borrowed amount.\n    );\n\n    /// @notice Emitted when a user repays borrowed tokens to a bank.\n    event Repay(\n        uint256 positionId,        /// Position ID associated with the repayment.\n        address caller,    /// Address of the spell caller initiating the repayment.\n        address token,     /// Token being repaid.\n        uint256 amount,            /// Amount of tokens repaid.\n        uint256 share              /// Debt share associated with the repaid amount.\n    );\n\n    /// @notice Emitted when a user adds tokens as collateral.\n    event PutCollateral(\n        uint256 positionId,        /// Position ID associated with the collateral.\n        address owner,     /// Owner of the collateral position.\n        address caller,    /// Address of the spell caller adding the collateral.\n        address token,     /// Token used as collateral.\n        uint256 id,                /// ID of the wrapped token.\n        uint256 amount             /// Amount of tokens put as collateral.\n    );\n\n    /// @notice Emitted when a user retrieves tokens from their collateral.\n    event TakeCollateral(\n        uint256 positionId,        /// Position ID associated with the collateral.\n        address caller,    /// Address of the spell caller retrieving the collateral.\n        address token,     /// Token taken from the collateral.\n        uint256 id,                /// ID of the wrapped token.\n        uint256 amount             /// Amount of tokens taken from collateral.\n    );\n\n    /// @notice Emitted when a position is liquidated.\n    event Liquidate(\n        uint256 positionId,           /// Position ID being liquidated.\n        address liquidator,   /// Address of the user performing the liquidation.\n        address debtToken,    /// Debt token associated with the position.\n        uint256 amount,               /// Amount used for liquidation.\n        uint256 share,                /// Debt share associated with the liquidation.\n        uint256 positionSize,         /// Size of the position being liquidated.\n        uint256 underlyingVaultSize   /// Vault size underlying the liquidated position.\n    );\n\n    /// @notice Emitted when a position is executed.\n    event Execute(\n        uint256 positionId,        /// Position ID being executed.\n        address owner      /// Owner of the position.\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Returns the ID of the currently executed position.\n    /// @return Current position ID.\n    function POSITION_ID() external view returns (uint256);\n\n    /// @notice Returns the address of the currently executed spell.\n    /// @return Current spell address.\n    function SPELL() external view returns (address);\n\n    /// @notice Returns the current executor's address, which is the owner of the current position.\n    /// @return Address of the current executor.\n    function EXECUTOR() external view returns (address);\n\n    /// @notice Returns the next available position ID.\n    /// @return Next position ID.\n    function nextPositionId() external view returns (uint256);\n\n    /// @notice Provides the protocol configuration settings.\n    function config() external view returns (IProtocolConfig);\n\n    /// @notice Retrieves the active fee manager.\n    function feeManager() external view returns (IFeeManager);\n\n    /// @notice Provides the current oracle responsible for price feeds.\n    function oracle() external view returns (ICoreOracle);\n\n    /// @notice Fetches details of a bank given its token.\n    function getBankInfo(address token) external view returns (\n        bool isListed,           /// Indicates if the bank is listed.\n        address bToken,          /// Corresponding bToken of the bank.\n        uint256 totalShare       /// Total shared debt across all positions in this bank.\n    );\n    \n    /// @notice Computes the total debt value associated with a given position.\n    /// @dev Should call accrue first to get current debt\n    /// @param positionId The unique ID of the position.\n    /// @return The total debt value in USD.\n    function getDebtValue(uint256 positionId) external returns (uint256);\n\n    /// @notice Determines the overall value of a specified position.\n    /// @param positionId The unique ID of the position.\n    /// @return The total value of the position in USD.\n    function getPositionValue(uint256 positionId) external returns (uint256);\n\n    /// @notice Computes the isolated collateral value for a particular position.\n    /// @dev Should call accrue first to get current debt.\n    /// @param positionId The unique ID of the position.\n    /// @return icollValue The value of the isolated collateral in USD.\n    function getIsolatedCollateralValue(\n        uint256 positionId\n    ) external returns (uint256 icollValue);\n\n    /// @notice Provides comprehensive details about a position using its ID.\n    /// @param positionId The unique ID of the position.\n    /// @return A Position struct containing details of the position.\n    function getPositionInfo(\n        uint256 positionId\n    ) external view returns (Position memory);\n\n    /// @notice Fetches information about the currently active position.\n    /// @return A Position struct with details of the current position.\n    function getCurrentPositionInfo() external view returns (Position memory);\n\n    /// @notice Triggers interest accumulation and fetches the updated borrow balance.\n    /// @param positionId The unique ID of the position.\n    /// @return The updated debt balance after accruing interest.\n    function currentPositionDebt(uint256 positionId) external returns (uint256);\n\n    /// @notice Deposits tokens into the bank as a lender.\n    /// @param token The address of the token to deposit.\n    /// @param amount The amount of tokens to deposit.\n    function lend(address token, uint256 amount) external;\n\n    /// @notice Redeems deposited tokens from the bank.\n    /// @param token The address of the token to withdraw.\n    /// @param amount The amount of tokens to redeem.\n    function withdrawLend(address token, uint256 amount) external;\n\n    /// @notice Borrows tokens against collateral from the bank.\n    /// @param token The address of the token to borrow.\n    /// @param amount The amount of tokens to borrow.\n    /// @return The amount of tokens that are borrowed.\n    function borrow(address token, uint256 amount) external returns (uint256);\n\n    /// @notice Repays borrowed tokens to the bank.\n    /// @param token The address of the token to repay.\n    /// @param amountCall The amount of tokens to repay.\n    function repay(address token, uint256 amountCall) external;\n\n    /// @notice Increases the collateral backing a position.\n    /// @param collToken Address of the collateral token.\n    /// @param collId ID associated with the collateral type (if applicable).\n    /// @param amountCall Amount of collateral tokens to deposit.\n    function putCollateral(\n        address collToken,\n        uint256 collId,\n        uint256 amountCall\n    ) external;\n\n    /// @notice Redeems a portion of the collateral backing a position.\n    /// @param amount Amount of collateral tokens to redeem.\n    /// @return The actual amount of collateral redeemed.\n    function takeCollateral(uint256 amount) external returns (uint256);\n\n    /// @notice Liquidate a specific position.\n    /// @param positionId ID of the position to liquidate.\n    /// @param debtToken Address of the debt token.\n    /// @param amountCall Amount specified for the liquidation call.\n    function liquidate(\n        uint256 positionId,\n        address debtToken,\n        uint256 amountCall\n    ) external;\n\n    /// @notice Accrues interest for a given token.\n    /// @param token Address of the token to accrue interest for.\n    function accrue(address token) external;\n}\n"
    },
    "contracts/interfaces/IBaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\n/// @title IBaseOracle\n/// @notice Interface for a basic oracle that provides price data for assets.\ninterface IBaseOracle {\n    /// @notice Returns the USD value of a given ERC-20 token, normalized to 1e18 decimals.\n    /// @dev The value returned is multiplied by 10**18 to maintain precision.\n    /// @param token Address of the ERC-20 token for which the price is requested.\n    /// @return The USD price of the given token, multiplied by 10**18.\n    function getPrice(address token) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/ichi/IIchiFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IIchiFarm {\n    function lpToken(uint256 pid) external view returns (address);\n\n    function pendingIchi(\n        uint256 pid,\n        address user\n    ) external view returns (uint256);\n\n    function poolInfo(\n        uint256 pid\n    )\n        external\n        view\n        returns (\n            uint256 accIchiPerShare,\n            uint256 lastRewardBlock,\n            uint256 allocPoint\n        );\n\n    function userInfo(\n        uint256 pid,\n        address to\n    ) external view returns (uint256 amount, int256 rewardDebt);\n\n    function deposit(uint256 pid, uint256 amount, address to) external;\n\n    function withdraw(uint256 pid, uint256 amount, address to) external;\n\n    function harvest(uint256 pid, address to) external;\n}\n"
    },
    "contracts/interfaces/ichi/IIchiV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\n\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol';\n\ninterface IIchiV2 is IERC20Upgradeable, IERC20PermitUpgradeable {\n    // EIP-20 token name for this token\n    function name() external view returns (string memory);\n\n    // EIP-20 token symbol for this token\n    function symbol() external view returns (string memory);\n\n    // EIP-20 token decimals for this token\n    function decimals() external view returns (uint8);\n\n    // ICHI V1 address\n    function ichiV1() external view returns (address);\n\n    // Address which may mint inflationary tokens\n    function minter() external view returns (address);\n\n    // The timestamp after which inflationary minting may occur\n    function mintingAllowedAfter() external view returns (uint256);\n\n    // Minimum time between inflationary mints\n    function minimumTimeBetweenMints() external view returns (uint32);\n\n    // Cap on the percentage of totalSupply that can be minted at each inflationary mint\n    function mintCap() external view returns (uint8);\n\n    // ICHI V2 to ICHI V1 conversion fee (default is 0%)\n    function conversionFee() external view returns (uint256);\n\n    // A record of each accounts delegate\n    function delegates(address) external view returns (address);\n\n    // A record of votes checkpoints for each account, by index\n    function checkpoints(address, uint32)\n        external\n        view\n        returns (uint32, uint96);\n\n    // The number of checkpoints for each account\n    function numCheckpoints(address) external view returns (uint32);\n\n    // The EIP-712 typehash for the contract's domain\n    function DOMAIN_TYPEHASH() external view returns (bytes32);\n\n    // The EIP-712 typehash for the delegation struct used by the contract\n    function DELEGATION_TYPEHASH() external view returns (bytes32);\n\n    // The EIP-712 typehash for the permit struct used by the contract\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n\n    // An event thats emitted when the minter address is changed\n    event MinterChanged(address minter, address newMinter);\n\n    // An event thats emitted when an account changes its delegate\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    // An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    // An event thats emitted when ICHI V1 tokens are converted into ICHI V2 tokens\n    event ConvertedToV2(\n        address indexed from,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    // An event thats emitted when ICHI V2 tokens are converted into ICHI V1 tokens\n    event ConvertedToV1(\n        address indexed from,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    // An event thats emitted when the conversion fee is changed\n    event ConversionFeeChanged(address minter, uint256 fee);\n\n    /**\n     * @notice Change the minter address\n     * @param minter_ The address of the new minter\n     */\n    function setMinter(address minter_) external;\n\n    /**\n     * @notice Mint new tokens\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to be minted\n     */\n    function mint(address dst, uint256 rawAmount) external;\n\n    /**\n     * @notice Change the ICHI V2 to ICHI V1 conversion fee\n     * @param fee_ New conversion fee\n     */\n    function setConversionFee(uint256 fee_) external;\n\n    /**\n     * @notice Convert ICHI V1 tokens to ICHI V2 tokens\n     * @param rawAmount The number of ICHI V1 tokens to be converted (using 9 decimals representation)\n     */\n    function convertToV2(uint256 rawAmount) external;\n\n    /**\n     * @notice Convert ICHI V2 tokens back to ICHI V1 tokens\n     * @param rawAmount The number of ICHI V2 tokens to be converted (using 18 decimals representation)\n     */\n    function convertToV1(uint256 rawAmount) external;\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96);\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber)\n        external\n        view\n        returns (uint96);\n}\n"
    },
    "contracts/interfaces/ichi/IICHIVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IICHIVault is IERC20, IERC20Metadata {\n    function ichiVaultFactory() external view returns (address);\n\n    function pool() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function allowToken0() external view returns (bool);\n\n    function allowToken1() external view returns (bool);\n\n    function fee() external view returns (uint24);\n\n    function tickSpacing() external view returns (int24);\n\n    function currentTick() external view returns (int24);\n\n    function twapPeriod() external view returns (uint32);\n\n    function affiliate() external view returns (address);\n\n    function baseLower() external view returns (int24);\n\n    function baseUpper() external view returns (int24);\n\n    function limitLower() external view returns (int24);\n\n    function limitUpper() external view returns (int24);\n\n    function deposit0Max() external view returns (uint256);\n\n    function deposit1Max() external view returns (uint256);\n\n    function maxTotalSupply() external view returns (uint256);\n\n    function hysteresis() external view returns (uint256);\n\n    function getTotalAmounts() external view returns (uint256, uint256);\n\n    function deposit(uint256, uint256, address) external returns (uint256);\n\n    function withdraw(uint256, address) external returns (uint256, uint256);\n\n    function rebalance(\n        int24 _baseLower,\n        int24 _baseUpper,\n        int24 _limitLower,\n        int24 _limitUpper,\n        int256 swapQuantity\n    ) external;\n\n    function setDepositMax(uint256 _deposit0Max, uint256 _deposit1Max) external;\n\n    function setAffiliate(address _affiliate) external;\n\n    event DeployICHIVault(\n        address indexed sender,\n        address indexed pool,\n        bool allowToken0,\n        bool allowToken1,\n        address owner,\n        uint256 twapPeriod\n    );\n\n    event SetTwapPeriod(address sender, uint32 newTwapPeriod);\n\n    event Deposit(\n        address indexed sender,\n        address indexed to,\n        uint256 shares,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Withdraw(\n        address indexed sender,\n        address indexed to,\n        uint256 shares,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    event Rebalance(\n        int24 tick,\n        uint256 totalAmount0,\n        uint256 totalAmount1,\n        uint256 feeAmount0,\n        uint256 feeAmount1,\n        uint256 totalSupply\n    );\n\n    event MaxTotalSupply(address indexed sender, uint256 maxTotalSupply);\n\n    event Hysteresis(address indexed sender, uint256 hysteresis);\n\n    event DepositMax(\n        address indexed sender,\n        uint256 deposit0Max,\n        uint256 deposit1Max\n    );\n\n    event Affiliate(address indexed sender, address affiliate);\n}\n"
    },
    "contracts/interfaces/ichi/IICHIVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IICHIVaultFactory {\n    event FeeRecipient(address indexed sender, address feeRecipient);\n\n    event BaseFee(address indexed sender, uint256 baseFee);\n\n    event BaseFeeSplit(address indexed sender, uint256 baseFeeSplit);\n\n    event DeployICHIVaultFactory(\n        address indexed sender,\n        address uniswapV3Factory\n    );\n\n    event ICHIVaultCreated(\n        address indexed sender,\n        address ichiVault,\n        address tokenA,\n        bool allowTokenA,\n        address tokenB,\n        bool allowTokenB,\n        uint24 fee,\n        uint256 count\n    );\n\n    function uniswapV3Factory() external view returns (address);\n\n    function feeRecipient() external view returns (address);\n\n    function baseFee() external view returns (uint256);\n\n    function baseFeeSplit() external view returns (uint256);\n\n    function setFeeRecipient(address _feeRecipient) external;\n\n    function setBaseFee(uint256 _baseFee) external;\n\n    function setBaseFeeSplit(uint256 _baseFeeSplit) external;\n\n    function createICHIVault(\n        address tokenA,\n        bool allowTokenA,\n        address tokenB,\n        bool allowTokenB,\n        uint24 fee\n    ) external returns (address ichiVault);\n\n    function genKey(\n        address deployer,\n        address token0,\n        address token1,\n        uint24 fee,\n        bool allowToken0,\n        bool allowToken1\n    ) external pure returns (bytes32 key);\n}\n"
    },
    "contracts/interfaces/ICoreOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"./IBaseOracle.sol\";\n\n/// @title ICoreOracle\n/// @notice Interface for the CoreOracle contract which provides price feed data for assets in the Blueberry protocol.\ninterface ICoreOracle is IBaseOracle {\n    /*//////////////////////////////////////////////////////////////////////////\n                                       EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when the owner sets a new oracle route for a given token.\n    /// @param token The ERC20 token for which the oracle route is set.\n    /// @param route The address of the oracle route.\n    event SetRoute(address indexed token, address route);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Check if the given ERC20 token is supported by the oracle.\n    /// @param token The ERC20 token to check support for.\n    /// @return A boolean indicating whether the token is supported or not.\n    function isTokenSupported(address token) external returns (bool);\n\n    /// @notice Check if the oracle supports the underlying token of a given ERC1155 wrapper.\n    /// @dev Only meant to validate wrappers of the Blueberry protocol, such as WERC20.\n    /// @param token ERC1155 token address to check support for.\n    /// @param tokenId ERC1155 token id to check support for.\n    /// @return A boolean indicating whether the wrapped token is supported or not.\n    function isWrappedTokenSupported(\n        address token,\n        uint256 tokenId\n    ) external returns (bool);\n\n    /// @notice Returns the USD value of a specific wrapped ERC1155 token.\n    /// @param token ERC1155 token address.\n    /// @param id ERC1155 token id.\n    /// @param amount Amount of the token for which to get the USD value, normalized to 1e18 decimals.\n    /// @return The USD value of the given wrapped token amount.\n    function getWrappedTokenValue(\n        address token,\n        uint256 id,\n        uint256 amount\n    ) external returns (uint256);\n\n    /// @notice Returns the USD value of a given amount of a specific ERC20 token.\n    /// @param token ERC20 token address.\n    /// @param amount Amount of the ERC20 token for which to get the USD value.\n    /// @return The USD value of the given token amount.\n    function getTokenValue(\n        address token,\n        uint256 amount\n    ) external returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICurveOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"./IBaseOracle.sol\";\n\n/// @title ICurveOracle\n/// @notice Interface for the CurveOracle contract which provides price feed data for assets on Curve Finance.\ninterface ICurveOracle is IBaseOracle {\n    /// @notice Fetches relevant information about a Curve liquidity pool.\n    /// @param crvLp The address of the Curve liquidity pool token (LP token).\n    /// @return pool Address of the pool contract.\n    /// @return coins A list of underlying tokens in the Curve liquidity pool.\n    /// @return virtualPrice The current virtual price of the LP token for the given Curve liquidity pool.\n    function getPoolInfo(\n        address crvLp\n    )\n        external\n        returns (address pool, address[] memory coins, uint256 virtualPrice);\n}\n"
    },
    "contracts/interfaces/IERC20Wrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\n/// @title IERC20Wrapper\n/// @notice Interface for the ERC20Wrapper contract which allows the wrapping\n///         of ERC-20 tokens with associated ERC-1155 token IDs.\ninterface IERC20Wrapper {\n    /// @notice Fetches the underlying ERC-20 token address associated with the provided ERC-1155 token ID.\n    /// @param tokenId The ERC-1155 token ID for which the underlying ERC-20 token address is to be fetched.\n    /// @return The address of the underlying ERC-20 token.\n    function getUnderlyingToken(\n        uint256 tokenId\n    ) external view returns (address);\n\n    /// @notice Fetches pending rewards for a particular ERC-1155 token ID and given amount.\n    /// @param id The ERC-1155 token ID for which the pending rewards are to be fetched.\n    /// @param amount The amount for which pending rewards are to be calculated.\n    /// @return tokens A list of addresses representing reward tokens.\n    /// @return amounts A list of amounts corresponding to each reward token in the `tokens` list.\n    function pendingRewards(\n        uint256 id,\n        uint amount\n    ) external returns (address[] memory, uint256[] memory);\n}\n"
    },
    "contracts/interfaces/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/// @title IFeeManager\n/// @notice Interface for FeeManager, the central fee management contract in the Blueberry Protocol.\n/// @dev FeeManager is responsible for cutting various fees in the protocol and sending them to the treasury.\ninterface IFeeManager {\n\n    /// @notice Calculates and deducts the deposit fee when lending \n    ///         isolated underlying assets to Blueberry Money Market.\n    /// @param token The address of the underlying token for which the deposit fee is to be calculated.\n    /// @param amount The gross deposit amount before fees.\n    /// @return The net deposit amount after the fee deduction.\n    function doCutDepositFee(address token, uint256 amount)\n        external\n        returns (uint256);\n\n    /// @notice Calculates and deducts the withdrawal fee when redeeming \n    ///         isolated underlying tokens from Blueberry Money Market.\n    /// @param token The address of the underlying token for which the withdrawal fee is to be calculated.\n    /// @param amount The gross withdrawal amount before fees.\n    /// @return The net withdrawal amount after the fee deduction.\n    function doCutWithdrawFee(address token, uint256 amount)\n        external\n        returns (uint256);\n    /// @notice Calculates and deducts the performance fee from the \n    /// rewards generated due to the leveraged position.\n    /// @param token The address of the reward token for which the reward fee is to be calculated.\n    /// @param amount The gross reward amount before fees.\n    /// @return The net reward amount after the fee deduction.\n    function doCutRewardsFee(address token, uint256 amount)\n        external\n        returns (uint256);\n\n    /// @notice Calculates and deducts the vault withdrawal fee if \n    ///the withdrawal occurs within the specified fee window in the Blueberry Money Market.\n    /// @param token The address of the underlying token for which the vault withdrawal fee is to be calculated.\n    /// @param amount The gross vault withdrawal amount before fees.\n    /// @return The net vault withdrawal amount after the fee deduction.\n    function doCutVaultWithdrawFee(address token, uint256 amount)\n        external\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/IHardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\nimport \"./IERC20Wrapper.sol\";\n\n/// @title IHardVault\n/// @notice Interface for the HardVault, which integrates ERC1155 tokens with the protocol's underlying assets.\n/// @dev This interface facilitates the conversion between underlying ERC-20\n///      tokens and corresponding ERC-1155 representations within the protocol.\ninterface IHardVault is IERC1155Upgradeable {\n    /// @notice Retrieves the underlying ERC-20 token address corresponding to a specific ERC-1155 token ID.\n    /// @param tokenId The ERC-1155 token ID to fetch the underlying ERC-20 token for.\n    /// @return Address of the underlying ERC-20 token associated with the provided token ID.\n    function getUnderlyingToken(\n        uint256 tokenId\n    ) external view returns (address);\n\n    /// @notice Returns the balance of the underlying ERC-20 token for a specific user.\n    /// @param uToken Address of the ERC-20 token to query.\n    /// @param user Address of the user to query the balance for.\n    /// @return Balance of the underlying ERC-20 token for the given user.\n    function balanceOfERC20(\n        address uToken,\n        address user\n    ) external view returns (uint256);\n\n    /// @notice Deposit a certain amount of ERC-20 tokens to receive an equivalent amount of ERC-1155 representations.\n    /// @param uToken The address of the ERC-20 token to be deposited.\n    /// @param amount The quantity of ERC-20 tokens to be deposited.\n    /// @return shareAmount The amount of ERC-1155 tokens minted in exchange for the deposited ERC-20 tokens.\n    function deposit(\n        address uToken,\n        uint256 amount\n    ) external returns (uint256 shareAmount);\n\n    /// @notice Withdraw a certain amount of ERC-1155 tokens to \n    ///         receive an equivalent amount of underlying ERC-20 tokens.\n    /// @param uToken The address of the underlying ERC-20 token to be withdrawn.\n    /// @param shareAmount The quantity of ERC-1155 tokens to be withdrawn.\n    /// @return withdrawAmount The amount of ERC-20 tokens returned in exchange for the withdrawn ERC-1155 tokens.\n    function withdraw(\n        address uToken,\n        uint256 shareAmount\n    ) external returns (uint256 withdrawAmount);\n}\n"
    },
    "contracts/interfaces/IProtocolConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"./IFeeManager.sol\";\n\n/// @title IProtocolConfig\n/// @notice Interface for the Protocol Configuration, \n///         encapsulating various fees and related configuration parameters.\n/// @dev This interface defines methods to retrieve fees \n///      and related parameters that govern the behavior of the protocol.\ninterface IProtocolConfig {\n\n    /// @notice Retrieve the deposit fee rate applied when users deposit into the protocol.\n    /// @return The deposit fee rate.\n    function depositFee() external view returns (uint256);\n\n    /// @notice Retrieve the withdrawal fee rate applied when users withdraw from the protocol.\n    /// @return The withdrawal fee rate.\n    function withdrawFee() external view returns (uint256);\n\n    /// @notice Retrieve the reward fee rate applied when users claim rewards from the protocol.\n    /// @return The reward fee rate.\n    function rewardFee() external view returns (uint256);\n\n    /// @notice Get the address where protocol's collected fees are stored and managed.\n    /// @return The treasury address of the protocol.\n    function treasury() external view returns (address);\n\n    /// @notice Retrieve the fee rate applied for withdrawals from vaults.\n    /// @return The fee rate for vault withdrawals.\n    function withdrawVaultFee() external view returns (uint256);\n\n    /// @notice Retrieve the window of time where the vault withdrawal fee is applied.\n    /// @return The window of time where the vault withdrawal fee is applied.\n    function withdrawVaultFeeWindow() external view returns (uint256);\n\n    /// @notice Retrieve the start time of the window of time where the vault withdrawal fee is applied.\n    /// @return The start time of the window of time where the vault withdrawal fee is applied.\n    function withdrawVaultFeeWindowStartTime() external view returns (uint256);\n\n    /// @notice Get the fee manager that handles fee calculations and distributions.\n    /// @return An instance of the IFeeManager interface that manages fees within the protocol.\n    function feeManager() external view returns (IFeeManager);\n}\n"
    },
    "contracts/interfaces/ISoftVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport \"./compound/ICErc20.sol\";\n\n/// @title ISoftVault\n/// @notice Interface for the SoftVault, allowing deposits and withdrawals of assets.\n/// @dev The SoftVault is responsible for handling user deposits, \n///      withdrawals, and interactions with underlying Blueberry Money Market bTokens.\ninterface ISoftVault is IERC20Upgradeable {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                       EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when an account deposits assets.\n    /// @param account Address of the account that deposited.\n    /// @param amount The amount of underlying assets deposited.\n    /// @param shareAmount The corresponding amount of vault shares minted.\n\n    event Deposited(\n        address indexed account,\n        uint256 amount,\n        uint256 shareAmount\n    );\n\n    /// @notice Event emitted when an account withdraws assets.\n    /// @param account Address of the account that withdrew.\n    /// @param amount The amount of underlying assets withdrawn.\n    /// @param shareAmount The corresponding amount of vault shares burned.    \n    event Withdrawn(\n        address indexed account,\n        uint256 amount,\n        uint256 shareAmount\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the corresponding Blueberry Money Market bToken for this vault.\n    /// @return A Blueberry Money Market bToken interface.\n    function bToken() external view returns (ICErc20);\n\n    /// @notice Get the underlying ERC20 token for this vault.\n    /// @return An ERC20 interface of the underlying token.\n    function uToken() external view returns (IERC20Upgradeable);\n\n    /// @notice Deposit a specified amount of the underlying asset into the vault.\n    /// @dev This function will convert the deposited assets into the corresponding bToken.\n    /// @param amount The amount of the underlying asset to deposit.\n    /// @return shareAmount The amount of vault shares minted for the deposit.\n    function deposit(uint256 amount) external returns (uint256 shareAmount);\n\n    /// @notice Withdraw a specified amount of the underlying asset from the vault.\n    /// @dev This function will convert the corresponding bToken back into the underlying asset.\n    /// @param amount The amount of vault shares to redeem.\n    /// @return withdrawAmount The amount of the underlying asset withdrawn.\n    function withdraw(uint256 amount) external returns (uint256 withdrawAmount);\n}\n"
    },
    "contracts/interfaces/IWAuraPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./IERC20Wrapper.sol\";\nimport \"./balancer/IBalancerPool.sol\";\nimport \"./balancer/IBalancerVault.sol\";\nimport \"./aura/IAuraPools.sol\";\nimport \"./aura/IAura.sol\";\n\n/// @title IWAuraPools\n/// @notice Interface for interacting with Aura pools wrapped as ERC1155 tokens.\n/// @dev This allows users to interact with Balancer-based Aura pools, \n///      staking liquidity pool tokens for rewards.\ninterface IWAuraPools is IERC1155Upgradeable, IERC20Wrapper {\n    /// @notice Get the AURA token's contract address.\n    /// @return An IAura interface of the AURA token.\n    function AURA() external view returns (IAura);\n\n    /// @notice Get the stash AURA token's contract address.\n    /// @return Address of the STASH AURA token.\n    function STASH_AURA() external view returns (address);\n\n    /// @notice Encode two uint values into a single uint.\n    function encodeId(uint, uint) external pure returns (uint);\n\n    /// @notice Decode an encoded ID into two separate uint values.\n    /// @param id The encoded uint ID to decode.\n    /// @return The two individual uint values decoded from the provided ID.\n    function decodeId(uint id) external pure returns (uint, uint);\n\n    /// @notice Fetch the pool tokens, balances and last changed block for a given Balancer Pool Token.\n    /// @param bpt The address of the Balancer Pool Token.\n    /// @return tokens An array of tokens inside the Balancer Pool.\n    /// @return balances An array of token balances inside the Balancer Pool.\n    /// @return lastChangedBlock The block number when the pool was last changed.\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        );\n\n    /// @notice Get the pool ID for a given Balancer Pool Token.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @return The bytes32 pool ID associated with the BPT.\n    function getBPTPoolId(address bpt) external view returns (bytes32);\n\n    /// @notice Fetch the Balancer Vault associated with a given Balancer Pool Token.\n    /// @param bpt The address of the Balancer Pool Token.\n    /// @return An IBalancerVault interface of the associated vault.\n    function getVault(address bpt) external view returns (IBalancerVault);\n\n    /// @notice Fetch the Aura Pools contract interface.\n    /// @return The IAuraPools interface of the Aura Pools.\n    function auraPools() external view returns (IAuraPools);\n\n    /// @notice Fetch detailed information for a specific Aura pool using its pool ID.\n    /// @param pid The pool ID.\n    /// @return lptoken The liquidity provider token's address for the specific pool.\n    /// @return token The reward token's address for the specific pool.\n    /// @return gauge The gauge contract's address for the specific pool.\n    /// @return crvRewards The Curve rewards contract's address associated with the specific pool.\n    /// @return stash The stash contract's address associated with the specific pool.\n    /// @return shutdown A boolean indicating if the pool is in shutdown mode.\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n\n    /// @notice Mint an ERC1155 token corresponding to a staked amount in a specific Aura pool.\n    /// @param gid The pool ID representing the specific Aura pool.\n    /// @param amount The amount of liquidity provider tokens to stake.\n    /// @return id The ID of the newly minted ERC1155 token representing the staked position.\n    function mint(uint gid, uint amount) external returns (uint id);\n\n    /// @notice Burn an ERC1155 token to redeem staked liquidity provider tokens and any earned rewards.\n    /// @param id The ID of the ERC1155 token representing the staked position.\n    /// @param amount The amount of ERC1155 tokens to burn.\n    /// @return rewardTokens An array of reward token addresses.\n    /// @return rewards An array of reward amounts corresponding to the reward token addresses.\n    function burn(\n        uint id,\n        uint amount\n    )\n        external\n        returns (address[] memory rewardTokens, uint256[] memory rewards);\n}\n"
    },
    "contracts/interfaces/IWConvexPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./IERC20Wrapper.sol\";\nimport \"./convex/ICvxPools.sol\";\nimport \"./convex/IConvex.sol\";\n\n/// @title IWConvexPools\n/// @notice Interface for interacting with Convex pools represented as ERC1155 tokens.\n/// @dev Convex pools allow users to stake liquidity pool tokens in return for CVX and other rewards.\ninterface IWConvexPools is IERC1155Upgradeable, IERC20Wrapper {\n    /// @notice Fetch the CVX token contract interface.\n    /// @return The IConvex interface of the CVX token.\n    function CVX() external view returns (IConvex);\n\n    /// @notice Mint an ERC1155 token corresponding to a staked amount in a specific Convex pool.\n    /// @param gid The pool ID representing the specific Convex pool.\n    /// @param amount The amount of liquidity provider tokens to stake.\n    /// @return id The ID of the newly minted ERC1155 token representing the staked position.\n    function mint(uint gid, uint amount) external returns (uint id);\n\n    /// @notice Burn an ERC1155 token to redeem staked liquidity provider tokens and any earned rewards.\n    /// @param id The ID of the ERC1155 token representing the staked position.\n    /// @param amount The amount of ERC1155 tokens to burn.\n    /// @return rewardTokens An array of reward token addresses.\n    /// @return rewards An array of reward amounts corresponding to the reward token addresses.\n    function burn(\n        uint id,\n        uint amount\n    )\n        external\n        returns (address[] memory rewardTokens, uint256[] memory rewards);\n\n    /// @notice Fetch the Convex Pool contract interface.\n    /// @return The ICvxPools interface of the Convex Pool.\n    function cvxPools() external view returns (ICvxPools);\n\n\n    /// @notice Encode two uint values into a single uint.\n    function encodeId(uint, uint) external pure returns (uint);\n\n    /// @notice Decode an encoded ID into two separate uint values.\n    /// @param id The encoded uint ID to decode.\n    /// @return The two individual uint values decoded from the provided ID.\n    function decodeId(uint id) external pure returns (uint, uint);\n\n    /// @notice Fetch detailed information for a specific Convex pool using its pool ID.\n    /// @param pid The pool ID.\n    /// @return lptoken The liquidity provider token's address for the specific pool.\n    /// @return token The reward token's address for the specific pool.\n    /// @return gauge The gauge contract's address for the specific pool.\n    /// @return crvRewards The Curve rewards contract's address associated with the specific pool.\n    /// @return stash The stash contract's address associated with the specific pool.\n    /// @return shutdown A boolean indicating if the pool is in shutdown mode.\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        external\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        );\n}\n"
    },
    "contracts/interfaces/IWCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\nimport \"./IERC20Wrapper.sol\";\nimport \"./curve/ICurveRegistry.sol\";\nimport \"./curve/ILiquidityGauge.sol\";\nimport \"./curve/ICurveGaugeController.sol\";\n\n/// @title IWCurveGauge\n/// @notice This interface defines the functionality for interacting\n///         with Curve's Liquidity Gauges represented as ERC1155 tokens.\n/// @dev Curve's Liquidity Gauges allow users to stake liquidity \n///      provider tokens in return for CRV rewards.\ninterface IWCurveGauge is IERC1155Upgradeable, IERC20Wrapper {\n\n    /// @notice Fetch the CRV token address.\n    /// @return An ERC20-compatible address of the CRV token.\n    function CRV() external view returns (IERC20Upgradeable);\n\n    /// @notice Mint an ERC1155 token corresponding to a staked amount in a specific Curve Liquidity Gauge.\n    /// @param gid The gauge ID representing the specific Curve Liquidity Gauge.\n    /// @param amount The amount of liquidity provider tokens to stake.\n    /// @return id The ID of the newly minted ERC1155 token representing the staked position.\n    function mint(uint gid, uint amount) external returns (uint id);\n\n    /// @notice Burn an ERC1155 token to redeem staked liquidity provider tokens and any earned rewards.\n    /// @param id The ID of the ERC1155 token representing the staked position.\n    /// @param amount The amount of ERC1155 tokens to burn.\n    /// @return pid The gauge ID from which the tokens were redeemed.\n    function burn(uint id, uint amount) external returns (uint pid);\n\n    /// @notice Fetch the Curve Registry address.\n    /// @return The address of the Curve Registry.\n    function registry() external view returns (ICurveRegistry);\n\n    /// @notice Fetch the Curve Gauge Controller address.\n    /// @return The address of the Curve Gauge Controller.\n    function gaugeController() external view returns (ICurveGaugeController);\n\n    /// @notice Encode two uint values into a single uint.\n    function encodeId(uint, uint) external pure returns (uint);\n\n    /// @notice Decode an encoded ID into two separate uint values.\n    /// @param id The encoded uint ID to decode.\n    /// @return The two individual uint values decoded from the provided ID.\n    function decodeId(uint id) external pure returns (uint, uint);\n\n    /// @notice Fetch the liquidity provider (LP) token address associated with a specific gauge ID.\n    /// @param gid The gauge ID.\n    /// @return The address of the liquidity provider token associated with the provided gauge ID.\n    function getLpFromGaugeId(uint256 gid) external view returns (address);\n}\n"
    },
    "contracts/interfaces/IWERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\nimport \"./IERC20Wrapper.sol\";\n\n/// @title IWERC20\n/// @notice This interface defines the functionality of the Wrapped ERC20 (WERC20) token.\n/// @dev WERC20 tokens enable ERC20 tokens to be represented \n///      as ERC1155 tokens, providing batch transfer capabilities and more.\ninterface IWERC20 is IERC1155Upgradeable, IERC20Wrapper {\n    /// @notice Fetch the balance of `user` for a specific underlying ERC20 token.\n    /// @param token The address of the underlying ERC20 token.\n    /// @param user The address of the user whose balance will be retrieved.\n    /// @return The balance of the given user's address in terms of the underlying ERC20 token.\n    function balanceOfERC20(\n        address token,\n        address user\n    ) external view returns (uint256);\n\n    /// @notice Mint a new ERC1155 token corresponding to a given ERC20 token.\n    /// @param token The address of the ERC20 token being wrapped.\n    /// @param amount The amount of ERC20 tokens to wrap into the new ERC1155 token.\n    /// @return id The ID of the newly minted ERC1155 token.\n    function mint(address token, uint256 amount) external returns (uint256 id);\n\n    /// @notice Burn an ERC1155 token to redeem the underlying ERC20 token.\n    /// @param token The address of the underlying ERC20 token to redeem.\n    /// @param amount The amount of ERC1155 tokens to burn.\n    /// @dev This function redeems the ERC20 tokens and sends them back to the caller.\n    function burn(address token, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\n/// @title IWETH\n/// @notice This is the interface for the Wrapped Ether (WETH) contract.\n/// @dev WETH is an ERC20-compatible version of Ether, facilitating interactions in smart contracts.\ninterface IWETH {\n    \n    /// @notice Fetch the balance of `user` in terms of WETH.\n    /// @param user The address of the account whose balance will be retrieved.\n    /// @return The balance of the given user's address.\n    function balanceOf(address user) external view returns (uint256);\n\n    /// @notice Approve an address to spend WETH on behalf of the message sender.\n    /// @param to The address to grant spending rights.\n    /// @param value The amount of WETH the spender is allowed to transfer.\n    /// @return A boolean value indicating whether the operation succeeded.\n    function approve(address to, uint256 value) external returns (bool);\n\n    /// @notice Transfer WETH from the message sender to another address.\n    /// @param to The recipient address.\n    /// @param value The amount of WETH to be transferred.\n    /// @return A boolean value indicating whether the transfer was successful.\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /// @notice Convert Ether to WETH by sending Ether to the contract.\n    /// @dev This function should be called with a payable modifier to attach Ether.\n    function deposit() external payable;\n\n    /// @notice Convert WETH back into Ether and send it to the message sender.\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/IWIchiFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\";\n\nimport \"./IERC20Wrapper.sol\";\nimport \"./ichi/IIchiV2.sol\";\nimport \"./ichi/IIchiFarm.sol\";\n\n\n/// @title IWIchiFarm\n/// @notice This is the interface for the WIchiFarm contract\n/// @dev WIchiFarm contract integrates both ERC1155 and ERC20Wrapper functionalities.\ninterface IWIchiFarm is IERC1155Upgradeable, IERC20Wrapper {\n    \n    /// @notice Fetch the address of the legacy ICHI token.\n    /// @return A IIchiV2 interface representing the legacy ICHI token.\n    function ICHI() external view returns (IIchiV2);\n\n    /// @notice Fetch the address of the ICHI farming contract.\n    /// @return A IIchiFarm interface representing the ICHI farming contract.\n    function ichiFarm() external view returns (IIchiFarm);\n\n    /// @notice Decode the given ID to obtain its constituent values.\n    /// @param id The encoded ID.\n    /// @return Two uint256 values derived from the given ID.\n    function decodeId(uint256 id) external pure returns (uint256, uint256);\n\n    /// @notice Mint the corresponding ERC1155 tokens based on a given pid and amount.\n    /// @param pid The product id, representing a specific token.\n    /// @param amount The amount of tokens to be minted.\n    /// @return A uint256 representing the minted token's ID.\n    function mint(uint256 pid, uint256 amount) external returns (uint256);\n\n    /// @notice Burn the ERC1155 tokens based on a given id and amount.\n    /// @param id The ID of the ERC1155 token to be burned.\n    /// @param amount The amount of tokens to be burned.\n    function burn(uint256 id, uint256 amount) external returns (uint256 pid);\n}\n"
    },
    "contracts/interfaces/paraswap/IParaswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../libraries/Paraswap/Utils.sol\";\n\ninterface IParaswap {\n    event Swapped(\n        bytes16 uuid,\n        address initiator,\n        address indexed beneficiary,\n        address indexed srcToken,\n        address indexed destToken,\n        uint256 srcAmount,\n        uint256 receivedAmount,\n        uint256 expectedAmount\n    );\n\n    event Bought(\n        bytes16 uuid,\n        address initiator,\n        address indexed beneficiary,\n        address indexed srcToken,\n        address indexed destToken,\n        uint256 srcAmount,\n        uint256 receivedAmount\n    );\n\n    event FeeTaken(uint256 fee, uint256 partnerShare, uint256 paraswapShare);\n\n    function multiSwap(\n        Utils.SellData calldata data\n    ) external payable returns (uint256);\n\n    function megaSwap(\n        Utils.MegaSwapSellData calldata data\n    ) external payable returns (uint256);\n\n    function protectedMultiSwap(\n        Utils.SellData calldata data\n    ) external payable returns (uint256);\n\n    function protectedMegaSwap(\n        Utils.MegaSwapSellData calldata data\n    ) external payable returns (uint256);\n\n    function protectedSimpleSwap(\n        Utils.SimpleData calldata data\n    ) external payable returns (uint256 receivedAmount);\n\n    function protectedSimpleBuy(\n        Utils.SimpleData calldata data\n    ) external payable;\n\n    function simpleSwap(\n        Utils.SimpleData calldata data\n    ) external payable returns (uint256 receivedAmount);\n\n    function simpleBuy(Utils.SimpleData calldata data) external payable;\n\n    function swapOnUniswap(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external payable;\n\n    function swapOnUniswapFork(\n        address factory,\n        bytes32 initCode,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external payable;\n\n    function buyOnUniswap(\n        uint256 amountInMax,\n        uint256 amountOut,\n        address[] calldata path\n    ) external payable;\n\n    function buyOnUniswapFork(\n        address factory,\n        bytes32 initCode,\n        uint256 amountInMax,\n        uint256 amountOut,\n        address[] calldata path\n    ) external payable;\n\n    function swapOnUniswapV2Fork(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address weth,\n        uint256[] calldata pools\n    ) external payable;\n\n    function buyOnUniswapV2Fork(\n        address tokenIn,\n        uint256 amountInMax,\n        uint256 amountOut,\n        address weth,\n        uint256[] calldata pools\n    ) external payable;\n\n    function swapOnZeroXv2(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 fromAmount,\n        uint256 amountOutMin,\n        address exchange,\n        bytes calldata payload\n    ) external payable;\n\n    function swapOnZeroXv4(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 fromAmount,\n        uint256 amountOutMin,\n        address exchange,\n        bytes calldata payload\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/sushi/IMasterChef.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ninterface IMasterChef {\n    function sushi() external view returns (address);\n\n    function userInfo(uint256 pid, address user)\n        external\n        view\n        returns (uint256 amount, uint256 rewardDebt);\n\n    function poolInfo(uint256 pid)\n        external\n        view\n        returns (\n            address lpToken,\n            uint256 allocPoint,\n            uint256 lastRewardBlock,\n            uint256 accSushiPerShare\n        );\n\n    function deposit(uint256 pid, uint256 amount) external;\n\n    function withdraw(uint256 pid, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/uniswap/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\";\n"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n"
    },
    "contracts/interfaces/uniswap/IUniswapV3Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IUniswapV3Router is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(\n        ExactOutputSingleParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/libraries/balancer/BalancerErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/// Forked from https://github.com/balancer-labs/balancer-v2-monorepo/blob/3703c43c89dc693b918d20ebb0d9e4b205d31c2c/contracts/lib/helpers/BalancerErrors.sol\n/// Updated solidity version to 0.8.X\n\n// solhint-disable\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _require(bool condition, uint256 errorCode) pure {\n    if (!condition) _revert(errorCode);\n}\n\n/**\n * @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 999 are\n * supported.\n */\nfunction _require(bool condition, uint256 errorCode, bytes3 prefix) pure {\n    if (!condition) _revert(errorCode, prefix);\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n * Uses the default 'BAL' prefix for the error code\n */\nfunction _revert(uint256 errorCode) pure {\n    _revert(errorCode, 0x42414c); // This is the raw byte representation of \"BAL\"\n}\n\n/**\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 999 are supported.\n */\nfunction _revert(uint256 errorCode, bytes3 prefix) pure {\n    uint256 prefixUint = uint256(uint24(prefix));\n    // We're going to dynamically create a revert string based on the error code, with the following format:\n    // 'BAL#{errorCode}'\n    // where the code is left-padded with zeroes to three digits (so they range from 000 to 999).\n    //\n    // We don't have revert strings embedded in the contract to save bytecode size: it takes much less space to store a\n    // number (8 to 16 bits) than the individual string characters.\n    //\n    // The dynamic string creation algorithm that follows could be implemented in Solidity, but assembly allows for a\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\n    assembly {\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-999\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\n        // the '0' character.\n\n        let units := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let tenths := add(mod(errorCode, 10), 0x30)\n\n        errorCode := div(errorCode, 10)\n        let hundreds := add(mod(errorCode, 10), 0x30)\n\n        // With the individual characters, we can now construct the full string.\n        // We first append the '#' character (0x23) to the prefix. In the case of 'BAL', it results in 0x42414c23 ('BAL#')\n        // Then, we shift this by 24 (to provide space for the 3 bytes of the error code), and add the\n        // characters to it, each shifted by a multiple of 8.\n        // The revert reason is then shifted left by 200 bits (256 minus the length of the string, 7 characters * 8 bits\n        // per character = 56) to locate it in the most significant part of the 256 slot (the beginning of a byte\n        // array).\n        let formattedPrefix := shl(24, add(0x23, shl(8, prefixUint)))\n\n        let revertReason := shl(200, add(formattedPrefix, add(add(units, shl(8, tenths)), shl(16, hundreds))))\n\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\n        // message will have the following layout:\n        // [ revert reason identifier ] [ string location offset ] [ string length ] [ string contents ]\n\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(string) function. We\n        // also write zeroes to the next 28 bytes of memory, but those are about to be overwritten.\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n        // Next is the offset to the location of the string, which will be placed immediately after (20 bytes away).\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\n        // The string length is fixed: 7 characters.\n        mstore(0x24, 7)\n        // Finally, the string itself is stored.\n        mstore(0x44, revertReason)\n\n        // Even if the string is only 7 bytes long, we need to return a full 32 byte slot containing it. The length of\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\n        revert(0, 100)\n    }\n}\n\nlibrary Errors {\n    // Math\n    uint256 internal constant ADD_OVERFLOW = 0;\n    uint256 internal constant SUB_OVERFLOW = 1;\n    uint256 internal constant SUB_UNDERFLOW = 2;\n    uint256 internal constant MUL_OVERFLOW = 3;\n    uint256 internal constant ZERO_DIVISION = 4;\n    uint256 internal constant DIV_INTERNAL = 5;\n    uint256 internal constant X_OUT_OF_BOUNDS = 6;\n    uint256 internal constant Y_OUT_OF_BOUNDS = 7;\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 8;\n    uint256 internal constant INVALID_EXPONENT = 9;\n\n    // Input\n    uint256 internal constant OUT_OF_BOUNDS = 100;\n    uint256 internal constant UNSORTED_ARRAY = 101;\n    uint256 internal constant UNSORTED_TOKENS = 102;\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 103;\n    uint256 internal constant ZERO_TOKEN = 104;\n\n    // Shared pools\n    uint256 internal constant MIN_TOKENS = 200;\n    uint256 internal constant MAX_TOKENS = 201;\n    uint256 internal constant MAX_SWAP_FEE_PERCENTAGE = 202;\n    uint256 internal constant MIN_SWAP_FEE_PERCENTAGE = 203;\n    uint256 internal constant MINIMUM_BPT = 204;\n    uint256 internal constant CALLER_NOT_VAULT = 205;\n    uint256 internal constant UNINITIALIZED = 206;\n    uint256 internal constant BPT_IN_MAX_AMOUNT = 207;\n    uint256 internal constant BPT_OUT_MIN_AMOUNT = 208;\n    uint256 internal constant EXPIRED_PERMIT = 209;\n    uint256 internal constant NOT_TWO_TOKENS = 210;\n    uint256 internal constant DISABLED = 211;\n\n    // Pools\n    uint256 internal constant MIN_AMP = 300;\n    uint256 internal constant MAX_AMP = 301;\n    uint256 internal constant MIN_WEIGHT = 302;\n    uint256 internal constant MAX_STABLE_TOKENS = 303;\n    uint256 internal constant MAX_IN_RATIO = 304;\n    uint256 internal constant MAX_OUT_RATIO = 305;\n    uint256 internal constant MIN_BPT_IN_FOR_TOKEN_OUT = 306;\n    uint256 internal constant MAX_OUT_BPT_FOR_TOKEN_IN = 307;\n    uint256 internal constant NORMALIZED_WEIGHT_INVARIANT = 308;\n    uint256 internal constant INVALID_TOKEN = 309;\n    uint256 internal constant UNHANDLED_JOIN_KIND = 310;\n    uint256 internal constant ZERO_INVARIANT = 311;\n    uint256 internal constant ORACLE_INVALID_SECONDS_QUERY = 312;\n    uint256 internal constant ORACLE_NOT_INITIALIZED = 313;\n    uint256 internal constant ORACLE_QUERY_TOO_OLD = 314;\n    uint256 internal constant ORACLE_INVALID_INDEX = 315;\n    uint256 internal constant ORACLE_BAD_SECS = 316;\n    uint256 internal constant AMP_END_TIME_TOO_CLOSE = 317;\n    uint256 internal constant AMP_ONGOING_UPDATE = 318;\n    uint256 internal constant AMP_RATE_TOO_HIGH = 319;\n    uint256 internal constant AMP_NO_ONGOING_UPDATE = 320;\n    uint256 internal constant STABLE_INVARIANT_DIDNT_CONVERGE = 321;\n    uint256 internal constant STABLE_GET_BALANCE_DIDNT_CONVERGE = 322;\n    uint256 internal constant RELAYER_NOT_CONTRACT = 323;\n    uint256 internal constant BASE_POOL_RELAYER_NOT_CALLED = 324;\n    uint256 internal constant REBALANCING_RELAYER_REENTERED = 325;\n    uint256 internal constant GRADUAL_UPDATE_TIME_TRAVEL = 326;\n    uint256 internal constant SWAPS_DISABLED = 327;\n    uint256 internal constant CALLER_IS_NOT_LBP_OWNER = 328;\n    uint256 internal constant PRICE_RATE_OVERFLOW = 329;\n    uint256 internal constant INVALID_JOIN_EXIT_KIND_WHILE_SWAPS_DISABLED = 330;\n    uint256 internal constant WEIGHT_CHANGE_TOO_FAST = 331;\n    uint256 internal constant LOWER_GREATER_THAN_UPPER_TARGET = 332;\n    uint256 internal constant UPPER_TARGET_TOO_HIGH = 333;\n    uint256 internal constant UNHANDLED_BY_LINEAR_POOL = 334;\n    uint256 internal constant OUT_OF_TARGET_RANGE = 335;\n    uint256 internal constant UNHANDLED_EXIT_KIND = 336;\n    uint256 internal constant UNAUTHORIZED_EXIT = 337;\n    uint256 internal constant MAX_MANAGEMENT_SWAP_FEE_PERCENTAGE = 338;\n    uint256 internal constant UNHANDLED_BY_MANAGED_POOL = 339;\n    uint256 internal constant UNHANDLED_BY_PHANTOM_POOL = 340;\n    uint256 internal constant TOKEN_DOES_NOT_HAVE_RATE_PROVIDER = 341;\n    uint256 internal constant INVALID_INITIALIZATION = 342;\n    uint256 internal constant OUT_OF_NEW_TARGET_RANGE = 343;\n    uint256 internal constant FEATURE_DISABLED = 344;\n    uint256 internal constant UNINITIALIZED_POOL_CONTROLLER = 345;\n    uint256 internal constant SET_SWAP_FEE_DURING_FEE_CHANGE = 346;\n    uint256 internal constant SET_SWAP_FEE_PENDING_FEE_CHANGE = 347;\n    uint256 internal constant CHANGE_TOKENS_DURING_WEIGHT_CHANGE = 348;\n    uint256 internal constant CHANGE_TOKENS_PENDING_WEIGHT_CHANGE = 349;\n    uint256 internal constant MAX_WEIGHT = 350;\n    uint256 internal constant UNAUTHORIZED_JOIN = 351;\n    uint256 internal constant MAX_MANAGEMENT_AUM_FEE_PERCENTAGE = 352;\n    uint256 internal constant FRACTIONAL_TARGET = 353;\n\n    // Lib\n    uint256 internal constant REENTRANCY = 400;\n    uint256 internal constant SENDER_NOT_ALLOWED = 401;\n    uint256 internal constant PAUSED = 402;\n    uint256 internal constant PAUSE_WINDOW_EXPIRED = 403;\n    uint256 internal constant MAX_PAUSE_WINDOW_DURATION = 404;\n    uint256 internal constant MAX_BUFFER_PERIOD_DURATION = 405;\n    uint256 internal constant INSUFFICIENT_BALANCE = 406;\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 407;\n    uint256 internal constant ERC20_TRANSFER_FROM_ZERO_ADDRESS = 408;\n    uint256 internal constant ERC20_TRANSFER_TO_ZERO_ADDRESS = 409;\n    uint256 internal constant ERC20_MINT_TO_ZERO_ADDRESS = 410;\n    uint256 internal constant ERC20_BURN_FROM_ZERO_ADDRESS = 411;\n    uint256 internal constant ERC20_APPROVE_FROM_ZERO_ADDRESS = 412;\n    uint256 internal constant ERC20_APPROVE_TO_ZERO_ADDRESS = 413;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_ALLOWANCE = 414;\n    uint256 internal constant ERC20_DECREASED_ALLOWANCE_BELOW_ZERO = 415;\n    uint256 internal constant ERC20_TRANSFER_EXCEEDS_BALANCE = 416;\n    uint256 internal constant ERC20_BURN_EXCEEDS_ALLOWANCE = 417;\n    uint256 internal constant SAFE_ERC20_CALL_FAILED = 418;\n    uint256 internal constant ADDRESS_INSUFFICIENT_BALANCE = 419;\n    uint256 internal constant ADDRESS_CANNOT_SEND_VALUE = 420;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_INT256 = 421;\n    uint256 internal constant GRANT_SENDER_NOT_ADMIN = 422;\n    uint256 internal constant REVOKE_SENDER_NOT_ADMIN = 423;\n    uint256 internal constant RENOUNCE_SENDER_NOT_ALLOWED = 424;\n    uint256 internal constant BUFFER_PERIOD_EXPIRED = 425;\n    uint256 internal constant CALLER_IS_NOT_OWNER = 426;\n    uint256 internal constant NEW_OWNER_IS_ZERO = 427;\n    uint256 internal constant CODE_DEPLOYMENT_FAILED = 428;\n    uint256 internal constant CALL_TO_NON_CONTRACT = 429;\n    uint256 internal constant LOW_LEVEL_CALL_FAILED = 430;\n    uint256 internal constant NOT_PAUSED = 431;\n    uint256 internal constant ADDRESS_ALREADY_ALLOWLISTED = 432;\n    uint256 internal constant ADDRESS_NOT_ALLOWLISTED = 433;\n    uint256 internal constant ERC20_BURN_EXCEEDS_BALANCE = 434;\n    uint256 internal constant INVALID_OPERATION = 435;\n    uint256 internal constant CODEC_OVERFLOW = 436;\n    uint256 internal constant IN_RECOVERY_MODE = 437;\n    uint256 internal constant NOT_IN_RECOVERY_MODE = 438;\n    uint256 internal constant INDUCED_FAILURE = 439;\n    uint256 internal constant EXPIRED_SIGNATURE = 440;\n    uint256 internal constant MALFORMED_SIGNATURE = 441;\n    uint256 internal constant SAFE_CAST_VALUE_CANT_FIT_UINT64 = 442;\n    uint256 internal constant UNHANDLED_FEE_TYPE = 443;\n\n    // Vault\n    uint256 internal constant INVALID_POOL_ID = 500;\n    uint256 internal constant CALLER_NOT_POOL = 501;\n    uint256 internal constant SENDER_NOT_ASSET_MANAGER = 502;\n    uint256 internal constant USER_DOESNT_ALLOW_RELAYER = 503;\n    uint256 internal constant INVALID_SIGNATURE = 504;\n    uint256 internal constant EXIT_BELOW_MIN = 505;\n    uint256 internal constant JOIN_ABOVE_MAX = 506;\n    uint256 internal constant SWAP_LIMIT = 507;\n    uint256 internal constant SWAP_DEADLINE = 508;\n    uint256 internal constant CANNOT_SWAP_SAME_TOKEN = 509;\n    uint256 internal constant UNKNOWN_AMOUNT_IN_FIRST_SWAP = 510;\n    uint256 internal constant MALCONSTRUCTED_MULTIHOP_SWAP = 511;\n    uint256 internal constant INTERNAL_BALANCE_OVERFLOW = 512;\n    uint256 internal constant INSUFFICIENT_INTERNAL_BALANCE = 513;\n    uint256 internal constant INVALID_ETH_INTERNAL_BALANCE = 514;\n    uint256 internal constant INVALID_POST_LOAN_BALANCE = 515;\n    uint256 internal constant INSUFFICIENT_ETH = 516;\n    uint256 internal constant UNALLOCATED_ETH = 517;\n    uint256 internal constant ETH_TRANSFER = 518;\n    uint256 internal constant CANNOT_USE_ETH_SENTINEL = 519;\n    uint256 internal constant TOKENS_MISMATCH = 520;\n    uint256 internal constant TOKEN_NOT_REGISTERED = 521;\n    uint256 internal constant TOKEN_ALREADY_REGISTERED = 522;\n    uint256 internal constant TOKENS_ALREADY_SET = 523;\n    uint256 internal constant TOKENS_LENGTH_MUST_BE_2 = 524;\n    uint256 internal constant NONZERO_TOKEN_BALANCE = 525;\n    uint256 internal constant BALANCE_TOTAL_OVERFLOW = 526;\n    uint256 internal constant POOL_NO_TOKENS = 527;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_BALANCE = 528;\n\n    // Fees\n    uint256 internal constant SWAP_FEE_PERCENTAGE_TOO_HIGH = 600;\n    uint256 internal constant FLASH_LOAN_FEE_PERCENTAGE_TOO_HIGH = 601;\n    uint256 internal constant INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT = 602;\n    uint256 internal constant AUM_FEE_PERCENTAGE_TOO_HIGH = 603;\n\n    // Misc\n    uint256 internal constant UNIMPLEMENTED = 998;\n    uint256 internal constant SHOULD_NOT_HAPPEN = 999;\n}"
    },
    "contracts/libraries/balancer/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport \"./BalancerErrors.sol\";\n\nimport \"./LogExpMath.sol\";\n\n/* solhint-disable private-vars-leading-underscore */\n\n/// forked from https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/solidity-utils/contracts/math/FixedPoint.sol\n/// Updated to solidity version 0.8.X\nlibrary FixedPoint {\n    uint256 internal constant ONE = 1e18; // 18 decimal places\n    uint256 internal constant TWO = 2 * ONE;\n    uint256 internal constant FOUR = 4 * ONE;\n    uint256 internal constant MAX_POW_RELATIVE_ERROR = 10000; // 10^(-14)\n\n    // Minimum base for the power function when the exponent is 'free' (larger than ONE).\n    uint256 internal constant MIN_POW_BASE_FREE_EXPONENT = 0.7e18;\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        uint256 c = a + b;\n        _require(c >= a, Errors.ADD_OVERFLOW);\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Fixed Point addition is the same as regular checked addition\n\n        _require(b <= a, Errors.SUB_OVERFLOW);\n        uint256 c = a - b;\n        return c;\n    }\n\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        return product / ONE;\n    }\n\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 product = a * b;\n        _require(a == 0 || product / a == b, Errors.MUL_OVERFLOW);\n\n        if (product == 0) {\n            return 0;\n        } else {\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((product - 1) / ONE) + 1;\n        }\n    }\n\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            return aInflated / b;\n        }\n    }\n\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        _require(b != 0, Errors.ZERO_DIVISION);\n\n        if (a == 0) {\n            return 0;\n        } else {\n            uint256 aInflated = a * ONE;\n            _require(aInflated / a == ONE, Errors.DIV_INTERNAL); // mul overflow\n\n            // The traditional divUp formula is:\n            // divUp(x, y) := (x + y - 1) / y\n            // To avoid intermediate overflow in the addition, we distribute the division and get:\n            // divUp(x, y) := (x - 1) / y + 1\n            // Note that this requires x != 0, which we already tested for.\n\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding down. The result is guaranteed to not be above\n     * the true value (that is, the error function expected - actual is always positive).\n     */\n    function powDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        // Optimize for when y equals 1.0, 2.0 or 4.0, as those are very simple to implement and occur often in 50/50\n        // and 80/20 Weighted Pools\n        if (y == ONE) {\n            return x;\n        } else if (y == TWO) {\n            return mulDown(x, x);\n        } else if (y == FOUR) {\n            uint256 square = mulDown(x, x);\n            return mulDown(square, square);\n        } else {\n            uint256 raw = LogExpMath.pow(x, y);\n            uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n            if (raw < maxError) {\n                return 0;\n            } else {\n                return sub(raw, maxError);\n            }\n        }\n    }\n\n    /**\n     * @dev Returns x^y, assuming both are fixed point numbers, rounding up. The result is guaranteed to not be below\n     * the true value (that is, the error function expected - actual is always negative).\n     */\n    function powUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        // Optimize for when y equals 1.0, 2.0 or 4.0, as those are very simple to implement and occur often in 50/50\n        // and 80/20 Weighted Pools\n        if (y == ONE) {\n            return x;\n        } else if (y == TWO) {\n            return mulUp(x, x);\n        } else if (y == FOUR) {\n            uint256 square = mulUp(x, x);\n            return mulUp(square, square);\n        } else {\n            uint256 raw = LogExpMath.pow(x, y);\n            uint256 maxError = add(mulUp(raw, MAX_POW_RELATIVE_ERROR), 1);\n\n            return add(raw, maxError);\n        }\n    }\n\n    /**\n     * @dev Returns the complement of a value (1 - x), capped to 0 if x is larger than 1.\n     *\n     * Useful when computing the complement for values with some level of relative error, as it strips this error and\n     * prevents intermediate negative values.\n     */\n    function complement(uint256 x) internal pure returns (uint256) {\n        return (x < ONE) ? (ONE - x) : 0;\n    }\n}"
    },
    "contracts/libraries/balancer/LogExpMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\n// documentation files (the Software), to deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\n// Software.\n\n// THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npragma solidity ^0.8.0;\n\nimport \"./BalancerErrors.sol\";\n\n/* solhint-disable */\n\n/// Forked from https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/solidity-utils/contracts/math/LogExpMath.sol\n/// updated to solidity version 0.8.x\n/**\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\n *\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\n * exponentiation and logarithm (where the base is Euler's number).\n *\n * @author Fernando Martinelli - @fernandomartinelli\n * @author Sergio Yuhjtman - @sergioyuhjtman\n * @author Daniel Fernandez - @dmf7z\n */\nlibrary LogExpMath {\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\n    // two numbers, and multiply by ONE when dividing them.\n\n    // All arguments and return values are 18 decimal fixed point numbers.\n    int256 constant ONE_18 = 1e18;\n\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\n    // case of ln36, 36 decimals.\n    int256 constant ONE_20 = 1e20;\n    int256 constant ONE_36 = 1e36;\n\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\n    //\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\n    // The smallest possible result is 10^(-18), which makes largest negative argument\n    // ln(10^(-18)) = -41.446531673892822312.\n    // We use 130.0 and -41.0 to have some safety margin.\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\n\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\n    // 256 bit integer.\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\n\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\n\n    // 18 decimal constants\n    int256 constant x0 = 128000000000000000000; // 27\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e(x0) (no decimals)\n    int256 constant x1 = 64000000000000000000; // 26\n    int256 constant a1 = 6235149080811616882910000000; // e(x1) (no decimals)\n\n    // 20 decimal constants\n    int256 constant x2 = 3200000000000000000000; // 25\n    int256 constant a2 = 7896296018268069516100000000000000; // e(x2)\n    int256 constant x3 = 1600000000000000000000; // 24\n    int256 constant a3 = 888611052050787263676000000; // e(x3)\n    int256 constant x4 = 800000000000000000000; // 23\n    int256 constant a4 = 298095798704172827474000; // e(x4)\n    int256 constant x5 = 400000000000000000000; // 22\n    int256 constant a5 = 5459815003314423907810; // e(x5)\n    int256 constant x6 = 200000000000000000000; // 21\n    int256 constant a6 = 738905609893065022723; // e(x6)\n    int256 constant x7 = 100000000000000000000; // 20\n    int256 constant a7 = 271828182845904523536; // e(x7)\n    int256 constant x8 = 50000000000000000000; // 2-1\n    int256 constant a8 = 164872127070012814685; // e(x8)\n    int256 constant x9 = 25000000000000000000; // 2-2\n    int256 constant a9 = 128402541668774148407; // e(x9)\n    int256 constant x10 = 12500000000000000000; // 2-3\n    int256 constant a10 = 113314845306682631683; // e(x10)\n    int256 constant x11 = 6250000000000000000; // 2-4\n    int256 constant a11 = 106449445891785942956; // e(x11)\n\n    /**\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\n     *\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\n        if (y == 0) {\n            // We solve the 0^0 indetermination by making it equal one.\n            return uint256(ONE_18);\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\n        // x^y = exp(y * ln(x)).\n\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\n        _require(x >> 255 == 0, Errors.X_OUT_OF_BOUNDS);\n        int256 x_int256 = int256(x);\n\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\n\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\n        _require(y < MILD_EXPONENT_BOUND, Errors.Y_OUT_OF_BOUNDS);\n        int256 y_int256 = int256(y);\n\n        int256 logx_times_y;\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\n            int256 ln_36_x = _ln_36(x_int256);\n\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\n            // (downscaled) last 18 decimals.\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\n        } else {\n            logx_times_y = _ln(x_int256) * y_int256;\n        }\n        logx_times_y /= ONE_18;\n\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\n        _require(\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\n            Errors.PRODUCT_OUT_OF_BOUNDS\n        );\n\n        return uint256(exp(logx_times_y));\n    }\n\n    /**\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\n     *\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\n     */\n    function exp(int256 x) internal pure returns (int256) {\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Errors.INVALID_EXPONENT);\n\n        if (x < 0) {\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\n            // Fixed point division requires multiplying by ONE_18.\n            return ((ONE_18 * ONE_18) / exp(-x));\n        }\n\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\n        // decomposition.\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest x_n.\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\n\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\n        // decomposition.\n\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\n        // it and compute the accumulated product.\n\n        int256 firstAN;\n        if (x >= x0) {\n            x -= x0;\n            firstAN = a0;\n        } else if (x >= x1) {\n            x -= x1;\n            firstAN = a1;\n        } else {\n            firstAN = 1; // One with no decimal places\n        }\n\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\n        // smaller terms.\n        x *= 100;\n\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\n        int256 product = ONE_20;\n\n        if (x >= x2) {\n            x -= x2;\n            product = (product * a2) / ONE_20;\n        }\n        if (x >= x3) {\n            x -= x3;\n            product = (product * a3) / ONE_20;\n        }\n        if (x >= x4) {\n            x -= x4;\n            product = (product * a4) / ONE_20;\n        }\n        if (x >= x5) {\n            x -= x5;\n            product = (product * a5) / ONE_20;\n        }\n        if (x >= x6) {\n            x -= x6;\n            product = (product * a6) / ONE_20;\n        }\n        if (x >= x7) {\n            x -= x7;\n            product = (product * a7) / ONE_20;\n        }\n        if (x >= x8) {\n            x -= x8;\n            product = (product * a8) / ONE_20;\n        }\n        if (x >= x9) {\n            x -= x9;\n            product = (product * a9) / ONE_20;\n        }\n\n        // x10 and x11 are unnecessary here since we have high enough precision already.\n\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\n\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\n\n        // The first term is simply x.\n        term = x;\n        seriesSum += term;\n\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\n\n        term = ((term * x) / ONE_20) / 2;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 3;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 4;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 5;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 6;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 7;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 8;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 9;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 10;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 11;\n        seriesSum += term;\n\n        term = ((term * x) / ONE_20) / 12;\n        seriesSum += term;\n\n        // 12 Taylor terms are sufficient for 18 decimal precision.\n\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\n        // and then drop two digits to return an 18 decimal value.\n\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\n    }\n\n    /**\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\n     */\n    function log(int256 arg, int256 base) internal pure returns (int256) {\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\n\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\n        // upscaling.\n\n        int256 logBase;\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\n            logBase = _ln_36(base);\n        } else {\n            logBase = _ln(base) * ONE_18;\n        }\n\n        int256 logArg;\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\n            logArg = _ln_36(arg);\n        } else {\n            logArg = _ln(arg) * ONE_18;\n        }\n\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\n        return (logArg * ONE_18) / logBase;\n    }\n\n    /**\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function ln(int256 a) internal pure returns (int256) {\n        // The real natural logarithm is not defined for negative numbers or zero.\n        _require(a > 0, Errors.OUT_OF_BOUNDS);\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\n            return _ln_36(a) / ONE_18;\n        } else {\n            return _ln(a);\n        }\n    }\n\n    /**\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\n     */\n    function _ln(int256 a) private pure returns (int256) {\n        if (a < ONE_18) {\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\n            // Fixed point division requires multiplying by ONE_18.\n            return (-_ln((ONE_18 * ONE_18) / a));\n        }\n\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\n        // decomposition, which will be lower than the smallest a_n.\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\n\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\n        // ONE_18 to convert them to fixed point.\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\n        // by it and compute the accumulated sum.\n\n        int256 sum = 0;\n        if (a >= a0 * ONE_18) {\n            a /= a0; // Integer, not fixed point division\n            sum += x0;\n        }\n\n        if (a >= a1 * ONE_18) {\n            a /= a1; // Integer, not fixed point division\n            sum += x1;\n        }\n\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\n        sum *= 100;\n        a *= 100;\n\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\n\n        if (a >= a2) {\n            a = (a * ONE_20) / a2;\n            sum += x2;\n        }\n\n        if (a >= a3) {\n            a = (a * ONE_20) / a3;\n            sum += x3;\n        }\n\n        if (a >= a4) {\n            a = (a * ONE_20) / a4;\n            sum += x4;\n        }\n\n        if (a >= a5) {\n            a = (a * ONE_20) / a5;\n            sum += x5;\n        }\n\n        if (a >= a6) {\n            a = (a * ONE_20) / a6;\n            sum += x6;\n        }\n\n        if (a >= a7) {\n            a = (a * ONE_20) / a7;\n            sum += x7;\n        }\n\n        if (a >= a8) {\n            a = (a * ONE_20) / a8;\n            sum += x8;\n        }\n\n        if (a >= a9) {\n            a = (a * ONE_20) / a9;\n            sum += x9;\n        }\n\n        if (a >= a10) {\n            a = (a * ONE_20) / a10;\n            sum += x10;\n        }\n\n        if (a >= a11) {\n            a = (a * ONE_20) / a11;\n            sum += x11;\n        }\n\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\n        // Let z = (a - 1) / (a + 1).\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\n        // division by ONE_20.\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\n        int256 z_squared = (z * z) / ONE_20;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_20;\n        seriesSum += num / 11;\n\n        // 6 Taylor terms are sufficient for 36 decimal precision.\n\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\n        seriesSum *= 2;\n\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\n        // value.\n\n        return (sum + seriesSum) / 100;\n    }\n\n    /**\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\n     * for x close to one.\n     *\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\n     */\n    function _ln_36(int256 x) private pure returns (int256) {\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\n        // worthwhile.\n\n        // First, we transform x to a 36 digit fixed point value.\n        x *= ONE_18;\n\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\n\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\n        // division by ONE_36.\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\n        int256 z_squared = (z * z) / ONE_36;\n\n        // num is the numerator of the series: the z^(2 * n + 1) term\n        int256 num = z;\n\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\n        int256 seriesSum = num;\n\n        // In each step, the numerator is multiplied by z^2\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 3;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 5;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 7;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 9;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 11;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 13;\n\n        num = (num * z_squared) / ONE_36;\n        seriesSum += num / 15;\n\n        // 8 Taylor terms are sufficient for 36 decimal precision.\n\n        // All that remains is multiplying by 2 (non fixed point).\n        return seriesSum * 2;\n    }\n}"
    },
    "contracts/libraries/BBMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\n// @title BBMath library\n// @notice A library facilitating all math operations required by the Blueberry Protocol.\nlibrary BBMath {\n    \n    /// @notice Rounds up the result of division between two numbers.\n    /// @param a Numerator.\n    /// @param b Denominator.\n    /// @return The result of the division, rounded up.\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b - 1) / b;\n    }\n\n    /// @notice Calculates the square root of a number using the Babylonian method.\n    /// @dev This function uses bit manipulation to efficiently estimate square roots.\n    ///      The function iteratively refines the approximation, and after seven iterations,\n    ///      the result is very close to the actual square root.\n    /// @param x The number to compute the square root of.\n    /// @return The estimated square root of x.\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        uint256 xx = x;\n        uint256 r = 1;\n\n        /// Bitwise operations to determine the magnitude of the input\n        /// and position our initial approximation (r) near the actual square root.\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n\n        /// Refinement using Babylonian method\n        /// This iterative approach refines our approximation with every iteration.\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; /// Seven iterations should be enough\n\n        /// Determine the closest approximation by comparing r and r1.\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "contracts/libraries/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"
    },
    "contracts/libraries/Paraswap/PSwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../../interfaces/paraswap/IParaswap.sol\";\nimport \"./Utils.sol\";\n\nlibrary PSwapLib {\n    function _approve(\n        IERC20 inToken,\n        address spender,\n        uint256 amount\n    ) internal {\n        // approve zero before reset allocation\n        inToken.approve(spender, 0);\n        inToken.approve(spender, amount);\n    }\n\n    function swap(\n        address augustusSwapper,\n        address tokenTransferProxy,\n        address fromToken,\n        uint fromAmount,\n        bytes calldata data\n    ) internal returns (bool success) {\n        _approve(IERC20(fromToken), tokenTransferProxy, fromAmount);\n\n        bytes memory returndata;\n\n        (success, returndata) = augustusSwapper.call(data);\n\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        }\n    }\n\n    function megaSwap(\n        address augustusSwapper,\n        address tokenTransferProxy,\n        Utils.MegaSwapSellData calldata data\n    ) internal returns (uint256) {\n        _approve(IERC20(data.fromToken), tokenTransferProxy, data.fromAmount);\n\n        return IParaswap(augustusSwapper).megaSwap(data);\n    }\n}\n"
    },
    "contracts/libraries/Paraswap/Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nlibrary Utils {\n    /**\n   * @param fromToken Address of the source token\n   * @param fromAmount Amount of source tokens to be swapped\n   * @param toAmount Minimum destination token amount expected out of this swap\n   * @param expectedAmount Expected amount of destination tokens without slippage\n   * @param beneficiary Beneficiary address\n   * 0 then 100% will be transferred to beneficiary. Pass 10000 for 100%\n   * @param path Route to be taken for this swap to take place\n\n   */\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.Path[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct MegaSwapSellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Utils.MegaSwapPath[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct SimpleData {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address[] callees;\n        bytes exchangeData;\n        uint256[] startIndexes;\n        uint256[] values;\n        address payable beneficiary;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct Adapter {\n        address payable adapter;\n        uint256 percent;\n        uint256 networkFee;\n        Route[] route;\n    }\n\n    struct Route {\n        uint256 index; //Adapter at which index needs to be used\n        address targetExchange;\n        uint percent;\n        bytes payload;\n        uint256 networkFee; //Network fee is associated with 0xv3 trades\n    }\n\n    struct MegaSwapPath {\n        uint256 fromAmountPercent;\n        Path[] path;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee; //Network fee is associated with 0xv3 trades\n        Adapter[] adapters;\n    }\n}\n"
    },
    "contracts/libraries/UniV3/UniV3WrappedLibContainer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nlibrary UniV3WrappedLibContainer {\n    // TickMath\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO =\n        1461446703485210103287273052203988822378723970342;\n\n    // OracleLibrary\n    function consult(\n        address pool,\n        uint32 secondsAgo\n    )\n        external\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {}\n\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) external pure returns (uint256 quoteAmount) {}\n\n    function getSqrtRatioAtTick(\n        int24 tick\n    ) external pure returns (uint160 sqrtPriceX96) {}\n\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) external pure returns (uint256 amount0, uint256 amount1) {}\n\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) external pure returns (uint128 liquidity) {}\n}\n"
    },
    "contracts/mock/MockAttack.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\nimport \"../interfaces/IWERC20.sol\";\n\ncontract MockAttack {}\n"
    },
    "contracts/mock/MockAuraToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract MockAuraToken is ERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address public operator;\n    address public vecrvProxy;\n\n    uint256 public constant EMISSIONS_MAX_SUPPLY = 5e25; // 50m\n    uint256 public constant INIT_MINT_AMOUNT = 5e25; // 50m\n    uint256 public constant totalCliffs = 500;\n    uint256 public immutable reductionPerCliff;\n    uint256 private manuallyMinted;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor() ERC20(\"Aura Token\", \"AURA\") {\n        operator = msg.sender;\n        reductionPerCliff = EMISSIONS_MAX_SUPPLY / totalCliffs;\n\n        _mint(msg.sender, INIT_MINT_AMOUNT);\n    }\n\n    function mintTestTokens(address to, uint amount) external {\n        _mint(to, amount);\n    }\n\n    function mintTestTokensManually(address to, uint amount) external {\n        manuallyMinted += amount;\n        _mint(to, amount);\n    }\n\n    function totalSupply() public view override returns (uint) {\n        return super.totalSupply() - manuallyMinted;\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        require(totalSupply() != 0, \"Not initialised\");\n\n        if (msg.sender != operator) {\n            // dont error just return. if a shutdown happens, rewards on old system\n            // can still be claimed, just wont mint cvx\n            return;\n        }\n\n        // e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 emissionsMinted = totalSupply() - INIT_MINT_AMOUNT;\n        // e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        // e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted / reductionPerCliff;\n\n        // e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            // e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            // e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            // e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = totalCliffs.sub(cliff).mul(5).div(2).add(700);\n            // e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            // e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            // e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            uint256 amount = _amount.mul(reduction).div(totalCliffs);\n            // e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = EMISSIONS_MAX_SUPPLY.sub(emissionsMinted);\n            if (amount > amtTillMax) {\n                amount = amtTillMax;\n            }\n            _mint(_to, amount);\n        }\n    }\n}\n"
    },
    "contracts/mock/MockBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"../BlueBerryBank.sol\";\n\ncontract MockBank is BlueBerryBank {\n    function createFakePosition(Position memory fakePosition) external {\n        uint256 positionId = nextPositionId++;\n        positions[positionId] = fakePosition;\n    }\n}\n"
    },
    "contracts/mock/MockBaseRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\nimport \"./MockVirtualBalanceRewardPool.sol\";\n\ncontract MockBaseRewardPool {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    IERC20 public rewardToken;\n    IERC20 public stakingToken;\n    uint256 public constant duration = 7 days;\n\n    uint256 public rewardPerToken;\n    uint256 public pid;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    uint256 private _totalSupply;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) private _balances;\n\n    address[] public extraRewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(uint256 pid_, address stakingToken_, address rewardToken_) {\n        pid = pid_;\n        stakingToken = IERC20(stakingToken_);\n        rewardToken = IERC20(rewardToken_);\n    }\n\n    function setReward(address user, uint amount) external {\n        rewards[user] = amount;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    function addExtraReward(address _reward) external returns (bool) {\n        require(_reward != address(0), \"!reward setting\");\n\n        extraRewards.push(_reward);\n        return true;\n    }\n\n    function clearExtraRewards() external {\n        delete extraRewards;\n    }\n\n    modifier updateReward(address account) {\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function setRewardPerToken(uint _rewardPerToken) external {\n        rewardPerToken = _rewardPerToken;\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return rewards[account];\n    }\n\n    function stake(\n        uint256 _amount\n    ) public updateReward(msg.sender) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[msg.sender] = _balances[msg.sender].add(_amount);\n\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(msg.sender, _amount);\n\n        return true;\n    }\n\n    function stakeFor(\n        address _for,\n        uint256 _amount\n    ) public updateReward(_for) returns (bool) {\n        require(_amount > 0, \"RewardPool : Cannot stake 0\");\n\n        //also stake to linked rewards\n        for (uint i = 0; i < extraRewards.length; i++) {\n            MockVirtualBalanceRewardPool(extraRewards[i]).stake(_for, _amount);\n        }\n\n        //give to _for\n        _totalSupply = _totalSupply.add(_amount);\n        _balances[_for] = _balances[_for].add(_amount);\n\n        //take away from sender\n        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n        emit Staked(_for, _amount);\n\n        return true;\n    }\n\n    function stakeAll() external returns (bool) {\n        uint256 balance = stakingToken.balanceOf(msg.sender);\n        stake(balance);\n        return true;\n    }\n\n    function withdraw(\n        uint256 amount,\n        bool claim\n    ) public updateReward(msg.sender) returns (bool) {\n        require(amount > 0, \"RewardPool : Cannot withdraw 0\");\n\n        //also withdraw from linked rewards\n        for (uint i = 0; i < extraRewards.length; i++) {\n            MockVirtualBalanceRewardPool(extraRewards[i]).withdraw(\n                msg.sender,\n                amount\n            );\n        }\n\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n\n        stakingToken.safeTransfer(msg.sender, amount);\n        emit Withdrawn(msg.sender, amount);\n\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n\n        return true;\n    }\n\n    function withdrawAll(bool claim) external {\n        withdraw(_balances[msg.sender], claim);\n    }\n\n    function withdrawAndUnwrap(\n        uint256 amount,\n        bool claim\n    ) public updateReward(msg.sender) returns (bool) {\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        emit Withdrawn(msg.sender, amount);\n\n        //get rewards too\n        if (claim) {\n            getReward(msg.sender, true);\n        }\n        return true;\n    }\n\n    function withdrawAllAndUnwrap(bool claim) external {\n        withdrawAndUnwrap(_balances[msg.sender], claim);\n    }\n\n    function getReward(\n        address _account,\n        bool _claimExtras\n    ) public updateReward(_account) returns (bool) {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            emit RewardPaid(_account, reward);\n        }\n\n        //also get rewards from linked rewards\n        if (_claimExtras) {\n            for (uint i = 0; i < extraRewards.length; i++) {\n                MockVirtualBalanceRewardPool(extraRewards[i]).getReward(\n                    _account\n                );\n            }\n        }\n\n        return true;\n    }\n\n    function getReward() external returns (bool) {\n        getReward(msg.sender, true);\n        return true;\n    }\n\n    function donate(uint256 _amount) external returns (bool) {\n        IERC20(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        queuedRewards = queuedRewards.add(_amount);\n    }\n\n    function queueNewRewards(uint256 _rewards) external returns (bool) {\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return true;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n\n        //uint256 queuedRatio = currentRewards.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n        return true;\n    }\n\n    function notifyRewardAmount(\n        uint256 reward\n    ) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "contracts/mock/MockBooster.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockBooster {\n    using SafeERC20 for IERC20;\n\n    struct PoolInfo {\n        address lptoken;\n        address token;\n        address gauge;\n        address crvRewards;\n        address stash;\n        bool shutdown;\n    }\n\n    uint public constant REWARD_MULTIPLIER_DENOMINATOR = 10000;\n\n    //index(pid) -> pool\n    PoolInfo[] public poolInfo;\n\n    mapping(address => uint256) public getRewardMultipliers;\n\n    bool public isShutdown;\n\n    function setShutdown(bool _isShutdown) external {\n        isShutdown = _isShutdown;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    //create a new pool\n    function addPool(\n        address _lptoken,\n        address _token,\n        address _gauge,\n        address _crvRewards,\n        address _stash\n    ) external returns (bool) {\n        //add the new pool\n        poolInfo.push(\n            PoolInfo({\n                lptoken: _lptoken,\n                token: _token,\n                gauge: _gauge,\n                crvRewards: _crvRewards,\n                stash: _stash,\n                shutdown: false\n            })\n        );\n        return true;\n    }\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool) {\n        require(!isShutdown, \"shutdown\");\n        PoolInfo storage pool = poolInfo[_pid];\n        require(pool.shutdown == false, \"pool is closed\");\n\n        //send to proxy to stake\n        address lptoken = pool.lptoken;\n        IERC20(lptoken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        address token = pool.token;\n        if (_stake) {\n            //mint here and send to rewards on user behalf\n            MockERC20(token).mintWithAmount(_amount);\n            address rewardContract = pool.crvRewards;\n            IERC20(token).safeApprove(rewardContract, 0);\n            IERC20(token).safeApprove(rewardContract, _amount);\n            IRewarder(rewardContract).stakeFor(msg.sender, _amount);\n        } else {\n            //add user balance directly\n            MockERC20(token).mintWithAmount(_amount);\n        }\n\n        return true;\n    }\n\n    function withdraw(uint256 _pid, uint256 _amount) public returns (bool) {\n        _withdraw(_pid, _amount, msg.sender, msg.sender);\n        return true;\n    }\n\n    //withdraw lp tokens\n    function _withdraw(\n        uint256 _pid,\n        uint256 _amount,\n        address _from,\n        address _to\n    ) internal {\n        PoolInfo storage pool = poolInfo[_pid];\n        address lptoken = pool.lptoken;\n\n        //remove lp balance\n        address token = pool.token;\n        MockERC20(token).burn(_from, _amount);\n\n        //return lp tokens\n        IERC20(lptoken).safeTransfer(_to, _amount);\n    }\n\n    function setRewardMultipliers(address rewarder, uint multiplier) external {\n        getRewardMultipliers[rewarder] = multiplier;\n    }\n}\n"
    },
    "contracts/mock/MockConvexToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockConvexToken is ERC20 {\n    using SafeERC20 for IERC20;\n    using Address for address;\n\n    address public operator;\n    address public vecrvProxy;\n\n    uint256 public maxSupply = 100 * 1000000 * 1e18; //100mil\n    uint256 public totalCliffs = 1000;\n    uint256 public reductionPerCliff;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor() ERC20(\"Convex Token\", \"CVX\") {\n        operator = msg.sender;\n        reductionPerCliff = maxSupply / totalCliffs;\n    }\n\n    function mintTestTokens(address to, uint amount) external {\n        _mint(to, amount);\n    }\n\n    function mint(address _to, uint256 _amount) external {\n        if (msg.sender != operator) {\n            //dont error just return. if a shutdown happens, rewards on old system\n            //can still be claimed, just wont mint cvx\n            return;\n        }\n\n        uint256 supply = totalSupply();\n        if (supply == 0) {\n            //premine, one time only\n            _mint(_to, _amount);\n            return;\n        }\n\n        //use current supply to gauge cliff\n        //this will cause a bit of overflow into the next cliff range\n        //but should be within reasonable levels.\n        //requires a max supply check though\n        uint256 cliff = supply / reductionPerCliff;\n        //mint if below total cliffs\n        if (cliff < totalCliffs) {\n            //for reduction% take inverse of current cliff\n            uint256 reduction = totalCliffs - cliff;\n            //reduce\n            _amount = (_amount * reduction) / totalCliffs;\n\n            //supply cap check\n            uint256 amtTillMax = maxSupply - supply;\n            if (_amount > amtTillMax) {\n                _amount = amtTillMax;\n            }\n\n            //mint\n            _mint(_to, _amount);\n        }\n    }\n}\n"
    },
    "contracts/mock/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockERC20 is ERC20 {\n    uint8 _decimals;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimal\n    ) ERC20(name, symbol) {\n        _decimals = decimal;\n    }\n\n    function setDecimals(uint8 decimal) external {\n        _decimals = decimal;\n    }\n\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    function mint() external {\n        _mint(msg.sender, 100 * 10 ** _decimals);\n    }\n\n    function mintWithAmount(uint amount) external {\n        _mint(msg.sender, amount);\n    }\n\n    function mintTo(address to, uint amount) external {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint amount) external {\n        _burn(from, amount);\n    }\n}\n"
    },
    "contracts/mock/MockFeedRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport '@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract MockFeedRegistry is Ownable {\n    mapping(address => mapping(address => address)) feeds;\n\n    /**\n     * @notice represents the number of decimals the aggregator responses represent.\n     */\n    function decimals(address base, address quote)\n        external\n        view\n        returns (uint8)\n    {\n        AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n        require(address(aggregator) != address(0), 'Feed not found');\n        return aggregator.decimals();\n    }\n\n    function latestRoundData(address base, address quote)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        AggregatorV2V3Interface aggregator = _getFeed(base, quote);\n        require(address(aggregator) != address(0), 'Feed not found');\n        (roundId, answer, startedAt, updatedAt, answeredInRound) = aggregator\n            .latestRoundData();\n    }\n\n    function getFeed(address base, address quote)\n        external\n        view\n        returns (AggregatorV2V3Interface aggregator)\n    {\n        aggregator = _getFeed(base, quote);\n        require(address(aggregator) != address(0), 'Feed not found');\n    }\n\n    function setFeed(\n        address base,\n        address quote,\n        address aggregator\n    ) external onlyOwner {\n        feeds[base][quote] = aggregator;\n    }\n\n    function _getFeed(address base, address quote)\n        internal\n        view\n        returns (AggregatorV2V3Interface aggregator)\n    {\n        aggregator = AggregatorV2V3Interface(feeds[base][quote]);\n    }\n}\n"
    },
    "contracts/mock/MockIchiFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockIchiFarm is Ownable {\n    using SafeERC20 for IERC20;\n    /// @notice Info of each IFV2 user.\n    /// `amount` LP token amount the user has provided.\n    /// `rewardDebt` The amount of ICHI entitled to the user.\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    /// @notice Info of each IFV2 pool.\n    /// `allocPoint` The amount of allocation points assigned to the pool.\n    /// Also known as the amount of ICHI to distribute per block.\n    struct PoolInfo {\n        uint128 accIchiPerShare;\n        uint64 lastRewardBlock;\n        uint64 allocPoint;\n    }\n\n    /// @dev Address of ICHI contract.\n    IERC20 private immutable ICHI;\n\n    /// @notice Info of each IFV2 pool.\n    PoolInfo[] public poolInfo;\n    /// @notice Address of the LP token for each IFV2 pool.\n    IERC20[] public lpToken;\n    /// @dev List of all added LP tokens.\n    mapping(address => bool) private addedLPs;\n\n    /// @notice Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    /// @notice Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint;\n\n    /// @notice ICHI tokens created per block.\n    uint256 public ichiPerBlock;\n\n    /// @dev Extra decimals for pool's accIchiPerShare attribute. Needed in order to accomodate different types of LPs.\n    uint256 private constant ACC_ICHI_PRECISION = 1e18;\n\n    /// @dev nonReentrant flag used to secure functions with external calls.\n    bool private nonReentrant;\n\n    event Deposit(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        address indexed to\n    );\n    event Withdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        address indexed to\n    );\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount,\n        address indexed to\n    );\n    event Harvest(address indexed user, uint256 indexed pid, uint256 amount);\n    event LogPoolAddition(\n        uint256 indexed pid,\n        uint256 allocPoint,\n        IERC20 indexed lpToken\n    );\n    event LogSetPool(uint256 indexed pid, uint256 allocPoint);\n    event LogUpdatePool(\n        uint256 indexed pid,\n        uint64 lastRewardBlock,\n        uint256 lpSupply,\n        uint256 accIchiPerShare\n    );\n    event SetIchiPerBlock(uint256 ichiPerBlock, bool withUpdate);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @param _ichi The ICHI token contract address.\n    /// @param _ichiPerBlock ICHI tokens created per block.\n    constructor(IERC20 _ichi, uint256 _ichiPerBlock) {\n        ICHI = _ichi;\n        ichiPerBlock = _ichiPerBlock;\n        totalAllocPoint = 0;\n    }\n\n    /// @notice Update number of ICHI tokens created per block. Can only be called by the owner.\n    /// @param _ichiPerBlock ICHI tokens created per block.\n    /// @param _withUpdate true if massUpdatePools should be triggered as well.\n    function setIchiPerBlock(uint256 _ichiPerBlock, bool _withUpdate)\n        external\n        onlyOwner\n    {\n        if (_withUpdate) {\n            massUpdateAllPools();\n        }\n        ichiPerBlock = _ichiPerBlock;\n        emit SetIchiPerBlock(_ichiPerBlock, _withUpdate);\n    }\n\n    /// @notice Set the nonReentrant flag. Could be used to pause/resume the farm operations. Can only be called by the owner.\n    /// @param _val nonReentrant flag value to be set.\n    function setNonReentrant(bool _val) external onlyOwner returns (bool) {\n        nonReentrant = _val;\n        return nonReentrant;\n    }\n\n    /// @notice Returns the number of IFV2 pools.\n    function poolLength() external view returns (uint256 pools) {\n        pools = poolInfo.length;\n    }\n\n    /// @notice Returns the ICHI reward value for a specific pool.\n    function poolIchiReward(uint256 _pid) external view returns (uint256) {\n        if (totalAllocPoint == 0) return 0;\n        return (ichiPerBlock * (poolInfo[_pid].allocPoint)) / totalAllocPoint;\n    }\n\n    /// @notice Returns the total number of LPs staked in the farm.\n    function getLPSupply(uint256 _pid) external view returns (uint256) {\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\n        return lpSupply;\n    }\n\n    /// @notice Add a new LP to the pool. Can only be called by the owner.\n    /// DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    /// @param allocPoint AP of the new pool.\n    /// @param _lpToken Address of the LP ERC-20 token.\n    function add(uint256 allocPoint, IERC20 _lpToken) external onlyOwner {\n        require(\n            !addedLPs[address(_lpToken)],\n            \"ichiFarmV2::there is already a pool with this LP\"\n        );\n        uint256 lastRewardBlock = block.number;\n        totalAllocPoint += allocPoint;\n        lpToken.push(_lpToken);\n        addedLPs[address(_lpToken)] = true;\n\n        poolInfo.push(\n            PoolInfo({\n                allocPoint: uint64(allocPoint),\n                lastRewardBlock: uint64(lastRewardBlock),\n                accIchiPerShare: 0\n            })\n        );\n        emit LogPoolAddition(lpToken.length - 1, allocPoint, _lpToken);\n    }\n\n    /// @notice Update the given pool's ICHI allocation point. Can only be called by the owner.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _allocPoint New AP of the pool.\n    function set(uint256 _pid, uint256 _allocPoint) external onlyOwner {\n        totalAllocPoint =\n            totalAllocPoint -\n            poolInfo[_pid].allocPoint +\n            _allocPoint;\n        poolInfo[_pid].allocPoint = uint64(_allocPoint);\n        emit LogSetPool(_pid, _allocPoint);\n    }\n\n    /// @notice View function to see pending ICHI on frontend.\n    /// @param _pid The index of the pool. See `poolInfo`.\n    /// @param _user Address of user.\n    /// @return pending ICHI reward for a given user.\n    function pendingIchi(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256 pending)\n    {\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accIchiPerShare = pool.accIchiPerShare;\n        uint256 lpSupply = lpToken[_pid].balanceOf(address(this));\n        if (\n            block.number > pool.lastRewardBlock &&\n            lpSupply > 0 &&\n            totalAllocPoint > 0\n        ) {\n            uint256 blocks = block.number - pool.lastRewardBlock;\n            accIchiPerShare +=\n                ((blocks *\n                    ichiPerBlock *\n                    pool.allocPoint *\n                    ACC_ICHI_PRECISION) / totalAllocPoint) /\n                lpSupply;\n        }\n        pending =\n            (user.amount * accIchiPerShare) /\n            ACC_ICHI_PRECISION -\n            uint256(user.rewardDebt);\n    }\n\n    /// @notice Update reward variables for all pools. Be careful of gas spending!\n    function massUpdateAllPools() public {\n        uint256 len = poolInfo.length;\n        for (uint256 pid = 0; pid < len; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    /// @notice Update reward variables for specified pools. Be careful of gas spending!\n    /// @param pids Pool IDs of all to be updated. Make sure to update all active pools.\n    function massUpdatePools(uint256[] calldata pids) external {\n        uint256 len = pids.length;\n        for (uint256 i = 0; i < len; ++i) {\n            updatePool(pids[i]);\n        }\n    }\n\n    /// @notice Update reward variables of the given pool.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @return pool Returns the pool that was updated.\n    function updatePool(uint256 pid) public returns (PoolInfo memory pool) {\n        pool = poolInfo[pid];\n        if (block.number > pool.lastRewardBlock) {\n            uint256 lpSupply = lpToken[pid].balanceOf(address(this));\n            if (lpSupply > 0 && totalAllocPoint > 0) {\n                uint256 blocks = block.number - pool.lastRewardBlock;\n                pool.accIchiPerShare += uint128(\n                    ((blocks *\n                        ichiPerBlock *\n                        pool.allocPoint *\n                        ACC_ICHI_PRECISION) / totalAllocPoint) / lpSupply\n                );\n            }\n            pool.lastRewardBlock = uint64(block.number);\n            poolInfo[pid] = pool;\n            emit LogUpdatePool(\n                pid,\n                pool.lastRewardBlock,\n                lpSupply,\n                pool.accIchiPerShare\n            );\n        }\n    }\n\n    /// @notice Deposit LP tokens to IFV2 for ICHI allocation.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to deposit.\n    /// @param to The receiver of `amount` deposit benefit.\n    function deposit(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) external {\n        require(!nonReentrant, \"ichiFarmV2::nonReentrant - try again\");\n        nonReentrant = true;\n\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][to];\n\n        // Effects\n        user.amount += amount;\n        user.rewardDebt += int256(\n            (amount * pool.accIchiPerShare) / ACC_ICHI_PRECISION\n        );\n\n        // Interactions\n        lpToken[pid].safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(msg.sender, pid, amount, to);\n        nonReentrant = false;\n    }\n\n    /// @notice Withdraw LP tokens from IFV2.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param amount LP token amount to withdraw.\n    /// @param to Receiver of the LP tokens.\n    function withdraw(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) external {\n        require(!nonReentrant, \"ichiFarmV2::nonReentrant - try again\");\n        nonReentrant = true;\n\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n\n        // Effects\n        user.rewardDebt -= int256(\n            (amount * pool.accIchiPerShare) / ACC_ICHI_PRECISION\n        );\n        user.amount -= amount;\n\n        // Interactions\n        lpToken[pid].safeTransfer(to, amount);\n\n        emit Withdraw(msg.sender, pid, amount, to);\n        nonReentrant = false;\n    }\n\n    /// @notice Harvest proceeds for transaction sender to `to`.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of ICHI rewards.\n    function harvest(uint256 pid, address to) external {\n        require(!nonReentrant, \"ichiFarmV2::nonReentrant - try again\");\n        nonReentrant = true;\n\n        PoolInfo memory pool = updatePool(pid);\n        UserInfo storage user = userInfo[pid][msg.sender];\n        int256 accumulatedIchi = int256(\n            (user.amount * pool.accIchiPerShare) / ACC_ICHI_PRECISION\n        );\n        uint256 _pendingIchi = uint256(accumulatedIchi - user.rewardDebt);\n\n        // Effects\n        user.rewardDebt = accumulatedIchi;\n\n        // Interactions\n        if (_pendingIchi > 0) {\n            ICHI.safeTransfer(to, _pendingIchi);\n        }\n\n        emit Harvest(msg.sender, pid, _pendingIchi);\n        nonReentrant = false;\n    }\n\n    /// @notice Withdraw without caring about rewards. EMERGENCY ONLY.\n    /// @param pid The index of the pool. See `poolInfo`.\n    /// @param to Receiver of the LP tokens.\n    function emergencyWithdraw(uint256 pid, address to) public {\n        require(address(0) != to, \"ichiFarmV2::can't withdraw to address zero\");\n        UserInfo storage user = userInfo[pid][msg.sender];\n        uint256 amount = user.amount;\n        user.amount = 0;\n        user.rewardDebt = 0;\n        // Note: transfer can fail or succeed if `amount` is zero.\n        lpToken[pid].safeTransfer(to, amount);\n        emit EmergencyWithdraw(msg.sender, pid, amount, to);\n    }\n}\n"
    },
    "contracts/mock/MockIchiV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./MockERC20.sol\";\n\ncontract MockIchiV2 is MockERC20 {\n    using SafeERC20 for IERC20;\n\n    // ICHI V1 address\n    address public ichiV1;\n\n    // constant that represents 100%\n    uint256 constant PERCENT = 100;\n\n    // constant that represents difference in decimals between ICHI V1 and ICHI V2 tokens\n    uint256 constant DECIMALS_DIFF = 1e9;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(address ichiV1_) MockERC20(\"ICHI\", \"ICHI\", 18) {\n        ichiV1 = ichiV1_;\n    }\n\n    /**\n     * @notice Convert ICHI V1 tokens to ICHI V2 tokens\n     * @param v1Amount The number of ICHI V1 tokens to be converted (using 9 decimals representation)\n     */\n    function convertToV2(uint256 v1Amount) external {\n        require(v1Amount > 0, \"IchiV2.convertToV2: amount must be > 0\");\n\n        // convert 9 decimals ICHI V1 to 18 decimals ICHI V2\n        uint256 v2Amount = v1Amount * DECIMALS_DIFF;\n\n        // transfer ICHI V1 tokens in\n        IERC20(ichiV1).safeTransferFrom(msg.sender, address(this), v1Amount);\n\n        _mint(msg.sender, v2Amount);\n    }\n}\n"
    },
    "contracts/mock/MockIchiVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.16;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH =\n        0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(\n        address factory,\n        PoolKey memory key\n    ) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(\n                                abi.encode(key.token0, key.token1, key.fee)\n                            ),\n                            POOL_INIT_CODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n}\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\nimport \"../interfaces/ichi/IICHIVaultFactory.sol\";\n\nimport \"../libraries/UniV3/UniV3WrappedLibContainer.sol\";\n\n/**\n @notice A Uniswap V2-like interface with fungible liquidity to Uniswap V3 \n which allows for either one-sided or two-sided liquidity provision.\n ICHIVaults should be deployed by the ICHIVaultFactory. \n ICHIVaults should not be used with tokens that charge transaction fees.  \n */\ncontract MockIchiVault is\n    IICHIVault,\n    IUniswapV3MintCallback,\n    IUniswapV3SwapCallback,\n    ERC20,\n    ReentrancyGuard,\n    Ownable\n{\n    using SafeERC20 for IERC20;\n\n    address public ichiVaultFactory;\n    address public immutable override pool;\n    address public immutable override token0;\n    address public immutable override token1;\n    bool public immutable override allowToken0;\n    bool public immutable override allowToken1;\n    uint24 public immutable override fee;\n    int24 public immutable override tickSpacing;\n\n    address public override affiliate;\n    int24 public override baseLower;\n    int24 public override baseUpper;\n    int24 public override limitLower;\n    int24 public override limitUpper;\n\n    // The following three variables serve the very ////important purpose of\n    // limiting inventory risk and the arbitrage opportunities made possible by\n    // instant deposit & withdrawal.\n    // If, in the ETHUSDT pool at an ETH price of 2500 USDT, I deposit 100k\n    // USDT in a pool with 40 WETH, and then directly afterwards withdraw 50k\n    // USDT and 20 WETH (this is of equivalent dollar value), I drastically\n    // change the pool composition and additionally decreases deployed capital\n    // by 50%. Keeping a maxTotalSupply just above our current total supply\n    // means that large amounts of funds can't be deposited all at once to\n    // create a large imbalance of funds or to sideline many funds.\n    // Additionally, deposit maximums prevent users from using the pool as\n    // a counterparty to trade assets against while avoiding uniswap fees\n    // & slippage--if someone were to try to do this with a large amount of\n    // capital they would be overwhelmed by the gas fees necessary to call\n    // deposit & withdrawal many times.\n\n    uint256 public override deposit0Max;\n    uint256 public override deposit1Max;\n    uint256 public override maxTotalSupply;\n    uint256 public override hysteresis;\n\n    uint256 public constant PRECISION = 10 ** 18;\n    uint256 constant PERCENT = 100;\n    address constant NULL_ADDRESS = address(0);\n\n    uint32 public twapPeriod;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /**\n     @notice creates an instance of ICHIVault based on the pool. \n            allowToken parameters control whether the ICHIVault allows one-sided or two-sided liquidity provision\n     @param _pool Uniswap V3 pool for which liquidity is managed\n     @param _allowToken0 flag that indicates whether token0 is accepted during deposit\n     @param _allowToken1 flag that indicates whether token1 is accepted during deposit\n     @param __owner Owner of the ICHIVault\n     */\n    constructor(\n        address _pool,\n        bool _allowToken0,\n        bool _allowToken1,\n        address __owner,\n        address _factory,\n        uint32 _twapPeriod\n    ) ERC20(\"ICHI Vault Liquidity\", \"ICHI_Vault_LP\") {\n        require(_pool != NULL_ADDRESS, \"IV.constructor: zero address\");\n        require(\n            _allowToken0 || _allowToken1,\n            \"IV.constructor: no allowed tokens\"\n        );\n\n        ichiVaultFactory = _factory;\n        pool = _pool;\n        token0 = IUniswapV3Pool(_pool).token0();\n        token1 = IUniswapV3Pool(_pool).token1();\n        fee = IUniswapV3Pool(_pool).fee();\n        allowToken0 = _allowToken0;\n        allowToken1 = _allowToken1;\n        twapPeriod = _twapPeriod;\n        tickSpacing = IUniswapV3Pool(_pool).tickSpacing();\n\n        transferOwnership(__owner);\n\n        maxTotalSupply = 0; // no cap\n        hysteresis = PRECISION / PERCENT; // 1% threshold\n        deposit0Max = type(uint256).max; // max uint256\n        deposit1Max = type(uint256).max; // max uint256\n        affiliate = NULL_ADDRESS; // by default there is no affiliate address\n        emit DeployICHIVault(\n            msg.sender,\n            _pool,\n            _allowToken0,\n            _allowToken1,\n            __owner,\n            _twapPeriod\n        );\n    }\n\n    function setTwapPeriod(uint32 newTwapPeriod) external onlyOwner {\n        require(newTwapPeriod > 0, \"IV.setTwapPeriod: missing period\");\n        twapPeriod = newTwapPeriod;\n        emit SetTwapPeriod(msg.sender, newTwapPeriod);\n    }\n\n    /**\n     @notice Distributes shares to depositor equal to the token1 value of his deposit multiplied \n            by the ratio of total liquidity shares issued divided by the pool's AUM measured in token1 value. \n     @param deposit0 Amount of token0 transfered from sender to ICHIVault\n     @param deposit1 Amount of token0 transfered from sender to ICHIVault\n     @param to Address to which liquidity tokens are minted\n     @param shares Quantity of liquidity tokens minted as a result of deposit\n     */\n    function deposit(\n        uint256 deposit0,\n        uint256 deposit1,\n        address to\n    ) external override nonReentrant returns (uint256 shares) {\n        require(allowToken0 || deposit0 == 0, \"IV.deposit: token0 not allowed\");\n        require(allowToken1 || deposit1 == 0, \"IV.deposit: token1 not allowed\");\n        require(\n            deposit0 > 0 || deposit1 > 0,\n            \"IV.deposit: deposits must be > 0\"\n        );\n        require(\n            deposit0 < deposit0Max && deposit1 < deposit1Max,\n            \"IV.deposit: deposits too large\"\n        );\n        require(to != NULL_ADDRESS && to != address(this), \"IV.deposit: to\");\n\n        // update fees for inclusion in total pool amounts\n        (uint128 baseLiquidity, , ) = _position(baseLower, baseUpper);\n        if (baseLiquidity > 0) {\n            (uint256 burn0, uint256 burn1) = IUniswapV3Pool(pool).burn(\n                baseLower,\n                baseUpper,\n                0\n            );\n            require(\n                burn0 == 0 && burn1 == 0,\n                \"IV.deposit: unexpected burn (1)\"\n            );\n        }\n\n        (uint128 limitLiquidity, , ) = _position(limitLower, limitUpper);\n        if (limitLiquidity > 0) {\n            (uint256 burn0, uint256 burn1) = IUniswapV3Pool(pool).burn(\n                limitLower,\n                limitUpper,\n                0\n            );\n            require(\n                burn0 == 0 && burn1 == 0,\n                \"IV.deposit: unexpected burn (2)\"\n            );\n        }\n\n        // Spot\n\n        uint256 price = _fetchSpot(token0, token1, currentTick(), PRECISION);\n\n        // TWAP\n\n        uint256 twap = _fetchTwap(pool, token0, token1, twapPeriod, PRECISION);\n\n        // if difference between spot and twap is too big, check if the price may have been manipulated in this block\n        uint256 delta = (price > twap)\n            ? ((price - twap) * PRECISION) / price\n            : ((twap - price) * PRECISION) / twap;\n        if (delta > hysteresis)\n            require(checkHysteresis(), \"IV.deposit: try later\");\n\n        (uint256 pool0, uint256 pool1) = getTotalAmounts();\n\n        // aggregated deposit\n        uint256 deposit0PricedInToken1 = (deposit0 *\n            ((price < twap) ? price : twap)) / PRECISION;\n\n        if (deposit0 > 0) {\n            IERC20(token0).safeTransferFrom(\n                msg.sender,\n                address(this),\n                deposit0\n            );\n        }\n        if (deposit1 > 0) {\n            IERC20(token1).safeTransferFrom(\n                msg.sender,\n                address(this),\n                deposit1\n            );\n        }\n\n        shares = deposit1 + deposit0PricedInToken1;\n\n        if (totalSupply() != 0) {\n            uint256 pool0PricedInToken1 = (pool0 *\n                ((price > twap) ? price : twap)) / PRECISION;\n            shares = (shares * totalSupply()) / (pool0PricedInToken1 + pool1);\n        }\n        _mint(to, shares);\n        emit Deposit(msg.sender, to, shares, deposit0, deposit1);\n        // Check total supply cap not exceeded. A value of 0 means no limit.\n        require(\n            maxTotalSupply == 0 || totalSupply() <= maxTotalSupply,\n            \"IV.deposit: maxTotalSupply\"\n        );\n    }\n\n    /**\n     @notice Redeems shares by sending out a percentage of the ICHIVault's AUM - \n            this percentage is equal to the percentage of total issued shares represented by the redeeemed shares.\n     @param shares Number of liquidity tokens to redeem as pool assets\n     @param to Address to which redeemed pool assets are sent\n     @param amount0 Amount of token0 redeemed by the submitted liquidity tokens\n     @param amount1 Amount of token1 redeemed by the submitted liquidity tokens\n     */\n    function withdraw(\n        uint256 shares,\n        address to\n    )\n        external\n        override\n        nonReentrant\n        returns (uint256 amount0, uint256 amount1)\n    {\n        require(shares > 0, \"IV.withdraw: shares\");\n        require(to != NULL_ADDRESS, \"IV.withdraw: to\");\n\n        // Withdraw liquidity from Uniswap pool\n        (uint256 base0, uint256 base1) = _burnLiquidity(\n            baseLower,\n            baseUpper,\n            _liquidityForShares(baseLower, baseUpper, shares),\n            to,\n            false\n        );\n        (uint256 limit0, uint256 limit1) = _burnLiquidity(\n            limitLower,\n            limitUpper,\n            _liquidityForShares(limitLower, limitUpper, shares),\n            to,\n            false\n        );\n\n        // Push tokens proportional to unused balances\n        uint256 _totalSupply = totalSupply();\n        uint256 unusedAmount0 = (IERC20(token0).balanceOf(address(this)) *\n            shares) / _totalSupply;\n        uint256 unusedAmount1 = (IERC20(token1).balanceOf(address(this)) *\n            shares) / _totalSupply;\n        if (unusedAmount0 > 0) IERC20(token0).safeTransfer(to, unusedAmount0);\n        if (unusedAmount1 > 0) IERC20(token1).safeTransfer(to, unusedAmount1);\n\n        amount0 = base0 + limit0 + unusedAmount0;\n        amount1 = base1 + limit1 + unusedAmount1;\n\n        _burn(msg.sender, shares);\n\n        emit Withdraw(msg.sender, to, shares, amount0, amount1);\n    }\n\n    /**\n     @notice Updates ICHIVault's LP positions.\n     @dev The base position is placed first with as much liquidity as possible and\n        is typically symmetric around the current price.\n        This order should use up all of one token, leaving some unused quantity of the other.\n        This unused amount is then placed as a single-sided order.\n     @param _baseLower The lower tick of the base position\n     @param _baseUpper The upper tick of the base position\n     @param _limitLower The lower tick of the limit position\n     @param _limitUpper The upper tick of the limit position\n     @param swapQuantity Quantity of tokens to swap;\n        if quantity is positive, `swapQuantity` token0 are swaped for token1,\n        if negative, `swapQuantity` token1 is swaped for token0\n     */\n    function rebalance(\n        int24 _baseLower,\n        int24 _baseUpper,\n        int24 _limitLower,\n        int24 _limitUpper,\n        int256 swapQuantity\n    ) external override nonReentrant onlyOwner {\n        require(\n            _baseLower < _baseUpper &&\n                _baseLower % tickSpacing == 0 &&\n                _baseUpper % tickSpacing == 0,\n            \"IV.rebalance: base position invalid\"\n        );\n        require(\n            _limitLower < _limitUpper &&\n                _limitLower % tickSpacing == 0 &&\n                _limitUpper % tickSpacing == 0,\n            \"IV.rebalance: limit position invalid\"\n        );\n\n        // update fees\n        (uint128 baseLiquidity, , ) = _position(baseLower, baseUpper);\n        if (baseLiquidity > 0) {\n            IUniswapV3Pool(pool).burn(baseLower, baseUpper, 0);\n        }\n        (uint128 limitLiquidity, , ) = _position(limitLower, limitUpper);\n        if (limitLiquidity > 0) {\n            IUniswapV3Pool(pool).burn(limitLower, limitUpper, 0);\n        }\n\n        // Withdraw all liquidity and collect all fees from Uniswap pool\n        (, uint256 feesBase0, uint256 feesBase1) = _position(\n            baseLower,\n            baseUpper\n        );\n        (, uint256 feesLimit0, uint256 feesLimit1) = _position(\n            limitLower,\n            limitUpper\n        );\n\n        uint256 fees0 = feesBase0 + feesLimit0;\n        uint256 fees1 = feesBase1 + feesLimit1;\n\n        _burnLiquidity(\n            baseLower,\n            baseUpper,\n            baseLiquidity,\n            address(this),\n            true\n        );\n        _burnLiquidity(\n            limitLower,\n            limitUpper,\n            limitLiquidity,\n            address(this),\n            true\n        );\n\n        emit Rebalance(\n            currentTick(),\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            fees0,\n            fees1,\n            totalSupply()\n        );\n\n        // swap tokens if required\n        if (swapQuantity != 0) {\n            IUniswapV3Pool(pool).swap(\n                address(this),\n                swapQuantity > 0,\n                swapQuantity > 0 ? swapQuantity : -swapQuantity,\n                swapQuantity > 0\n                    ? UniV3WrappedLibContainer.MIN_SQRT_RATIO + 1\n                    : UniV3WrappedLibContainer.MAX_SQRT_RATIO - 1,\n                abi.encode(address(this))\n            );\n        }\n\n        baseLower = _baseLower;\n        baseUpper = _baseUpper;\n        baseLiquidity = _liquidityForAmounts(\n            baseLower,\n            baseUpper,\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this))\n        );\n        _mintLiquidity(baseLower, baseUpper, baseLiquidity);\n\n        limitLower = _limitLower;\n        limitUpper = _limitUpper;\n        limitLiquidity = _liquidityForAmounts(\n            limitLower,\n            limitUpper,\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this))\n        );\n        _mintLiquidity(limitLower, limitUpper, limitLiquidity);\n    }\n\n    function setFactory(address _newFactory) external onlyOwner {\n        ichiVaultFactory = _newFactory;\n    }\n\n    /**\n     @notice Mint liquidity in Uniswap V3 pool.\n     @param tickLower The lower tick of the liquidity position\n     @param tickUpper The upper tick of the liquidity position\n     @param liquidity Amount of liquidity to mint\n     @param amount0 Used amount of token0\n     @param amount1 Used amount of token1\n     */\n    function _mintLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        if (liquidity > 0) {\n            (amount0, amount1) = IUniswapV3Pool(pool).mint(\n                address(this),\n                tickLower,\n                tickUpper,\n                liquidity,\n                abi.encode(address(this))\n            );\n        }\n    }\n\n    /**\n     @notice Burn liquidity in Uniswap V3 pool.\n     @param tickLower The lower tick of the liquidity position\n     @param tickUpper The upper tick of the liquidity position\n     @param liquidity amount of liquidity to burn\n     @param to The account to receive token0 and token1 amounts\n     @param collectAll Flag that indicates whether all token0 and token1 tokens should be collected \n                        or only the ones released during this burn\n     @param amount0 released amount of token0\n     @param amount1 released amount of token1\n     */\n    function _burnLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        address to,\n        bool collectAll\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        if (liquidity > 0) {\n            // Burn liquidity\n            (uint256 owed0, uint256 owed1) = IUniswapV3Pool(pool).burn(\n                tickLower,\n                tickUpper,\n                liquidity\n            );\n\n            // Collect amount owed\n            uint128 collect0 = collectAll\n                ? type(uint128).max\n                : _uint128Safe(owed0);\n            uint128 collect1 = collectAll\n                ? type(uint128).max\n                : _uint128Safe(owed1);\n            if (collect0 > 0 || collect1 > 0) {\n                (amount0, amount1) = IUniswapV3Pool(pool).collect(\n                    to,\n                    tickLower,\n                    tickUpper,\n                    collect0,\n                    collect1\n                );\n            }\n        }\n    }\n\n    /**\n     @notice Calculates liquidity amount for the given shares.\n     @param tickLower The lower tick of the liquidity position\n     @param tickUpper The upper tick of the liquidity position\n     @param shares number of shares\n     */\n    function _liquidityForShares(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 shares\n    ) internal view returns (uint128) {\n        (uint128 position, , ) = _position(tickLower, tickUpper);\n        return _uint128Safe((uint256(position) * shares) / totalSupply());\n    }\n\n    /**\n     @notice Returns information about the liquidity position.\n     @param tickLower The lower tick of the liquidity position\n     @param tickUpper The upper tick of the liquidity position\n     @param liquidity liquidity amount\n     @param tokensOwed0 amount of token0 owed to the owner of the position\n     @param tokensOwed1 amount of token1 owed to the owner of the position\n     */\n    function _position(\n        int24 tickLower,\n        int24 tickUpper\n    )\n        internal\n        view\n        returns (uint128 liquidity, uint128 tokensOwed0, uint128 tokensOwed1)\n    {\n        bytes32 positionKey = keccak256(\n            abi.encodePacked(address(this), tickLower, tickUpper)\n        );\n        (liquidity, , , tokensOwed0, tokensOwed1) = IUniswapV3Pool(pool)\n            .positions(positionKey);\n    }\n\n    /**\n     @notice Callback function for mint\n     @dev this is where the payer transfers required token0 and token1 amounts\n     @param amount0 required amount of token0\n     @param amount1 required amount of token1\n     @param data encoded payer's address\n     */\n    function uniswapV3MintCallback(\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external override {\n        require(msg.sender == address(pool), \"cb1\");\n        address payer = abi.decode(data, (address));\n\n        if (payer == address(this)) {\n            if (amount0 > 0) IERC20(token0).safeTransfer(msg.sender, amount0);\n            if (amount1 > 0) IERC20(token1).safeTransfer(msg.sender, amount1);\n        } else {\n            if (amount0 > 0)\n                IERC20(token0).safeTransferFrom(payer, msg.sender, amount0);\n            if (amount1 > 0)\n                IERC20(token1).safeTransferFrom(payer, msg.sender, amount1);\n        }\n    }\n\n    /**\n     @notice Callback function for swap\n     @dev this is where the payer transfers required token0 and token1 amounts\n     @param amount0Delta required amount of token0\n     @param amount1Delta required amount of token1\n     @param data encoded payer's address\n     */\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        require(msg.sender == address(pool), \"cb2\");\n        address payer = abi.decode(data, (address));\n\n        if (amount0Delta > 0) {\n            if (payer == address(this)) {\n                IERC20(token0).safeTransfer(msg.sender, uint256(amount0Delta));\n            } else {\n                IERC20(token0).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount0Delta)\n                );\n            }\n        } else if (amount1Delta > 0) {\n            if (payer == address(this)) {\n                IERC20(token1).safeTransfer(msg.sender, uint256(amount1Delta));\n            } else {\n                IERC20(token1).safeTransferFrom(\n                    payer,\n                    msg.sender,\n                    uint256(amount1Delta)\n                );\n            }\n        }\n    }\n\n    /**\n     @notice Checks if the last price change happened in the current block\n     */\n    function checkHysteresis() private view returns (bool) {\n        (, , uint16 observationIndex, , , , ) = IUniswapV3Pool(pool).slot0();\n        (uint32 blockTimestamp, , , ) = IUniswapV3Pool(pool).observations(\n            observationIndex\n        );\n        return (block.timestamp != blockTimestamp);\n    }\n\n    /**\n     @notice Sets the maximum liquidity token supply the contract allows\n     @dev onlyOwner\n     @param _maxTotalSupply The maximum liquidity token supply the contract allows\n     */\n    function setMaxTotalSupply(uint256 _maxTotalSupply) external onlyOwner {\n        maxTotalSupply = _maxTotalSupply;\n        emit MaxTotalSupply(msg.sender, _maxTotalSupply);\n    }\n\n    /**\n     @notice Sets the hysteresis threshold (in percentage points, 10**16 = 1%).\n        When difference between spot price and TWAP exceeds the threshold, a check for a flashloan attack is executed\n     @dev onlyOwner\n     @param _hysteresis hysteresis threshold\n     */\n    function setHysteresis(uint256 _hysteresis) external onlyOwner {\n        hysteresis = _hysteresis;\n        emit Hysteresis(msg.sender, _hysteresis);\n    }\n\n    /**\n     @notice Sets the affiliate account address where portion of the collected swap fees will be distributed\n     @dev onlyOwner\n     @param _affiliate The affiliate account address\n     */\n    function setAffiliate(address _affiliate) external override onlyOwner {\n        affiliate = _affiliate;\n        emit Affiliate(msg.sender, _affiliate);\n    }\n\n    /**\n     @notice Sets the maximum token0 and token1 amounts the contract allows in a deposit\n     @dev onlyOwner\n     @param _deposit0Max The maximum amount of token0 allowed in a deposit\n     @param _deposit1Max The maximum amount of token1 allowed in a deposit\n     */\n    function setDepositMax(\n        uint256 _deposit0Max,\n        uint256 _deposit1Max\n    ) external override onlyOwner {\n        deposit0Max = _deposit0Max;\n        deposit1Max = _deposit1Max;\n        emit DepositMax(msg.sender, _deposit0Max, _deposit1Max);\n    }\n\n    /**\n     @notice Calculates token0 and token1 amounts for liquidity in a position\n     @param tickLower The lower tick of the liquidity position\n     @param tickUpper The upper tick of the liquidity position\n     @param liquidity Amount of liquidity in the position\n     */\n    function _amountsForLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    ) internal view returns (uint256, uint256) {\n        (uint160 sqrtRatioX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        return\n            UniV3WrappedLibContainer.getAmountsForLiquidity(\n                sqrtRatioX96,\n                UniV3WrappedLibContainer.getSqrtRatioAtTick(tickLower),\n                UniV3WrappedLibContainer.getSqrtRatioAtTick(tickUpper),\n                liquidity\n            );\n    }\n\n    /**\n     @notice Calculates amount of liquidity in a position for given token0 and token1 amounts\n     @param tickLower The lower tick of the liquidity position\n     @param tickUpper The upper tick of the liquidity position\n     @param amount0 token0 amount\n     @param amount1 token1 amount\n     */\n    function _liquidityForAmounts(\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amount0,\n        uint256 amount1\n    ) internal view returns (uint128) {\n        (uint160 sqrtRatioX96, , , , , , ) = IUniswapV3Pool(pool).slot0();\n        return\n            UniV3WrappedLibContainer.getLiquidityForAmounts(\n                sqrtRatioX96,\n                UniV3WrappedLibContainer.getSqrtRatioAtTick(tickLower),\n                UniV3WrappedLibContainer.getSqrtRatioAtTick(tickUpper),\n                amount0,\n                amount1\n            );\n    }\n\n    /**\n     @notice uint128Safe function\n     @param x input value\n     */\n    function _uint128Safe(uint256 x) internal pure returns (uint128) {\n        require(x <= type(uint128).max, \"IV.128_OF\");\n        return uint128(x);\n    }\n\n    /**\n     @notice Calculates total quantity of token0 and token1 in both positions (and unused in the ICHIVault)\n     @param total0 Quantity of token0 in both positions (and unused in the ICHIVault)\n     @param total1 Quantity of token1 in both positions (and unused in the ICHIVault)\n     */\n    function getTotalAmounts()\n        public\n        view\n        override\n        returns (uint256 total0, uint256 total1)\n    {\n        (, uint256 base0, uint256 base1) = getBasePosition();\n        (, uint256 limit0, uint256 limit1) = getLimitPosition();\n        total0 = IERC20(token0).balanceOf(address(this)) + base0 + limit0;\n        total1 = IERC20(token1).balanceOf(address(this)) + base1 + limit1;\n    }\n\n    /**\n     @notice Calculates amount of total liquidity in the base position\n     @param liquidity Amount of total liquidity in the base position\n     @param amount0 Estimated amount of token0 that could be collected by burning the base position\n     @param amount1 Estimated amount of token1 that could be collected by burning the base position\n     */\n    function getBasePosition()\n        public\n        view\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        (\n            uint128 positionLiquidity,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        ) = _position(baseLower, baseUpper);\n        (amount0, amount1) = _amountsForLiquidity(\n            baseLower,\n            baseUpper,\n            positionLiquidity\n        );\n        liquidity = positionLiquidity;\n        amount0 += uint256(tokensOwed0);\n        amount1 += uint256(tokensOwed1);\n    }\n\n    /**\n     @notice Calculates amount of total liquidity in the limit position\n     @param liquidity Amount of total liquidity in the base position\n     @param amount0 Estimated amount of token0 that could be collected by burning the limit position\n     @param amount1 Estimated amount of token1 that could be collected by burning the limit position\n     */\n    function getLimitPosition()\n        public\n        view\n        returns (uint128 liquidity, uint256 amount0, uint256 amount1)\n    {\n        (\n            uint128 positionLiquidity,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        ) = _position(limitLower, limitUpper);\n        (amount0, amount1) = _amountsForLiquidity(\n            limitLower,\n            limitUpper,\n            positionLiquidity\n        );\n        liquidity = positionLiquidity;\n        amount0 += uint256(tokensOwed0);\n        amount1 += uint256(tokensOwed1);\n    }\n\n    /**\n     @notice Returns current price tick\n     @param tick Uniswap pool's current price tick\n     */\n    function currentTick() public view returns (int24 tick) {\n        (, int24 tick_, , , , , bool unlocked_) = IUniswapV3Pool(pool).slot0();\n        require(unlocked_, \"IV.currentTick: the pool is locked\");\n        tick = tick_;\n    }\n\n    /**\n     @notice returns equivalent _tokenOut for _amountIn, _tokenIn using spot price\n     @param _tokenIn token the input amount is in\n     @param _tokenOut token for the output amount\n     @param _tick tick for the spot price\n     @param _amountIn amount in _tokenIn\n     @param amountOut equivalent anount in _tokenOut\n     */\n    function _fetchSpot(\n        address _tokenIn,\n        address _tokenOut,\n        int24 _tick,\n        uint256 _amountIn\n    ) internal pure returns (uint256 amountOut) {\n        return\n            UniV3WrappedLibContainer.getQuoteAtTick(\n                _tick,\n                uint128(_amountIn),\n                _tokenIn,\n                _tokenOut\n            );\n    }\n\n    /**\n     @notice returns equivalent _tokenOut for _amountIn, _tokenIn using TWAP price\n     @param _pool Uniswap V3 pool address to be used for price checking\n     @param _tokenIn token the input amount is in\n     @param _tokenOut token for the output amount\n     @param _twapPeriod the averaging time period\n     @param _amountIn amount in _tokenIn\n     @param amountOut equivalent anount in _tokenOut\n     */\n    function _fetchTwap(\n        address _pool,\n        address _tokenIn,\n        address _tokenOut,\n        uint32 _twapPeriod,\n        uint256 _amountIn\n    ) internal view returns (uint256 amountOut) {\n        // Leave twapTick as a int256 to avoid solidity casting\n        (int256 twapTick, ) = UniV3WrappedLibContainer.consult(_pool, _twapPeriod);\n        return\n            UniV3WrappedLibContainer.getQuoteAtTick(\n                int24(twapTick), // can assume safe being result from consult()\n                uint128(_amountIn),\n                _tokenIn,\n                _tokenOut\n            );\n    }\n}\n"
    },
    "contracts/mock/MockOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../interfaces/IBaseOracle.sol\";\n\ncontract MockOracle is IBaseOracle, Ownable {\n    mapping(address => uint256) public prices; // Mapping from token to price (times 1e18).\n\n    /// The governor sets oracle price for a token.\n    event SetPrice(address token, uint256 px);\n\n    /// @dev Return the USD based price of the given input, multiplied by 10**18.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        return prices[token];\n    }\n\n    /// @dev Set the prices of the given token addresses.\n    /// @param tokens The token addresses to set the prices.\n    /// @param pxs The price data points, representing token value in USD, based 1e18.\n    function setPrice(\n        address[] memory tokens,\n        uint256[] memory pxs\n    ) external onlyOwner {\n        if (tokens.length != pxs.length) revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            prices[tokens[idx]] = pxs[idx];\n            emit SetPrice(tokens[idx], pxs[idx]);\n        }\n    }\n}\n"
    },
    "contracts/mock/MockParaswap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"../interfaces/paraswap/IParaswap.sol\";\nimport \"./MockParaswapTransferProxy.sol\";\n\ncontract MockParaswap is IParaswap {\n    MockParaswapTransferProxy public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(address _transferTokenProxy) {\n        tokenTransferProxy = MockParaswapTransferProxy(_transferTokenProxy);\n    }\n\n    function multiSwap(\n        Utils.SellData calldata data\n    ) external payable returns (uint256) {}\n\n    function megaSwap(\n        Utils.MegaSwapSellData calldata data\n    ) external payable returns (uint256) {\n        tokenTransferProxy.safeTransferFrom(\n            msg.sender,\n            address(this),\n            data.fromToken,\n            data.fromAmount\n        );\n    }\n\n    function protectedMultiSwap(\n        Utils.SellData calldata data\n    ) external payable returns (uint256) {}\n\n    function protectedMegaSwap(\n        Utils.MegaSwapSellData calldata data\n    ) external payable returns (uint256) {}\n\n    function protectedSimpleSwap(\n        Utils.SimpleData calldata data\n    ) external payable returns (uint256 receivedAmount) {}\n\n    function protectedSimpleBuy(\n        Utils.SimpleData calldata data\n    ) external payable {}\n\n    function simpleSwap(\n        Utils.SimpleData calldata data\n    ) external payable returns (uint256 receivedAmount) {}\n\n    function simpleBuy(Utils.SimpleData calldata data) external payable {}\n\n    function swapOnUniswap(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external payable {}\n\n    function swapOnUniswapFork(\n        address factory,\n        bytes32 initCode,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path\n    ) external payable {}\n\n    function buyOnUniswap(\n        uint256 amountInMax,\n        uint256 amountOut,\n        address[] calldata path\n    ) external payable {}\n\n    function buyOnUniswapFork(\n        address factory,\n        bytes32 initCode,\n        uint256 amountInMax,\n        uint256 amountOut,\n        address[] calldata path\n    ) external payable {}\n\n    function swapOnUniswapV2Fork(\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address weth,\n        uint256[] calldata pools\n    ) external payable {}\n\n    function buyOnUniswapV2Fork(\n        address tokenIn,\n        uint256 amountInMax,\n        uint256 amountOut,\n        address weth,\n        uint256[] calldata pools\n    ) external payable {}\n\n    function swapOnZeroXv2(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 fromAmount,\n        uint256 amountOutMin,\n        address exchange,\n        bytes calldata payload\n    ) external payable {}\n\n    function swapOnZeroXv4(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint256 fromAmount,\n        uint256 amountOutMin,\n        address exchange,\n        bytes calldata payload\n    ) external payable {}\n}\n"
    },
    "contracts/mock/MockParaswapTransferProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract MockParaswapTransferProxy {\n    using SafeERC20 for IERC20;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        address token,\n        uint amount\n    ) external {\n        IERC20(token).safeTransferFrom(from, to, amount);\n    }\n}\n"
    },
    "contracts/mock/MockStashToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ncontract MockStashToken {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public constant MAX_TOTAL_SUPPLY = 1e38;\n\n    address public rewardPool;\n    address public baseToken;\n\n    uint256 internal _totalSupply;\n\n    function init(address _rewardPool, address _baseToken) external {\n        rewardPool = _rewardPool;\n        baseToken = _baseToken;\n    }\n\n    function name() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"Stash Token \",\n                    IERC20Metadata(baseToken).name()\n                )\n            );\n    }\n\n    function symbol() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\"STASH-\", IERC20Metadata(baseToken).symbol())\n            );\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function mint(uint256 _amount) external {\n        require(\n            _totalSupply.add(_amount) < MAX_TOTAL_SUPPLY,\n            \"totalSupply exceeded\"\n        );\n\n        _totalSupply = _totalSupply.add(_amount);\n        IERC20(baseToken).safeTransferFrom(msg.sender, address(this), _amount);\n    }\n\n    function transfer(address _to, uint256 _amount) public returns (bool) {\n        require(msg.sender == rewardPool, \"!rewardPool\");\n        require(_totalSupply >= _amount, \"amount>totalSupply\");\n\n        _totalSupply = _totalSupply.sub(_amount);\n        IERC20(baseToken).safeTransfer(_to, _amount);\n\n        return true;\n    }\n}\n"
    },
    "contracts/mock/MockVirtualBalanceRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\n\ninterface IDeposit {\n    function isShutdown() external view returns (bool);\n\n    function balanceOf(address _account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function poolInfo(\n        uint256\n    ) external view returns (address, address, address, address, address, bool);\n\n    function rewardClaimed(uint256, address, uint256) external;\n\n    function withdrawTo(uint256, uint256, address) external;\n\n    function claimRewards(uint256, address) external returns (bool);\n\n    function rewardArbitrator() external returns (address);\n\n    function setGaugeRedirect(uint256 _pid) external returns (bool);\n\n    function owner() external returns (address);\n\n    function deposit(\n        uint256 _pid,\n        uint256 _amount,\n        bool _stake\n    ) external returns (bool);\n}\n\ncontract MockVirtualBalanceRewardPool {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 public immutable rewardToken;\n    uint256 public constant duration = 7 days;\n\n    IDeposit public immutable deposits;\n\n    uint256 public rewardPerToken;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public queuedRewards = 0;\n    uint256 public currentRewards = 0;\n    uint256 public historicalRewards = 0;\n    uint256 public constant newRewardRatio = 830;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /**\n     * @param deposit_  Parent deposit pool e.g cvxCRV staking in BaseRewardPool\n     * @param reward_   The rewards token e.g 3Crv\n     */\n    constructor(address deposit_, address reward_) {\n        deposits = IDeposit(deposit_);\n        rewardToken = IERC20(reward_);\n    }\n\n    /**\n     * @notice Update rewards earned by this account\n     */\n    modifier updateReward(address account) {\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function setRewardPerToken(uint _rewardPerToken) external {\n        rewardPerToken = _rewardPerToken;\n    }\n\n    function setReward(address user, uint amount) external {\n        rewards[user] = amount;\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return deposits.totalSupply();\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return deposits.balanceOf(account);\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return rewards[account];\n    }\n\n    /**\n     * @notice  Update reward, emit, call linked reward's stake\n     * @dev     Callable by the deposits address which is the BaseRewardPool\n     *          this updates the virtual balance of this user as this contract doesn't\n     *          actually hold any staked tokens it just diributes reward tokens\n     */\n    function stake(\n        address _account,\n        uint256 amount\n    ) external updateReward(_account) {\n        require(msg.sender == address(deposits), \"!authorized\");\n        // require(amount > 0, 'VirtualDepositRewardPool: Cannot stake 0');\n        emit Staked(_account, amount);\n    }\n\n    /**\n     * @notice  Withdraw stake and update reward, emit, call linked reward's stake\n     * @dev     See stake\n     */\n    function withdraw(\n        address _account,\n        uint256 amount\n    ) public updateReward(_account) {\n        require(msg.sender == address(deposits), \"!authorized\");\n        //require(amount > 0, 'VirtualDepositRewardPool : Cannot withdraw 0');\n\n        emit Withdrawn(_account, amount);\n    }\n\n    /**\n     * @notice  Get rewards for this account\n     * @dev     This can be called directly but it is usually called by the\n     *          BaseRewardPool getReward when the BaseRewardPool loops through\n     *          it's extraRewards array calling getReward on all of them\n     */\n    function getReward(address _account) public updateReward(_account) {\n        uint256 reward = earned(_account);\n        if (reward > 0) {\n            rewards[_account] = 0;\n            rewardToken.safeTransfer(_account, reward);\n            emit RewardPaid(_account, reward);\n        }\n    }\n\n    function getReward() external {\n        getReward(msg.sender);\n    }\n\n    function donate(uint256 _amount) external returns (bool) {\n        IERC20(rewardToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            _amount\n        );\n        queuedRewards = queuedRewards.add(_amount);\n    }\n\n    function queueNewRewards(uint256 _rewards) external {\n        _rewards = _rewards.add(queuedRewards);\n\n        if (block.timestamp >= periodFinish) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n            return;\n        }\n\n        //et = now - (finish-duration)\n        uint256 elapsedTime = block.timestamp.sub(periodFinish.sub(duration));\n        //current at now: rewardRate * elapsedTime\n        uint256 currentAtNow = rewardRate * elapsedTime;\n        uint256 queuedRatio = currentAtNow.mul(1000).div(_rewards);\n        if (queuedRatio < newRewardRatio) {\n            notifyRewardAmount(_rewards);\n            queuedRewards = 0;\n        } else {\n            queuedRewards = _rewards;\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 reward\n    ) internal updateReward(address(0)) {\n        historicalRewards = historicalRewards.add(reward);\n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(duration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            reward = reward.add(leftover);\n            rewardRate = reward.div(duration);\n        }\n        currentRewards = reward;\n        lastUpdateTime = block.timestamp;\n        periodFinish = block.timestamp.add(duration);\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "contracts/mock/MockWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.16;\n\ncontract MockWETH {\n    string public name = 'Wrapped Ether';\n    string public symbol = 'WETH';\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint256).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/oracle/AggregatorOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./BaseOracleExt.sol\";\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../interfaces/IBaseOracle.sol\";\n\n/// @title AggregatorOracle\n/// @author BlueberryProtocol\n/// @notice This contract aggregates price feeds from multiple oracle sources, \n///         ensuring a more reliable and resilient price data.\ncontract AggregatorOracle is IBaseOracle, Ownable, BaseOracleExt {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Mapping of primary oracle sources associated with each token.\n    mapping(address => uint256) public primarySourceCount;\n    /// @notice Mapping from token to (mapping from index to oracle source)\n    mapping(address => mapping(uint256 => IBaseOracle)) public primarySources;\n    //// @notice Maximum allowed price deviation between oracle sources, expressed in base 10000.\n    mapping(address => uint256) public maxPriceDeviations;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      EVENTS \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when primary oracle sources are set or updated for a token.\n    /// @param token Address of the token whose oracle sources were updated.\n    /// @param maxPriceDeviation Maximum allowed price deviation.\n    /// @param oracles List of oracle sources set for the token.\n    event SetPrimarySources(\n        address indexed token,\n        uint256 maxPriceDeviation,\n        IBaseOracle[] oracles\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Set primary oracle sources for given token\n    /// @dev Emit SetPrimarySources event when primary oracles set successfully\n    /// @param token Token to set oracle sources\n    /// @param maxPriceDeviation Maximum price deviation (in 1e18) of price feeds\n    /// @param sources Oracle sources for the token\n    function _setPrimarySources(\n        address token,\n        uint256 maxPriceDeviation,\n        IBaseOracle[] memory sources\n    ) internal {\n        // Validate inputs\n        if (token == address(0)) revert Errors.ZERO_ADDRESS();\n        if (maxPriceDeviation > Constants.MAX_PRICE_DEVIATION)\n            revert Errors.OUT_OF_DEVIATION_CAP(maxPriceDeviation);\n        if (sources.length > 3) revert Errors.EXCEED_SOURCE_LEN(sources.length);\n\n        primarySourceCount[token] = sources.length;\n        maxPriceDeviations[token] = maxPriceDeviation;\n        for (uint256 idx = 0; idx < sources.length; idx++) {\n            if (address(sources[idx]) == address(0))\n                revert Errors.ZERO_ADDRESS();\n            primarySources[token][idx] = sources[idx];\n        }\n        emit SetPrimarySources(token, maxPriceDeviation, sources);\n    }\n\n    /// @notice Set primary oracle sources for the given token\n    /// @dev Only owner can set primary sources\n    /// @param token Token address to set oracle sources\n    /// @param maxPriceDeviation Maximum price deviation (in 1e18) of price feeds\n    /// @param sources Oracle sources for the token\n    function setPrimarySources(\n        address token,\n        uint256 maxPriceDeviation,\n        IBaseOracle[] memory sources\n    ) external onlyOwner {\n        _setPrimarySources(token, maxPriceDeviation, sources);\n    }\n\n    /// @notice Set or update the primary oracle sources for multiple tokens at once.\n    /// Can only be called by the contract owner.\n    /// @param tokens List of token addresses.\n    /// @param maxPriceDeviationList List of maximum allowed price deviations (in 1e18).\n    /// @param allSources list of oracle sources, one list for each token.\n    function setMultiPrimarySources(\n        address[] memory tokens,\n        uint256[] memory maxPriceDeviationList,\n        IBaseOracle[][] memory allSources\n    ) external onlyOwner {\n        // Validate inputs\n        if (\n            tokens.length != allSources.length ||\n            tokens.length != maxPriceDeviationList.length\n        ) revert Errors.INPUT_ARRAY_MISMATCH();\n\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            _setPrimarySources(\n                tokens[idx],\n                maxPriceDeviationList[idx],\n                allSources[idx]\n            );\n        }\n    }\n\n    /// @notice Fetch the aggregated USD price of a token.\n    /// If there are multiple valid sources, the function aggregates and ensures the data is within acceptable deviation limits.\n    /// @param token Address of the token to fetch the price for.\n    /// @return The aggregated USD price of the token, scaled by 10**18.\n    function getPrice(address token) external override returns (uint256) {\n        uint256 candidateSourceCount = primarySourceCount[token];\n        if (candidateSourceCount == 0) revert Errors.NO_PRIMARY_SOURCE(token);\n        uint256[] memory prices = new uint256[](candidateSourceCount);\n\n        /// Get valid oracle sources\n        uint256 validSourceCount = 0;\n        for (uint256 idx = 0; idx < candidateSourceCount; idx++) {\n            try primarySources[token][idx].getPrice(token) returns (\n                uint256 px\n            ) {\n                if (px != 0) prices[validSourceCount++] = px;\n            } catch {}\n        }\n        if (validSourceCount == 0) revert Errors.NO_VALID_SOURCE(token);\n        /// Sort prices in ascending order\n        for (uint256 i = 0; i < validSourceCount - 1; i++) {\n            for (uint256 j = 0; j < validSourceCount - i - 1; j++) {\n                if (prices[j] > prices[j + 1]) {\n                    (prices[j], prices[j + 1]) = (prices[j + 1], prices[j]);\n                }\n            }\n        }\n        uint256 maxPriceDeviation = maxPriceDeviations[token];\n\n        /// Algo:\n        /// - 1 valid source --> return price\n        /// - 2 valid sources\n        ///     --> if the prices within deviation threshold, return average\n        ///     --> else revert\n        /// - 3 valid sources --> check deviation threshold of each pair\n        ///     --> if all within threshold, return median\n        ///     --> if one pair within threshold, return average of the pair\n        ///     --> if none, revert\n        /// - revert Errors.otherwise\n        if (validSourceCount == 1) {\n            return prices[0]; // if 1 valid source, return\n        } else if (validSourceCount == 2) {\n            if (!_isValidPrices(prices[0], prices[1], maxPriceDeviation))\n                revert Errors.EXCEED_DEVIATION();\n            return (prices[0] + prices[1]) / 2; /// if 2 valid sources, return average\n        } else {\n            bool midMinOk = _isValidPrices(\n                prices[0],\n                prices[1],\n                maxPriceDeviation\n            );\n            bool maxMidOk = _isValidPrices(\n                prices[1],\n                prices[2],\n                maxPriceDeviation\n            );\n            if (midMinOk && maxMidOk) {\n                return prices[1]; /// if 3 valid sources, and each pair is within thresh, return median\n            } else if (midMinOk) {\n                return (prices[0] + prices[1]) / 2; /// return average of pair within thresh\n            } else if (maxMidOk) {\n                return (prices[1] + prices[2]) / 2; /// return average of pair within thresh\n            } else {\n                revert Errors.EXCEED_DEVIATION();\n            }\n        }\n    }\n}\n"
    },
    "contracts/oracle/BandAdapterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/band/IStdReference.sol\";\n\n/// @title BandAdapterOracle\n/// @author BlueberryProtocol\n/// @notice This contract is an adapter that fetches price feeds from Band Protocol.\ncontract BandAdapterOracle is IBaseOracle, BaseAdapter {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice The BandStandardRef oracle contract instance for price feeds.\n    IStdReference public ref;\n\n    /// @notice A mapping from token addresses to their respective symbol strings.\n    /// Band Protocol provides price feeds based on token symbols.\n    mapping(address => string) public symbols;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a new Band Protocol reference instance is set.\n    /// @param ref Address of the new Band Protocol reference contract.\n    event SetRef(address ref);\n\n    /// @notice Emitted when a token's symbol string is set or updated.\n    /// @param token The token address whose symbol was set.\n    /// @param symbol The new token symbol string.\n    event SetSymbol(address token, string symbol);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs the BandAdapterOracle contract instance.\n    /// @param ref_ Address of the Band Protocol reference contract.\n    constructor(IStdReference ref_) {\n        if (address(ref_) == address(0)) revert Errors.ZERO_ADDRESS();\n\n        ref = ref_;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Updates the standard reference contract used to fetch price data.\n    /// @param ref_ The new Band Protocol reference contract address.\n    function setRef(IStdReference ref_) external onlyOwner {\n        if (address(ref_) == address(0)) revert Errors.ZERO_ADDRESS();\n        ref = ref_;\n        emit SetRef(address(ref_));\n    }\n\n    /// @notice Sets or updates symbols for a list of tokens.\n    /// @param tokens List of token addresses.\n    /// @param syms List of corresponding symbol strings.\n    function setSymbols(\n        address[] calldata tokens,\n        string[] calldata syms\n    ) external onlyOwner {\n        if (syms.length != tokens.length) revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < syms.length; idx++) {\n            if (tokens[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            symbols[tokens[idx]] = syms[idx];\n            emit SetSymbol(tokens[idx], syms[idx]);\n        }\n    }\n\n    /// @notice Fetches the current USD price of the specified token.\n    /// @dev The price returned has a precision of 1e18. The Band Protocol already provides prices with this precision.\n    /// @param token The address of the ERC-20 token to get the price for.\n    /// @return The current USD price of the token.\n    function getPrice(address token) external override returns (uint256) {\n        string memory sym = symbols[token];\n        uint256 maxDelayTime = timeGaps[token];\n        if (bytes(sym).length == 0) revert Errors.NO_SYM_MAPPING(token);\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token);\n\n        IStdReference.ReferenceData memory data = ref.getReferenceData(\n            sym,\n            \"USD\"\n        );\n        if (\n            data.lastUpdatedBase < block.timestamp - maxDelayTime ||\n            data.lastUpdatedQuote < block.timestamp - maxDelayTime\n        ) revert Errors.PRICE_OUTDATED(token);\n\n        return data.rate;\n    }\n}\n"
    },
    "contracts/oracle/BaseAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/BlueBerryConst.sol\" as Constants;\n\n/// @title BaseAdapter\n/// @author BlueberryProtocol\n/// @notice This contract provides a base for adapters that interface with external oracle services.\n/// It allows the owner to set time gaps for price feed data of different tokens.\nabstract contract BaseAdapter is Ownable {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice A mapping that associates each token address with its respective time gap.\n    /// Time gap represents the acceptable age of the data before it is considered outdated.\n    mapping(address => uint256) public timeGaps;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when a time gap for a specific token is set or updated.\n    /// @param token The token address for which the time gap was set.\n    /// @param gap The new time gap value (in seconds).\n    event SetTimeGap(address token, uint256 gap);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Allows the owner to set time gaps for a list of tokens. \n    /// The time gap is used to determine the acceptable age of the oracle data.\n    /// @param tokens List of token addresses for which time gaps will be set.\n    /// @param gaps Corresponding list of time gaps to set for each token.\n    function setTimeGap(\n        address[] calldata tokens,\n        uint256[] calldata gaps\n    ) external onlyOwner {\n        if (tokens.length != gaps.length) revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (gaps[idx] > Constants.MAX_TIME_GAP)\n                revert Errors.TOO_LONG_DELAY(gaps[idx]);\n            if (gaps[idx] < Constants.MIN_TIME_GAP)\n                revert Errors.TOO_LOW_MEAN(gaps[idx]);\n            if (tokens[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n            timeGaps[tokens[idx]] = gaps[idx];\n            emit SetTimeGap(tokens[idx], gaps[idx]);\n        }\n    }\n}\n"
    },
    "contracts/oracle/BaseOracleExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"../utils/BlueBerryConst.sol\" as Constants;\n\nabstract contract BaseOracleExt {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function to validate deviations of 2 given prices\n    /// @param price0 First price to validate, base 1e18\n    /// @param price1 Second price to validate, base 1e18\n    /// @param maxPriceDeviation Max price deviation of 2 prices, base 10000\n    function _isValidPrices(\n        uint256 price0,\n        uint256 price1,\n        uint256 maxPriceDeviation\n    ) internal pure returns (bool) {\n        uint256 maxPrice = price0 > price1 ? price0 : price1;\n        uint256 minPrice = price0 > price1 ? price1 : price0;\n        return\n            (((maxPrice - minPrice) * Constants.DENOMINATOR) / maxPrice) <=\n            maxPriceDeviation;\n    }\n}\n"
    },
    "contracts/oracle/ChainlinkAdapterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/IFeedRegistry.sol\";\n\n/// @title ChainlinkAdapterOracle for L1 Chains\n/// @author BlueberryProtocol\n/// @notice This Oracle Adapter leverages Chainlink's decentralized price feeds to provide accurate price data.\n///         It also supports remapping of tokens to their canonical forms (e.g., WBTC to BTC).\ncontract ChainlinkAdapterOracle is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Chainlink feed registry for accessing price feeds.\n    /// (source: https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/Denominations.sol)\n    IFeedRegistry public registry;\n    /// Address representing USD in Chainlink's denominations.\n    address public constant USD = address(840);\n\n    /// @dev Maps tokens to their canonical form for price querying.\n    ///      For example, WETH may be remapped to ETH, WBTC to BTC, etc.\n    mapping(address => address) public remappedTokens;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when the Chainlink feed registry used by the adapter is updated.\n    /// @param registry The new Chainlink feed registry address.\n    event SetRegistry(address registry);\n\n    /// @notice Emitted when a token is remapped to its canonical form.\n    /// @param token The original token address that's being remapped.\n    /// @param remappedToken The canonical form of the token to which the original is remapped.\n    event SetTokenRemapping(\n        address indexed token,\n        address indexed remappedToken\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @param registry_ Chainlink feed registry address.\n    constructor(IFeedRegistry registry_) {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n\n        registry = registry_;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Updates the Chainlink feed registry used by this adapter.\n    /// @param registry_ The new Chainlink feed registry address.\n    /// @dev Can only be called by the contract owner.\n    function setFeedRegistry(IFeedRegistry registry_) external onlyOwner {\n        if (address(registry_) == address(0)) revert Errors.ZERO_ADDRESS();\n        registry = registry_;\n        emit SetRegistry(address(registry_));\n    }\n\n    /// @notice Maps a list of tokens to their canonical form for price queries.\n    /// @param tokens_ The list of tokens to be remapped.\n    /// @param remappedTokens_ The list of tokens to remap to.\n    /// @dev Both arrays should have the same length. Can only be called by the contract owner.\n    function setTokenRemappings(\n        address[] calldata tokens_,\n        address[] calldata remappedTokens_\n    ) external onlyOwner {\n        if (remappedTokens_.length != tokens_.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens_.length; idx++) {\n            if (tokens_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            remappedTokens[tokens_[idx]] = remappedTokens_[idx];\n            emit SetTokenRemapping(tokens_[idx], remappedTokens_[idx]);\n        }\n    }\n\n    /// @notice Fetches the USD price of the specified token from Chainlink's feed.\n    ///         If the token has been remapped, it uses the canonical form for price querying.\n    /// @param token_ Address of the token for which to fetch the price.\n    /// @return price The USD price of the token, represented with 18 decimals.\n    function getPrice(address token_) external override returns (uint256) {\n        /// remap token if possible\n        address token = remappedTokens[token_];\n        if (token == address(0)) token = token_;\n\n        uint256 maxDelayTime = timeGaps[token];\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token_);\n\n        /// Get token-USD price\n        uint256 decimals = registry.decimals(token, USD);\n        (\n            uint80 roundID,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = registry.latestRoundData(token, USD);\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (answer <= 0) revert Errors.PRICE_NEGATIVE(token_);\n        if (answeredInRound < roundID) revert Errors.PRICE_OUTDATED(token_);\n\n        return\n            (answer.toUint256() * Constants.PRICE_PRECISION) / 10 ** decimals;\n    }\n}\n"
    },
    "contracts/oracle/ChainlinkAdapterOracleL2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"./BaseAdapter.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/chainlink/ISequencerUptimeFeed.sol\";\n\n/// @title Chainlink Adapter Oracle for L2 chains including Arb, Optimism, etc.\n/// @author BlueberryProtocol\n/// @notice This contract integrates Chainlink's Oracle to fetch price data on Layer 2 networks.\n///         It also monitors the uptime status of the L2 sequencer.\ncontract ChainlinkAdapterOracleL2 is IBaseOracle, BaseAdapter {\n    using SafeCast for int256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Reference to the sequencer uptime feed (used to monitor L2 chain status).\n    ISequencerUptimeFeed public sequencerUptimeFeed;\n\n    /// @dev A mapping from a token address to its associated Chainlink price feed.\n    mapping(address => address) public priceFeeds;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Emitted when the registry is updated.\n    /// @param registry The address of the updated registry.\n    event SetRegistry(address registry);\n\n    /// @notice Emitted when the L2 sequencer uptime feed registry source is updated.\n    /// @param registry The address of the updated L2 sequencer uptime feed registry.\n    event SetSequencerUptimeFeed(address registry);\n\n    /// @notice Emitted when a new price feed for a token is set or updated.\n    /// @param token The address of the token for which the price feed is set or updated.\n    /// @param priceFeed The address of the Chainlink price feed for the token.    \n    event SetTokenPriceFeed(address indexed token, address indexed priceFeed);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs the ChainlinkAdapterOracleL2 and sets the L2 sequencer uptime feed.\n    /// @param sequencerUptimeFeed_ The Chainlink L2 sequencer uptime feed source.\n    constructor(ISequencerUptimeFeed sequencerUptimeFeed_) {\n        if (address(sequencerUptimeFeed_) == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        sequencerUptimeFeed = sequencerUptimeFeed_;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Sets the Chainlink L2 sequencer uptime feed registry source.\n    /// @param sequencerUptimeFeed_ Chainlink L2 sequencer uptime feed source.\n    function setSequencerUptimeFeed(\n        ISequencerUptimeFeed sequencerUptimeFeed_\n    ) external onlyOwner {\n        if (address(sequencerUptimeFeed_) == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        sequencerUptimeFeed = sequencerUptimeFeed_;\n        emit SetSequencerUptimeFeed(address(sequencerUptimeFeed_));\n    }\n\n    /// @notice Sets the price feeds for specified tokens.\n    /// @param tokens_ List of tokens for which the price feeds are being set.\n    /// @param priceFeeds_ Corresponding list of Chainlink price feeds.\n    function setPriceFeeds(\n        address[] calldata tokens_,\n        address[] calldata priceFeeds_\n    ) external onlyOwner {\n        if (tokens_.length != priceFeeds_.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens_.length; idx++) {\n            if (tokens_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n            if (priceFeeds_[idx] == address(0)) revert Errors.ZERO_ADDRESS();\n\n            priceFeeds[tokens_[idx]] = priceFeeds_[idx];\n            emit SetTokenPriceFeed(tokens_[idx], priceFeeds_[idx]);\n        }\n    }\n\n    /// @notice Returns the USD price of the specified token. Price value is with 18 decimals.\n    /// @param token_ Token address to get the price of.\n    /// @return price USD price of the specified token.\n    /// @dev Fetches the price from the Chainlink price feed, checks sequencer status, and verifies price validity.\n    function getPrice(address token_) external view override returns (uint256) {\n        /// 1. Check for the maximum acceptable delay time.\n        uint256 maxDelayTime = timeGaps[token_];\n        if (maxDelayTime == 0) revert Errors.NO_MAX_DELAY(token_);\n\n        /// 2. L2 sequencer status check (0 = up, 1 = down).\n        (, int256 answer, uint256 startedAt, , ) = sequencerUptimeFeed\n            .latestRoundData();\n\n        /// Ensure the grace period has passed after the sequencer is back up.\n        bool isSequencerUp = answer == 0;\n        if (!isSequencerUp) {\n            revert Errors.SEQUENCER_DOWN(address(sequencerUptimeFeed));\n        }\n\n        uint256 timeSinceUp = block.timestamp - startedAt;\n        if (timeSinceUp <= Constants.SEQUENCER_GRACE_PERIOD_TIME) {\n            revert Errors.SEQUENCER_GRACE_PERIOD_NOT_OVER(\n                address(sequencerUptimeFeed)\n            );\n        }\n\n        /// 3. Retrieve the price from the Chainlink feed.\n        address priceFeed = priceFeeds[token_];\n        if (priceFeed == address(0)) revert Errors.ZERO_ADDRESS();\n\n        /// Get token-USD price\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = AggregatorV3Interface(priceFeed).latestRoundData();\n        if (updatedAt < block.timestamp - maxDelayTime)\n            revert Errors.PRICE_OUTDATED(token_);\n        if (price <= 0) revert Errors.PRICE_NEGATIVE(token_);\n        if (answeredInRound < roundID) revert Errors.PRICE_OUTDATED(token_);\n\n        return\n            (price.toUint256() * Constants.PRICE_PRECISION) /\n            Constants.CHAINLINK_PRICE_FEED_PRECISION;\n    }\n}\n"
    },
    "contracts/oracle/CompStableBPTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/FixedPointMathLib.sol\";\n\n/// @title Composable Stable Balancer LP Oracle\n/// @author BlueberryProtocol\n/// @notice Oracle contract which privides price feeds of Composable Stable Balancer LP tokens\ncontract CompStableBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs the `CompStableBPTOracle` with a reference to a base oracle.\n    /// @param _base The base oracle used for fetching price data.\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Provides the USD value of the given Balancer LP token, with 18 decimals of precision.\n    /// @param token The address of the Balancer LP token whose USD value is to be fetched.\n    /// @return The USD value of the specified Balancer LP token.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        /// Use a reentrancy guard to protect against potential flashloan attacks.\n        checkReentrancy(vault);\n\n        /// Get the list of tokens from the associated Balancer pool.\n        (address[] memory tokens, , ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256 length = tokens.length;\n        uint256 minPrice = type(uint256).max;\n        /// Iterate over tokens to get their respective prices and determine the minimum.\n        for(uint256 i; i != length; ++i) {\n            if (tokens[i] == token) continue;\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        /// Return the USD value of the LP token by multiplying the minimum price with the rate from the pool.\n        return minPrice.mulWadDown(pool.getRate());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}\n"
    },
    "contracts/oracle/CoreOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryConst.sol\" as Constants;\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../interfaces/ICoreOracle.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\n\n/// @title CoreOracle\n/// @author BlueberryProtocol\n/// @notice This oracle contract provides reliable price feeds to the Bank contract.\n/// It maintains a registry of routes pointing to price feed sources.\n/// The price feed sources can be aggregators, liquidity pool oracles, or any other\n/// custom oracles that conform to the `IBaseOracle` interface.\ncontract CoreOracle is ICoreOracle, OwnableUpgradeable, PausableUpgradeable {\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from token to oracle routes. => Aggregator | LP Oracle | AdapterOracle ...\n    mapping(address => address) public routes;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Initializes the CoreOracle contract\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    /// @notice Pauses the contract.\n    /// This function can only be called by the owner.\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract.\n    /// This function can only be called by the owner.\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /// @notice Register oracle routes for specific tokens.\n    /// @param tokens Array of token addresses.\n    /// @param oracleRoutes Array of oracle addresses corresponding to each token.\n    function setRoutes(\n        address[] calldata tokens,\n        address[] calldata oracleRoutes\n    ) external onlyOwner {\n        if (tokens.length != oracleRoutes.length)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            address token = tokens[idx];\n            address route = oracleRoutes[idx];\n            if (token == address(0) || route == address(0))\n                revert Errors.ZERO_ADDRESS();\n\n            routes[token] = route;\n            emit SetRoute(token, route);\n        }\n    }\n\n    /// @dev Fetches the price of the given token in USD with 18 decimals precision.\n    /// @param token ERC-20 token address.\n    /// @return price Price of the token.\n    function _getPrice(address token) internal whenNotPaused returns (uint256) {\n        address route = routes[token];\n        if (route == address(0)) revert Errors.NO_ORACLE_ROUTE(token);\n        uint256 px = IBaseOracle(route).getPrice(token);\n        if (px == 0) revert Errors.PRICE_FAILED(token);\n        return px;\n    }\n\n    /// @notice Fetches the price of the given token in USD with 18 decimals precision.\n    /// @param token ERC-20 token address.\n    /// @return price Price of the token.\n    function getPrice(address token) external override returns (uint256) {\n        return _getPrice(token);\n    }\n\n    /// @dev Checks if the oracle supports the given ERC20 token.\n    /// @param token ERC20 token address to check.\n    /// @return bool True if supported, false otherwise.\n    function _isTokenSupported(address token) internal returns (bool) {\n        address route = routes[token];\n        if (route == address(0)) return false;\n        try IBaseOracle(route).getPrice(token) returns (uint256 price) {\n            return price != 0;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Checks if the oracle supports the given ERC20 token.\n    /// @param token ERC20 token address to check.\n    /// @return bool True if supported, false otherwise.\n    function isTokenSupported(address token) external override returns (bool) {\n        return _isTokenSupported(token);\n    }\n\n    /// @notice Determines if the oracle supports the underlying token of a given wrapped token.\n    /// @dev This is specific to the Blueberry protocol's ERC1155 wrappers (e.g., WERC20).\n    /// @param token ERC1155 token address.\n    /// @param tokenId ERC1155 token ID.\n    /// @return bool True if the underlying token is supported, false otherwise\n    function isWrappedTokenSupported(\n        address token,\n        uint256 tokenId\n    ) external override returns (bool) {\n        address uToken = IERC20Wrapper(token).getUnderlyingToken(tokenId);\n        return _isTokenSupported(uToken);\n    }\n\n    /// @dev Fetches the USD value of the specified amount of a token.\n    /// @param token ERC20 token address.\n    /// @param amount Amount of the token.\n    /// @return value USD value of the token amount.\n    function _getTokenValue(\n        address token,\n        uint256 amount\n    ) internal returns (uint256 value) {\n        uint256 decimals = IERC20MetadataUpgradeable(token).decimals();\n        value = (_getPrice(token) * amount) / 10 ** decimals;\n    }\n\n    /// @notice Calculates the USD value of wrapped ERC1155 tokens.\n    /// @param token ERC1155 Wrapper token address.\n    /// @param id ERC1155 token ID.\n    /// @param amount Token amount (assumed to be in 1e18 format).\n    /// @return positionValue The USD value of the wrapped token.\n    function getWrappedTokenValue(\n        address token,\n        uint256 id,\n        uint256 amount\n    ) external override returns (uint256 positionValue) {\n        address uToken = IERC20Wrapper(token).getUnderlyingToken(id);\n        positionValue = _getTokenValue(uToken, amount);\n    }\n\n    /// @notice Fetches the USD value of the specified amount of a token.\n    /// @param token ERC20 token address.\n    /// @param amount Amount of the token.\n    /// @return value USD value of the token amount.\n    function getTokenValue(\n        address token,\n        uint256 amount\n    ) external override returns (uint256) {\n        return _getTokenValue(token, amount);\n    }\n}\n"
    },
    "contracts/oracle/CurveBaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as BlueBerryErrors;\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/curve/ICurveRegistry.sol\";\nimport \"../interfaces/curve/ICurveCryptoSwapRegistry.sol\";\nimport \"../interfaces/curve/ICurveAddressProvider.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\n\n/// @title Curve Base Oracle\n/// @author BlueberryProtocol\n/// @notice Abstract base oracle for Curve LP token price feeds.\nabstract contract CurveBaseOracle is UsingBaseOracle, ICurveOracle, Ownable {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// Address provider for Curve-related contracts.\n    ICurveAddressProvider public immutable addressProvider;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                       EVENTS \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Emitted when a Curve LP token is registered with its associated pool and underlying tokens.\n    event CurveLpRegistered(\n        address crvLp,\n        address pool,\n        address[] underlyingTokens\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) UsingBaseOracle(base_) {\n        addressProvider = addressProvider_;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Fetches Curve pool information for a given Curve LP token address.\n    /// @param crvLp Curve LP token address.\n    /// @return pool The address of the associated Curve pool.\n    /// @return ulTokens Underlying tokens of the Curve pool.\n    /// @return virtualPrice Virtual price of the Curve pool.\n    function _getPoolInfo(\n        address crvLp\n    )\n        internal\n        returns (address pool, address[] memory ulTokens, uint256 virtualPrice)\n    {\n        /// 1. Attempt retrieval from main Curve registry.\n        address registry = addressProvider.get_registry();\n        pool = ICurveRegistry(registry).get_pool_from_lp_token(crvLp);\n        if (pool != address(0)) {\n            (uint256 n, ) = ICurveRegistry(registry).get_n_coins(pool);\n            address[8] memory coins = ICurveRegistry(registry).get_coins(pool);\n            ulTokens = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                ulTokens[i] = coins[i];\n            }\n            virtualPrice = ICurveRegistry(registry)\n                .get_virtual_price_from_lp_token(crvLp);\n            return (pool, ulTokens, virtualPrice);\n        }\n\n        /// 2. Attempt retrieval from CryptoSwap Curve registry.\n        registry = addressProvider.get_address(5);\n        pool = ICurveCryptoSwapRegistry(registry).get_pool_from_lp_token(crvLp);\n        if (pool != address(0)) {\n            uint256 n = ICurveCryptoSwapRegistry(registry).get_n_coins(pool);\n            address[8] memory coins = ICurveCryptoSwapRegistry(registry)\n                .get_coins(pool);\n            ulTokens = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                ulTokens[i] = coins[i];\n            }\n            virtualPrice = ICurveCryptoSwapRegistry(registry)\n                .get_virtual_price_from_lp_token(crvLp);\n            return (pool, ulTokens, virtualPrice);\n        }\n\n        /// 3. Attempt retrieval from Meta Curve registry.\n        registry = addressProvider.get_address(7);\n        pool = ICurveCryptoSwapRegistry(registry).get_pool_from_lp_token(crvLp);\n        if (pool != address(0)) {\n            uint256 n = ICurveCryptoSwapRegistry(registry).get_n_coins(pool);\n            address[8] memory coins = ICurveCryptoSwapRegistry(registry)\n                .get_coins(pool);\n            ulTokens = new address[](n);\n            for (uint256 i = 0; i < n; i++) {\n                ulTokens[i] = coins[i];\n            }\n            virtualPrice = ICurveCryptoSwapRegistry(registry)\n                .get_virtual_price_from_lp_token(crvLp);\n            return (pool, ulTokens, virtualPrice);\n        }\n\n        revert BlueBerryErrors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    /// @dev Internal function to check for reentrancy issues with Curve pools.\n    /// @param _pool The address of the Curve pool to check.\n    /// @param _numTokens The number of tokens in the pool.\n    function _checkReentrant(address _pool, uint256 _numTokens) internal virtual;\n\n    /// @notice Fetches Curve pool details for the provided Curve LP token.\n    /// @param crvLp The Curve LP token address.\n    /// @return pool The Curve pool address.\n    /// @return coins The list of underlying tokens in the pool.\n    /// @return virtualPrice The virtual price of the Curve pool.\n    function getPoolInfo(\n        address crvLp\n    )\n        external\n        returns (address pool, address[] memory coins, uint256 virtualPrice)\n    {\n        return _getPoolInfo(crvLp);\n    }\n\n    /// @notice Fetches the USD value of a given Curve LP token.\n    /// @dev To be implemented in inheriting contracts.\n    /// @param crvLp The Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external virtual returns (uint256);\n}\n"
    },
    "contracts/oracle/CurveStableOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\n\n/// @title Curve Stable Oracle\n/// @author BlueberryProtocol\n/// @notice Oracle contract that provides price feeds for Curve stable LP tokens.\ncontract CurveStableOracle is CurveBaseOracle {\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Overrides the base oracle's reentrancy check based on the number of tokens.\n    /// @param _pool The address of the pool to check.\n    /// @param _numTokens The number of tokens in the pool.\n    function _checkReentrant(address _pool, uint256 _numTokens) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        if (_numTokens == 2) {\n            uint256[2] memory amounts;\n            pool.remove_liquidity(0, amounts);\n        } else if (_numTokens == 3) {\n            uint256[3] memory amounts;\n            pool.remove_liquidity(0, amounts);\n        } else if (_numTokens == 4) {\n            uint256[4] memory amounts;\n            pool.remove_liquidity(0, amounts);\n        }\n    }\n\n    /// @notice Returns the USD value of the specified Curve LP token with 18 decimals of precision.\n    /// @dev Uses the minimum underlying token price for calculation.\n    /// @param crvLp The ERC-20 Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        uint256 minPrice = type(uint256).max;\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            uint256 tokenPrice = base.getPrice(tokens[idx]);\n            if (tokenPrice < minPrice) minPrice = tokenPrice;\n        }\n\n        // Calculate LP token price using the minimum underlying token price\n        return (minPrice * virtualPrice) / 1e18;\n    }\n\n    /// @notice Fallback function to receive Ether.\n    receive() external payable {}\n}\n"
    },
    "contracts/oracle/CurveTricryptoOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\n\n/// @title Curve Volatile Oracle\n/// @author BlueberryProtocol \n/// @notice Oracle contract which privides price feeds of Curve volatile pool LP tokens\ncontract CurveTricryptoOracle is CurveBaseOracle {\n    \n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor initializes the CurveBaseOracle with the provided parameters.\n    /// @param base_ The address of the base oracle.\n    /// @param addressProvider_ The address of the curve address provider.\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Overrides the base oracle's reentrancy check.\n    /// @param _pool The address of the pool to check.\n    /// @param (unnamed) Unused parameter for overriding.\n    function _checkReentrant(address _pool, uint256) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        pool.claim_admin_fees();\n    }\n\n    /// @notice Returns the USD value of the specified Curve LP token with 18 decimals of precision.\n    /// @dev If the length of tokens is not 3, the function will revert.\n    /// @param crvLp The ERC-20 Curve LP token address.\n    /// @return The USD value of the Curve LP token.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        /// Check if the token list length is 3 (tricrypto)\n        if (tokens.length == 3) {\n            /// tokens[2] is WETH\n            uint256 ethPrice = base.getPrice(tokens[2]);\n            return\n                (lpPrice(\n                    virtualPrice,\n                    base.getPrice(tokens[1]),\n                    ethPrice,\n                    base.getPrice(tokens[0])\n                ) * 1e18) / ethPrice;\n        }\n        revert BlueBerryErrors.ORACLE_NOT_SUPPORT_LP(crvLp);\n    }\n\n    /// @dev Calculates the LP price using provided token prices and virtual price.\n    /// @param virtualPrice The virtual price from the pool.\n    /// @param p1 Price of the first token.\n    /// @param p2 Price of the second token (usually ETH).\n    /// @param p3 Price of the third token.\n    /// @return The calculated LP price.\n    function lpPrice(\n        uint256 virtualPrice,\n        uint256 p1,\n        uint256 p2,\n        uint256 p3\n    ) internal pure returns (uint256) {\n        return (3 * virtualPrice * cubicRoot(((p1 * p2) / 1e18) * p3)) / 1e18;\n    }\n\n    /// @dev Calculates the cubic root of the provided value using the Newton-Raphson method.\n    /// @param x The value to find the cubic root for.\n    /// @return The calculated cubic root.\n\n    function cubicRoot(uint256 x) internal pure returns (uint256) {\n        uint256 D = x / 1e18;\n        for (uint256 i; i < 255; ) {\n            uint256 D_prev = D;\n            D = (D * (2e18 + ((((x / D) * 1e18) / D) * 1e18) / D)) / (3e18);\n            uint256 diff = (D > D_prev) ? D - D_prev : D_prev - D;\n            if (diff < 2 || diff * 1e18 < D) return D;\n            unchecked {\n                ++i;\n            }\n        }\n        revert(\"Did Not Converge\");\n    }\n}\n"
    },
    "contracts/oracle/CurveVolatileOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"./CurveBaseOracle.sol\";\nimport \"../libraries/balancer/FixedPoint.sol\";\nimport \"../utils/BlueBerryConst.sol\" as Constants;\n\n/// @author BlueberryProtocol\n/// @title Curve Volatile Oracle\n/// @notice Oracle contract which privides price feeds for Curve volatile pool LP tokens\ncontract CurveVolatileOracle is CurveBaseOracle {\n    using FixedPoint for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    uint16 constant PERCENTAGE_FACTOR = 1e4; /// 100% represented in fixed point format\n    uint256 constant RANGE_WIDTH = 200; // Represents a 2% range width\n\n    /// @dev The lower bound for the contract's token-to-underlying exchange rate.\n    /// @notice Used to protect against LP token / share price manipulation.\n    mapping(address => uint256) public lowerBound;\n\n    /// @dev Event emitted when the bounds for the token-to-underlying exchange rate is changed.\n    event NewLimiterParams(uint256 lowerBound, uint256 upperBound);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructor to set initial values for the Curve Volatile Oracle\n    /// @param base_ Address of the base oracle\n    /// @param addressProvider_ Address of the curve address provider\n    constructor(\n        IBaseOracle base_,\n        ICurveAddressProvider addressProvider_\n    ) CurveBaseOracle(base_, addressProvider_) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Updates the bounds for the exchange rate value\n    /// @param _crvLp The curve lp token\n    /// @param _lowerBound The new lower bound (the upper bound is computed dynamically)\n    ///                    from the lower bound\n    function setLimiter(\n        address _crvLp,\n        uint256 _lowerBound\n    ) external onlyOwner {\n        _setLimiter(_crvLp, _lowerBound);\n    }\n\n    /// @dev Internal implementation for setting the limiter\n    function _setLimiter(address _crvLp, uint256 _lowerBound) internal {\n        if (\n            _lowerBound == 0 ||\n            !_checkCurrentValueInBounds(\n                _crvLp,\n                _lowerBound,\n                _upperBound(_lowerBound)\n            )\n        ) revert BlueBerryErrors.INCORRECT_LIMITS();\n\n        lowerBound[_crvLp] = _lowerBound;\n        emit NewLimiterParams(_lowerBound, _upperBound(_lowerBound));\n    }\n\n    /// Checks if the current value is within the specified bounds\n    function _checkCurrentValueInBounds(\n        address _crvLp,\n        uint256 _lowerBound,\n        uint256 __upperBound\n    ) internal returns (bool) {\n        (, , uint256 virtualPrice) = _getPoolInfo(_crvLp);\n        if (virtualPrice < _lowerBound || virtualPrice > __upperBound) {\n            return false;\n        }\n        return true;\n    }\n\n    /// Override function to check for reentrancy\n    function _checkReentrant(address _pool, uint256) internal override {\n        ICurvePool pool = ICurvePool(_pool);\n        pool.claim_admin_fees();\n    }\n\n    /// @notice Return the USD value of given Curve Lp, with 18 decimals of precision.\n    /// @param crvLp The ERC-20 Curve LP token to check the value.\n    function getPrice(address crvLp) external override returns (uint256) {\n        (address pool, address[] memory tokens, uint256 virtualPrice) = _getPoolInfo(crvLp);\n        _checkReentrant(pool, tokens.length);\n\n        uint256 nTokens = tokens.length;\n\n        uint256 px0 = base.getPrice(tokens[0]);\n        uint256 px1 = base.getPrice(tokens[1]);\n\n        uint256 product = (px0 * Constants.PRICE_PRECISION) / Constants.CHAINLINK_PRICE_FEED_PRECISION;\n        product = product.mulDown((px1 * Constants.PRICE_PRECISION) / Constants.CHAINLINK_PRICE_FEED_PRECISION);\n\n        if (nTokens == 3) {\n            uint256 px2 = base.getPrice(tokens[2]);\n            product = product.mulDown(\n                (uint256(px2) * Constants.PRICE_PRECISION) / Constants.CHAINLINK_PRICE_FEED_PRECISION\n            );\n        }\n\n        /// Checks that virtual_price is within bounds\n        virtualPrice = _checkAndUpperBoundValue(crvLp, virtualPrice);\n\n        uint256 answer = product.powDown(Constants.PRICE_PRECISION / nTokens).mulDown(\n            nTokens * virtualPrice\n        );\n\n        return (answer * Constants.CHAINLINK_PRICE_FEED_PRECISION) / Constants.PRICE_PRECISION;\n    }\n\n    /// @dev Checks that value is within the range [lowerBound; upperBound],\n    /// @notice If the value is below the lowerBound, it reverts. Otherwise, it returns min(value, upperBound).\n    /// @param crvLp The curve LP token address\n    /// @param value Value to be checked and bounded\n    function _checkAndUpperBoundValue(\n        address crvLp,\n        uint256 value\n    ) internal view returns (uint256) {\n        uint256 lb = lowerBound[crvLp];\n        if (value < lb) revert BlueBerryErrors.VALUE_OUT_OF_RANGE();\n\n        uint256 uBound = _upperBound(lb);\n\n        return (value > uBound) ? uBound : value;\n    }\n\n    /// Computes the upper bound based on the provided lower bound\n    function _upperBound(uint256 lb) internal pure returns (uint256) {\n        return (lb * (PERCENTAGE_FACTOR + RANGE_WIDTH)) / PERCENTAGE_FACTOR;\n    }\n}\n"
    },
    "contracts/oracle/IchiVaultOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./UsingBaseOracle.sol\";\nimport \"./BaseOracleExt.sol\";\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../libraries/UniV3/UniV3WrappedLibContainer.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\n\n/// @author BlueberryProtocol\n/// @title Ichi Vault Oracle\n/// @notice Oracle contract provides price feeds of Ichi Vault tokens\n/// @dev The logic of this oracle is using legacy & traditional mathematics of Uniswap V2 Lp Oracle.\n///      Base token prices are fetched from Chainlink or Band Protocol.\n///      To prevent flashloan price manipulations, it compares spot & twap prices from Uni V3 Pool.\ncontract IchiVaultOracle is\n    UsingBaseOracle,\n    IBaseOracle,\n    Ownable,\n    BaseOracleExt\n{\n    /*//////////////////////////////////////////////////////////////////////////\n                                      PUBLIC STORAGE \n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Mapping to keep track of the maximum price deviation allowed for each token\n    mapping(address => uint256) public maxPriceDeviations;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs a new instance of the contract.\n    /// @param _base The base oracle instance.\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Event emitted when the maximum price deviation for a token is set or updated.\n    /// @param token The address of the token.\n    /// @param maxPriceDeviation The new maximum price deviation (in 1e18 format).\n    event SetPriceDeviation(address indexed token, uint256 maxPriceDeviation);\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Set price deviations for given token\n    /// @dev Input token is the underlying token of ICHI Vaults which is token0 or token1 of Uni V3 Pool\n    /// @param token Token to price deviation\n    /// @param maxPriceDeviation Max price deviation (in 1e18) of price feeds\n    function setPriceDeviation(\n        address token,\n        uint256 maxPriceDeviation\n    ) external onlyOwner {\n        /// Validate inputs\n        if (token == address(0)) revert Errors.ZERO_ADDRESS();\n        if (maxPriceDeviation > Constants.MAX_PRICE_DEVIATION)\n            revert Errors.OUT_OF_DEVIATION_CAP(maxPriceDeviation);\n\n        maxPriceDeviations[token] = maxPriceDeviation;\n        emit SetPriceDeviation(token, maxPriceDeviation);\n    }\n\n    /// @notice Get token0 spot price quoted in token1\n    /// @dev Returns token0 price of 1e18 amount\n    /// @param vault ICHI Vault address\n    /// @return price spot price of token0 quoted in token1\n    function spotPrice0InToken1(\n        IICHIVault vault\n    ) public view returns (uint256) {\n        return\n            UniV3WrappedLibContainer.getQuoteAtTick(\n                vault.currentTick(), // current tick\n                uint128(Constants.PRICE_PRECISION), // amountIn\n                vault.token0(), // tokenIn\n                vault.token1() // tokenOut\n            );\n    }\n\n    /// @notice Get token0 twap price quoted in token1\n    /// @dev Returns token0 price of 1e18 amount\n    /// @param vault ICHI Vault address\n    /// @return price spot price of token0 quoted in token1\n    function twapPrice0InToken1(\n        IICHIVault vault\n    ) public view returns (uint256) {\n        uint32 twapPeriod = vault.twapPeriod();\n        if (twapPeriod > Constants.MAX_TIME_GAP)\n            revert Errors.TOO_LONG_DELAY(twapPeriod);\n        if (twapPeriod < Constants.MIN_TIME_GAP)\n            revert Errors.TOO_LOW_MEAN(twapPeriod);\n        (int24 twapTick, ) = UniV3WrappedLibContainer.consult(\n            vault.pool(),\n            twapPeriod\n        );\n        return\n            UniV3WrappedLibContainer.getQuoteAtTick(\n                twapTick,\n                uint128(Constants.PRICE_PRECISION), /// amountIn\n                vault.token0(), /// tokenIn\n                vault.token1() /// tokenOut\n            );\n    }\n\n    /// @notice Return vault token price in USD, with 18 decimals of precision.\n    /// @param token The vault token to get the price of.\n    /// @return price USD price of token in 18 decimal\n    function getPrice(address token) external override returns (uint256) {\n        IICHIVault vault = IICHIVault(token);\n        uint256 totalSupply = vault.totalSupply();\n        if (totalSupply == 0) return 0;\n\n        address token0 = vault.token0();\n        address token1 = vault.token1();\n\n        /// Check price manipulations on Uni V3 pool by flashloan attack\n        uint256 spotPrice = spotPrice0InToken1(vault);\n        uint256 twapPrice = twapPrice0InToken1(vault);\n        uint256 maxPriceDeviation = maxPriceDeviations[token0];\n        if (!_isValidPrices(spotPrice, twapPrice, maxPriceDeviation))\n            revert Errors.EXCEED_DEVIATION();\n\n        /// Total reserve / total supply\n        (uint256 r0, uint256 r1) = vault.getTotalAmounts();\n        uint256 px0 = base.getPrice(address(token0));\n        uint256 px1 = base.getPrice(address(token1));\n        uint256 t0Decimal = IERC20Metadata(token0).decimals();\n        uint256 t1Decimal = IERC20Metadata(token1).decimals();\n\n        uint256 totalReserve = (r0 * px0) /\n            10 ** t0Decimal +\n            (r1 * px1) /\n            10 ** t1Decimal;\n\n        return (totalReserve * 10 ** vault.decimals()) / totalSupply;\n    }\n}\n"
    },
    "contracts/oracle/StableBPTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/FixedPointMathLib.sol\";\n\n/// @title Stable Balancer LP Oracle\n/// @author BlueberryProtocol\n/// @notice Oracle contract which privides price feeds of Stable Balancer LP tokens\ncontract StableBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPointMathLib for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD value of given Balancer Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        // Reentrancy guard to prevent flashloan attack\n        checkReentrancy(vault);\n\n        (address[] memory tokens, , ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256 length = tokens.length;\n        uint256 minPrice = base.getPrice(tokens[0]);\n        for(uint256 i = 1; i != length; ++i) {\n            uint256 price = base.getPrice(tokens[i]);\n            minPrice = (price < minPrice) ? price : minPrice;\n        }\n        return minPrice.mulWadDown(pool.getRate());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}\n"
    },
    "contracts/oracle/UniswapV2Oracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../libraries/BBMath.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\n\n/// @author BlueberryProtocol\n/// @title Uniswap V2 Oracle\n/// @notice Oracle contract which privides price feeds of Uni V2 Lp tokens\n/// @dev Implented Fair Lp Pricing\n///      Ref: https://blog.alphaventuredao.io/fair-lp-token-pricing/\ncontract UniswapV2Oracle is UsingBaseOracle, IBaseOracle {\n    \n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD based price of the given input, multiplied by 10**18.\n    /// @dev Fair LP Price Formula => Price = 2 * (sqrt(r0 x r1) x sqrt(p0 x p1)) / total supply\n    /// @param pair The Uniswap pair to check the value.\n    function getPrice(address pair) external override returns (uint256) {\n        IUniswapV2Pair pool = IUniswapV2Pair(pair);\n        uint256 totalSupply = pool.totalSupply();\n        if (totalSupply == 0) return 0;\n\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n\n        (uint256 r0, uint256 r1, ) = pool.getReserves();\n        uint256 px0 = base.getPrice(token0);\n        uint256 px1 = base.getPrice(token1);\n        uint256 t0Decimal = IERC20Metadata(token0).decimals();\n        uint256 t1Decimal = IERC20Metadata(token1).decimals();\n        uint256 sqrtK = BBMath.sqrt(\n            r0 * r1 * 10 ** (36 - t0Decimal - t1Decimal)\n        );\n\n        return (2 * sqrtK * BBMath.sqrt(px0 * px1)) / totalSupply;\n    }\n}\n"
    },
    "contracts/oracle/UniswapV3AdapterOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport  \"./BaseAdapter.sol\";\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../libraries/UniV3/UniV3WrappedLibContainer.sol\";\n\n/// @author BlueberryProtocol\n/// @title Uniswap V3 Adapter Oracle\n/// @notice Oracle contract which provides price feeds of tokens from Uni V3 pool paired with stablecoins\ncontract UniswapV3AdapterOracle is IBaseOracle, UsingBaseOracle, BaseAdapter {\n    using SafeCast for uint256;\n\n    event SetPoolStable(address token, address pool);\n\n    /// @dev Mapping from token address to Uni V3 pool of token/(USDT|USDC|DAI) pair\n    mapping(address => address) public stablePools;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Set stablecoin pools for multiple tokens\n    /// @param tokens list of tokens to set stablecoin pool references\n    /// @param pools list of reference pool addresses\n    function setStablePools(\n        address[] calldata tokens,\n        address[] calldata pools\n    ) external onlyOwner {\n        if (tokens.length != pools.length) revert Errors.INPUT_ARRAY_MISMATCH();\n        for (uint256 idx = 0; idx < tokens.length; idx++) {\n            if (tokens[idx] == address(0) || pools[idx] == address(0))\n                revert Errors.ZERO_ADDRESS();\n            if (\n                tokens[idx] != IUniswapV3Pool(pools[idx]).token0() &&\n                tokens[idx] != IUniswapV3Pool(pools[idx]).token1()\n            ) revert Errors.NO_STABLEPOOL(pools[idx]);\n            stablePools[tokens[idx]] = pools[idx];\n            emit SetPoolStable(tokens[idx], pools[idx]);\n        }\n    }\n\n    /// @notice Return USD price of given token, multiplied by 10**18.\n    /// @param token The vault token to get the price of.\n    /// @return price USD price of token in 18 decimals.\n    function getPrice(address token) external override returns (uint256) {\n        /// Maximum cap of timeGap is 2 days(172,800), safe to convert\n        uint32 secondsAgo = timeGaps[token].toUint32();\n        if (secondsAgo == 0) revert Errors.NO_MEAN(token);\n\n        address stablePool = stablePools[token];\n        if (stablePool == address(0)) revert Errors.NO_STABLEPOOL(token);\n\n        address poolToken0 = IUniswapV3Pool(stablePool).token0();\n        address poolToken1 = IUniswapV3Pool(stablePool).token1();\n        address stablecoin = poolToken0 == token ? poolToken1 : poolToken0; // get stable token address\n\n        uint8 stableDecimals = IERC20Metadata(stablecoin).decimals();\n        uint8 tokenDecimals = IERC20Metadata(token).decimals();\n\n        (int24 arithmeticMeanTick, ) = UniV3WrappedLibContainer.consult(\n            stablePool,\n            secondsAgo\n        );\n        uint256 quoteTokenAmountForStable = UniV3WrappedLibContainer\n            .getQuoteAtTick(\n                arithmeticMeanTick,\n                uint256(10 ** tokenDecimals).toUint128(),\n                token,\n                stablecoin\n            );\n\n        return\n            (quoteTokenAmountForStable * base.getPrice(stablecoin)) /\n            10 ** stableDecimals;\n    }\n}\n"
    },
    "contracts/oracle/UsingBaseOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"../interfaces/IBaseOracle.sol\";\n\n/// @title UsingBaseOracle\n/// @dev This contract serves as a base for other contracts that need access \n/// to an external oracle service. It provides an immutable reference to a \n/// specified oracle source.\ncontract UsingBaseOracle {\n    IBaseOracle public immutable base; // Base oracle source\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs a new instance of the contract.\n    /// @dev Initializes the contract with a given oracle source.\n    /// @param _base The address of the oracle to be used as a data source.\n    constructor(IBaseOracle _base) {\n        base = _base;\n    }\n}\n"
    },
    "contracts/oracle/WeightedBPTOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nimport \"./UsingBaseOracle.sol\";\nimport \"../interfaces/IBaseOracle.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../interfaces/balancer/IBalancerVault.sol\";\nimport \"../libraries/balancer/FixedPoint.sol\";\n\n/// @title WeightedBPTOracle\n/// @dev Provides price feeds for Weighted Balancer LP tokens.\n/// @author BlueberryProtocol\n///\n/// This contract fetches and computes the value of a Balancer LP token in terms of USD.\n/// It uses the base oracle to fetch underlying token values and then computes the\n/// value of the LP token using Balancer's formula.\ncontract WeightedBPTOracle is UsingBaseOracle, IBaseOracle {\n    using FixedPoint for uint256;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @notice Constructs the WeightedBPTOracle contract.\n    /// @dev Initializes the contract with the base oracle address.\n    /// @param _base Address of the base oracle contract.\n    constructor(IBaseOracle _base) UsingBaseOracle(_base) {}\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Return the USD value of given Balancer Lp, with 18 decimals of precision.\n    /// @param token The ERC-20 token to check the value.\n    function getPrice(address token) external override returns (uint256) {\n        IBalancerPool pool = IBalancerPool(token);\n        IBalancerVault vault = IBalancerVault(pool.getVault());\n\n        // Reentrancy guard to prevent flashloan attack\n        checkReentrancy(vault);\n\n        (address[] memory tokens, uint256[] memory balances, ) = vault\n            .getPoolTokens(pool.getPoolId());\n\n        uint256[] memory weights = pool.getNormalizedWeights();\n\n        uint256 length = weights.length;\n        uint256 temp = 1e18;\n        uint256 invariant = 1e18;\n        for(uint256 i; i < length; i++) {\n            temp = temp.mulDown(\n                (base.getPrice(tokens[i]).divDown(weights[i]))\n                .powDown(weights[i])\n            );\n            invariant = invariant.mulDown(\n                (balances[i] * 10 ** (18 - IERC20Metadata(tokens[i]).decimals()))\n                .powDown(weights[i])\n            );\n        }\n        return invariant\n            .mulDown(temp)\n            .divDown(IBalancerPool(token).totalSupply());\n    }\n\n    /// @dev Checks for reentrancy by calling a no-op function on the Balancer Vault.\n    ///      This is a preventative measure against potential reentrancy attacks.\n    /// @param vault The Balancer Vault contract instance.\n    function checkReentrancy(IBalancerVault vault) internal {\n        vault.manageUserBalance(new IBalancerVault.UserBalanceOp[](0));\n    }\n}\n"
    },
    "contracts/ProtocolConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"./utils/BlueBerryConst.sol\" as Constants;\nimport \"./utils/BlueBerryErrors.sol\" as Errors;\nimport \"./interfaces/IProtocolConfig.sol\";\n\n\n/// @title ProtocolConfig\n/// @author BlueberryProtocol\n/// @notice This contract acts as the central point of all configurable states in the Blueberry Protocol.\n///         It holds references to fee management, various fee types and values, \n///         treasury settings, and other system configurations.\n\ncontract ProtocolConfig is OwnableUpgradeable, IProtocolConfig {\n\n    /// Fee manager of the protocol to handle different types of fees.\n    IFeeManager public feeManager;\n\n    /// Fee structures related to leveraging activities.\n    uint256 public depositFee;             // Fee applied on deposits.\n    uint256 public withdrawFee;            // Fee applied on withdrawals.\n    uint256 public rewardFee;              // Fee applied on reward claims.\n\n    /// Fee structures related to vault operations.\n    uint256 public withdrawVaultFee;                 /// Fee applied on vault withdrawals.\n    uint256 public withdrawVaultFeeWindow;           /// Time window for which the vault withdrawal fee applies.\n    uint256 public withdrawVaultFeeWindowStartTime;  /// Start timestamp of the withdrawal fee window.\n\n    /// Fee distribution rates.\n    uint256 public treasuryFeeRate;        /// Portion of the fee sent to the protocol's treasury.\n    uint256 public blbStablePoolFeeRate;   /// Portion of the fee for $BLB stablecoin pool.\n    uint256 public blbIchiVaultFeeRate;    /// Portion of the fee for $BLB-ICHI vault.\n\n    /// Addresses associated with the protocol.\n    address public treasury;               /// Address of the protocol's treasury.\n    address public blbUsdcIchiVault;       /// Address of the $BLB-USDC ICHI vault.\n    address public blbStabilityPool;       /// Address of the $BLB stability pool against stablecoins.\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n        \n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Initializes the contract with the given treasury address.\n    /// @param treasury_ Address of the treasury.\n    function initialize(address treasury_) external initializer {\n        __Ownable_init();\n        if (treasury_ == address(0)) revert Errors.ZERO_ADDRESS();\n        treasury = treasury_;\n\n        /// Set default values for fees and fee rates.\n        depositFee = 50; // Represents 0.5% (base 10000)\n        withdrawFee = 50; // Represents 0.5% (base 10000)\n        rewardFee = 1000; // Represents 10% (base 10000)\n\n        treasuryFeeRate = 3000; // 30% of deposit/withdraw fee => 0.15%\n        blbStablePoolFeeRate = 3500; //  35% of deposit/withdraw fee => 0.175%\n        blbIchiVaultFeeRate = 3500; //  35% of deposit/withdraw fee => 0.175%\n\n        withdrawVaultFee = 100; // Represents 1% (base 10000)\n        withdrawVaultFeeWindow = 60 days; // Liquidity boot strapping event per vault\n    }\n\n    /// @dev Owner priviledged function to start the withdraw vault fee window\n    /// @notice This function can only be called once per vault\n    function startVaultWithdrawFee() external onlyOwner {\n        if (withdrawVaultFeeWindowStartTime > 0)\n            revert Errors.FEE_WINDOW_ALREADY_STARTED();\n        withdrawVaultFeeWindowStartTime = block.timestamp;\n    }\n\n    /// @dev Owner priviledged function to set deposit fee\n    /// @param depositFee_ Fee rate applied to the deposit\n    function setDepositFee(uint256 depositFee_) external onlyOwner {\n        /// Capped at 20%\n        if (depositFee_ > Constants.MAX_FEE_RATE)\n            revert Errors.RATIO_TOO_HIGH(depositFee_);\n        depositFee = depositFee_;\n    }\n\n    /// @dev Owner priviledged function to set withdraw fee\n    /// @param withdrawFee_ Fee rate applied to the withdraw\n    function setWithdrawFee(uint256 withdrawFee_) external onlyOwner {\n        /// Capped at 20%\n        if (withdrawFee_ > Constants.MAX_FEE_RATE)\n            revert Errors.RATIO_TOO_HIGH(withdrawFee_);\n        withdrawFee = withdrawFee_;\n    }\n\n    /// @dev Owner priviledged function to set withdraw vault fee window duration\n    /// @param withdrawVaultFeeWindow_ Duration of the withdraw vault fee window\n    function setWithdrawVaultFeeWindow(\n        uint256 withdrawVaultFeeWindow_\n    ) external onlyOwner {\n        /// Capped at 60 days\n        if (withdrawVaultFeeWindow_ > Constants.MAX_WITHDRAW_VAULT_FEE_WINDOW)\n            revert Errors.FEE_WINDOW_TOO_LONG(withdrawVaultFeeWindow_);\n        withdrawVaultFeeWindow = withdrawVaultFeeWindow_;\n    }\n\n    /// @dev Owner priviledged function to set reward fee\n    /// @param rewardFee_ Fee rate applied to the rewards\n    function setRewardFee(uint256 rewardFee_) external onlyOwner {\n        /// Capped at 20%\n        if (rewardFee_ > Constants.MAX_FEE_RATE)\n            revert Errors.RATIO_TOO_HIGH(rewardFee_);\n        rewardFee = rewardFee_;\n    }\n\n    /// @dev Owner priviledged function to set the distribution rates for the various fees\n    /// @param treasuryFeeRate_ Fee rate sent to treasury\n    /// @param blbStablePoolFeeRate_ Fee rate applied to the $BLB liquidity pool\n    /// @param blbIchiVaultFeeRate_ Fee rate applied to the $BLB-ICHI vault\n    function setFeeDistribution(\n        uint256 treasuryFeeRate_,\n        uint256 blbStablePoolFeeRate_,\n        uint256 blbIchiVaultFeeRate_\n    ) external onlyOwner {\n        if (\n            (treasuryFeeRate_ + blbStablePoolFeeRate_ + blbIchiVaultFeeRate_) !=\n            Constants.DENOMINATOR\n        ) revert Errors.INVALID_FEE_DISTRIBUTION();\n        treasuryFeeRate = treasuryFeeRate_;\n        blbStablePoolFeeRate = blbStablePoolFeeRate_;\n        blbIchiVaultFeeRate = blbIchiVaultFeeRate_;\n    }\n\n    /// @dev Owner priviledged function to set treasury address\n    /// @param treasury_ Address of the new treasury\n    function setTreasuryWallet(address treasury_) external onlyOwner {\n        if (treasury_ == address(0)) revert Errors.ZERO_ADDRESS();\n        treasury = treasury_;\n    }\n\n    /// @dev Owner priviledged function to set fee manager address\n    /// @param feeManager_ Address of the new fee manager\n    function setFeeManager(address feeManager_) external onlyOwner {\n        if (feeManager_ == address(0)) revert Errors.ZERO_ADDRESS();\n        feeManager = IFeeManager(feeManager_);\n    }\n\n    /// @dev Owner priviledged function to set $BLB-ICHI vault address\n    /// @param vault_ Address of the new vault\n    function setBlbUsdcIchiVault(address vault_) external onlyOwner {\n        if (vault_ == address(0)) revert Errors.ZERO_ADDRESS();\n        blbUsdcIchiVault = vault_;\n    }\n\n    /// @dev Owner priviledged function to set $BLB stability pool address\n    /// @param pool_ Address of the new stability pool\n    function setBlbStabilityPool(address pool_) external onlyOwner {\n        if (pool_ == address(0)) revert Errors.ZERO_ADDRESS();\n        blbStabilityPool = pool_;\n    }\n}\n"
    },
    "contracts/spell/AuraSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/balancer/IBalancerPool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title AuraSpell\n/// @author BlueberryProtocol\n/// @notice AuraSpell is the factory contract that\n///         defines how Blueberry Protocol interacts with Aura pools\ncontract AuraSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Wrapped Aura Pools\n    IWAuraPools public wAuraPools;\n    /// @dev Address of AURA token\n    address public AURA;\n    /// @dev Address of Stash AURA token\n    address public STASH_AURA;\n\n    /// @dev paraswap AugustusSwapper Address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy Address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with required parameters.\n    /// @param bank_ Reference to the Bank contract.\n    /// @param werc20_ Reference to the WERC20 contract.\n    /// @param weth_ Address of the wrapped Ether token.\n    /// @param wAuraPools_ Address of the wrapped Aura Pools contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wAuraPools_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wAuraPools_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wAuraPools = IWAuraPools(wAuraPools_);\n        AURA = address(wAuraPools.AURA());\n        STASH_AURA = wAuraPools.STASH_AURA();\n        IWAuraPools(wAuraPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Allows the owner to add a new strategy.\n    /// @param bpt Address of the Balancer Pool Token.\n    /// @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address bpt,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(bpt, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Balancer pool and stakes the resultant tokens in Aura.\n    /// @param param Configuration for opening a position.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minimumBPT\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Extract strategy details for the given strategy ID.\n        Strategy memory strategy = strategies[param.strategyId];\n        /// Fetch pool information based on provided farming pool ID.\n        (address lpToken, , , , , ) = wAuraPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow funds based on specified amount\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Add liquidity to the Balancer pool and receive BPT in return.\n        {\n            uint256 _minimumBPT = minimumBPT;\n            IBalancerVault vault = wAuraPools.getVault(lpToken);\n\n            (address[] memory tokens, uint256[] memory balances, ) = wAuraPools\n                .getPoolTokens(lpToken);\n            (\n                uint256[] memory maxAmountsIn,\n                uint256[] memory amountsIn,\n                uint256 poolAmountOut\n            ) = _getJoinPoolParamsAndApprove(\n                    address(vault),\n                    tokens,\n                    balances,\n                    lpToken\n                );\n\n            if (poolAmountOut != 0) {\n                vault.joinPool(\n                    wAuraPools.getBPTPoolId(lpToken),\n                    address(this),\n                    address(this),\n                    IBalancerVault.JoinPoolRequest({\n                        assets: tokens,\n                        maxAmountsIn: maxAmountsIn,\n                        userData: abi.encode(1, amountsIn, _minimumBPT),\n                        fromInternalBalance: false\n                    })\n                );\n            }\n        }\n        /// 4. Ensure that the resulting LTV does not exceed maximum allowed value.\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Ensure position size is within permissible limits.\n        _validatePosSize(param.strategyId);\n\n        /// 6. Withdraw existing collaterals and burn the associated tokens.\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wAuraPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                pos.collateralSize\n            );\n            /// Distribute the multiple rewards to users.\n            uint256 rewardTokensLength = rewardTokens.length;\n            for (uint256 i; i != rewardTokensLength; ) {\n                _doRefundRewards(\n                    rewardTokens[i] == STASH_AURA ? AURA : rewardTokens[i]\n                );\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        /// 7. Deposit the tokens in the Aura pool and place the wrapped collateral tokens in the Blueberry Bank.\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wAuraPools), lpAmount);\n        uint256 id = wAuraPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wAuraPools), id, lpAmount);\n    }\n\n    /// @notice Closes a position from Balancer pool and exits the Aura farming.\n    /// @param param Parameters for closing the position\n    /// @param expectedRewards Expected reward amounts for each reward token\n    /// @param swapDatas Data required for swapping reward tokens to the debt token\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// Information about the position from Blueberry Bank\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address[] memory rewardTokens;\n        /// Ensure the position's collateral token matches the expected one\n        {\n            address lpToken = strategies[param.strategyId].vault;\n            if (pos.collToken != address(wAuraPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            if (wAuraPools.getUnderlyingToken(pos.collId) != lpToken)\n                revert Errors.INCORRECT_UNDERLYING(lpToken);\n\n            /// 1. Burn the wrapped tokens, retrieve the BPT tokens, and claim the AURA rewards\n            bank.takeCollateral(param.amountPosRemove);\n            (rewardTokens, ) = wAuraPools.burn(\n                pos.collId,\n                param.amountPosRemove\n            );\n\n            {\n                /// 2. Determine the exact amount of position to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(lpToken).balanceOf(\n                        address(this)\n                    );\n                }\n\n                /// 3. Parameters for removing liquidity\n                (\n                    uint256[] memory minAmountsOut,\n                    address[] memory tokens,\n                    uint256 borrowTokenIndex\n                ) = _getExitPoolParams(param.borrowToken, lpToken);\n\n                wAuraPools.getVault(lpToken).exitPool(\n                    IBalancerPool(lpToken).getPoolId(),\n                    address(this),\n                    address(this),\n                    IBalancerVault.ExitPoolRequest(\n                        tokens,\n                        minAmountsOut,\n                        abi.encode(0, amountPosRemove, borrowTokenIndex),\n                        false\n                    )\n                );\n            }\n        }\n\n        /// 4. Swap each reward token for the debt token\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            address sellToken = rewardTokens[i];\n            if (sellToken == STASH_AURA) sellToken = AURA;\n\n            _doCutRewardsFee(sellToken);\n            if (\n                expectedRewards[i] != 0 &&\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedRewards[i],\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n\n            /// Refund rest (dust) amount to owner\n            _doRefund(sellToken);\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Withdraw collateral from the bank and repay the borrowed amount\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        /// Ensure that the Loan to Value (LTV) ratio remains within accepted boundaries\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund any remaining tokens to the owner\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @dev Calculate the parameters required for joining a Balancer pool.\n    /// @param vault Address of the Balancer vault\n    /// @param tokens List of tokens in the Balancer pool\n    /// @param balances Balances of tokens in the Balancer pool\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return maxAmountsIn Maximum amounts to deposit for each token\n    /// @return amountsIn Amounts of each token to deposit\n    /// @return poolAmountOut Amount of LP tokens to be received\n    function _getJoinPoolParamsAndApprove(\n        address vault,\n        address[] memory tokens,\n        uint256[] memory balances,\n        address lpToken\n    ) internal returns (uint256[] memory, uint256[] memory, uint256) {\n        uint256 i;\n        uint256 j;\n        uint256 length = tokens.length;\n        uint256[] memory maxAmountsIn = new uint256[](length);\n        uint256[] memory amountsIn = new uint256[](length);\n        bool isLPIncluded;\n\n        for (i; i != length; ) {\n            if (tokens[i] != lpToken) {\n                amountsIn[j] = IERC20(tokens[i]).balanceOf(address(this));\n                if (amountsIn[j] > 0) {\n                    _ensureApprove(tokens[i], vault, amountsIn[j]);\n                }\n                ++j;\n            } else isLPIncluded = true;\n\n            maxAmountsIn[i] = IERC20(tokens[i]).balanceOf(address(this));\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        if (isLPIncluded) {\n            assembly {\n                mstore(amountsIn, sub(mload(amountsIn), 1))\n            }\n        }\n\n        uint256 totalLPSupply = IBalancerPool(lpToken).getActualSupply();\n        /// compute in reverse order of how Balancer's `joinPool` computes tokenAmountIn\n        uint256 poolAmountOut;\n        for (i = 0; i != length; ) {\n            if ((maxAmountsIn[i] * totalLPSupply) / balances[i] != 0) {\n                poolAmountOut = type(uint256).max;\n                break;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (maxAmountsIn, amountsIn, poolAmountOut);\n    }\n\n    /// @dev Calculate the parameters required for exiting a Balancer pool.\n    /// @param borrowToken The token to be borrowed\n    /// @param lpToken The LP token for the Balancer pool\n    /// @return minAmountsOut Minimum amounts to receive for each token upon exiting\n    /// @return tokens List of tokens in the Balancer pool\n    /// @return exitTokenIndex Index of the borrowToken in the tokens list\n    function _getExitPoolParams(\n        address borrowToken,\n        address lpToken\n    ) internal view returns (uint256[] memory, address[] memory, uint256) {\n        (address[] memory tokens, , ) = wAuraPools.getPoolTokens(lpToken);\n\n        uint256 length = tokens.length;\n        uint256[] memory minAmountsOut = new uint256[](length);\n        uint256 exitTokenIndex;\n\n        for (uint256 i; i != length; ) {\n            if (tokens[i] == borrowToken) break;\n\n            if (tokens[i] != lpToken) ++exitTokenIndex;\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (minAmountsOut, tokens, exitTokenIndex);\n    }\n}\n"
    },
    "contracts/spell/BasicSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../utils/BlueBerryConst.sol\" as Constants;\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../utils/ERC1155NaiveReceiver.sol\";\nimport \"../interfaces/IBank.sol\";\nimport \"../interfaces/IWERC20.sol\";\n\n/// @title BasicSpell\n/// @author BlueberryProtocol\n/// @notice BasicSpell is the abstract contract that other spells utilize\n/// @dev It extends functionalities from ERC1155NaiveReceiver, OwnableUpgradeable and EnsureApprove\nabstract contract BasicSpell is\n    ERC1155NaiveReceiver,\n    OwnableUpgradeable,\n    EnsureApprove\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   STRUCTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Defines strategies for Blueberry Protocol.\n    /// @param vault Address of the vault where assets are held.\n    /// @param minPositionSize Minimum size of the position in USD.\n    /// @param maxPositionSize Maximum size of the position in USD.\n    struct Strategy {\n        address vault;\n        uint256 minPositionSize;\n        uint256 maxPositionSize;\n    }\n\n    /// @dev Defines parameters required for opening a new position.\n    /// @param strategyId Identifier for the strategy.\n    /// @param collToken Address of the collateral token (e.g., USDC).\n    /// @param collAmount Amount of user's collateral to deposit.\n    /// @param borrowToken Address of the token to borrow.\n    /// @param borrowAmount Amount to borrow from the bank.\n    /// @param farmingPoolId Identifier for the farming pool.\n    struct OpenPosParam {\n        uint256 strategyId;\n        address collToken;\n        uint256 collAmount;\n        address borrowToken;\n        uint256 borrowAmount;\n        uint256 farmingPoolId;\n    }\n\n    /// @dev Defines parameters required for closing a position.\n    /// @param strategyId Identifier for the strategy to close.\n    /// @param collToken Address of the isolated collateral token.\n    /// @param borrowToken Address of the token representing the debt.\n    /// @param amountRepay Amount of debt to repay.\n    /// @param amountPosRemove Amount of position to withdraw.\n    /// @param amountShareWithdraw Amount of isolated collateral tokens to withdraw.\n    /// @param amountOutMin Minimum amount to receive after the operation (used to handle slippage).\n    struct ClosePosParam {\n        uint256 strategyId;\n        address collToken;\n        address borrowToken;\n        uint256 amountRepay;\n        uint256 amountPosRemove;\n        uint256 amountShareWithdraw;\n        uint256 amountOutMin;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// Reference to the bank contract interface.\n    IBank public bank;\n    /// Reference to the WERC20 contract interface.\n    IWERC20 public werc20;\n    /// Address of the Wrapped Ether contract.\n    address public WETH;\n\n    /// @dev strategyId => vault\n    Strategy[] public strategies;\n    /// @dev Mapping from strategy ID to collateral token and its maximum Loan-To-Value ratio. \n    /// Note: LTV is in base 1e4 to provide precision.\n    mapping(uint256 => mapping(address => uint256)) public maxLTV;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice This event is emitted when a new strategy is added.\n    /// @param strategyId Unique identifier for the strategy.\n    /// @param vault Address of the vault where assets are held.\n    /// @param minPosSize Minimum size of the position in USD.\n    /// @param maxPosSize Maximum size of the position in USD.\n    event StrategyAdded(\n        uint256 strategyId,\n        address vault,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    );\n\n    /// @notice This event is emitted when a strategy's min/max position size is updated.\n    /// @param strategyId Unique identifier for the strategy.\n    /// @param minPosSize Minimum size of the position in USD.\n    /// @param maxPosSize Maximum size of the position in USD.\n    event StrategyPosSizeUpdated(\n        uint256 strategyId,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    );\n\n    /// @notice This event is emitted when a strategy's collateral max LTV is updated.\n    /// @param strategyId Unique identifier for the strategy.\n    /// @param collaterals Array of collateral token addresses.\n    /// @param maxLTVs Array of maximum LTVs corresponding to the collaterals. (base 1e4)\n    event CollateralsMaxLTVSet(\n        uint256 strategyId,\n        address[] collaterals,\n        uint256[] maxLTVs\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      MODIFIERS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Modifier to ensure the provided strategyId exists within the strategies array.\n    /// @param strategyId The ID of the strategy to validate.\n    modifier existingStrategy(uint256 strategyId) {\n        if (strategyId >= strategies.length)\n            revert Errors.STRATEGY_NOT_EXIST(address(this), strategyId);\n\n        _;\n    }\n\n    /// @dev Modifier to ensure the provided collateral address exists within the given strategy.\n    /// @param strategyId The ID of the strategy to validate.\n    /// @param col Address of the collateral token.\n    modifier existingCollateral(uint256 strategyId, address col) {\n        if (maxLTV[strategyId][col] == 0)\n            revert Errors.COLLATERAL_NOT_EXIST(strategyId, col);\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract and sets the deployer as the initial owner.\n    /// @param bank_ The address of the bank contract.\n    /// @param werc20_ The address of the wrapped ERC20 contract.\n    /// @param weth_ The address of the wrapped Ether token.\n    function __BasicSpell_init(\n        IBank bank_,\n        address werc20_,\n        address weth_\n    ) internal onlyInitializing {\n        if (\n            address(bank_) == address(0) ||\n            address(werc20_) == address(0) ||\n            address(weth_) == address(0)\n        ) revert Errors.ZERO_ADDRESS();\n\n        __Ownable_init();\n\n        bank = bank_;\n        werc20 = IWERC20(werc20_);\n        WETH = weth_;\n\n        IWERC20(werc20_).setApprovalForAll(address(bank_), true);\n    }\n\n    /// @notice Adds a new strategy to the list of available strategies.\n    /// @dev Internal function that appends to the strategies array.\n    /// @dev Emit {StrategyAdded} event.\n    /// @param vault The address of the vault associated with this strategy.\n    /// @param minPosSize The minimum position size (USD value) for this strategy. Value is based on 1e18.\n    /// @param maxPosSize The maximum position size (USD value) for this strategy. Value is based on 1e18.\n    function _addStrategy(\n        address vault,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) internal {\n        if (vault == address(0)) revert Errors.ZERO_ADDRESS();\n        if (maxPosSize == 0) revert Errors.ZERO_AMOUNT();\n        if (minPosSize >= maxPosSize) revert Errors.INVALID_POS_SIZE();\n        strategies.push(\n            Strategy({\n                vault: vault,\n                minPositionSize: minPosSize,\n                maxPositionSize: maxPosSize\n            })\n        );\n        emit StrategyAdded(\n            strategies.length - 1,\n            vault,\n            minPosSize,\n            maxPosSize\n        );\n    }\n\n    /// @notice Update the position sizes for a specific strategy.\n    /// @dev This function validates the inputs, updates the strategy's position sizes, and emits an event.\n    /// @param strategyId ID of the strategy to be updated.\n    /// @param minPosSize New minimum position size for the strategy.\n    /// @param maxPosSize New maximum position size for the strategy.\n    function setPosSize(\n        uint256 strategyId,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (maxPosSize == 0) revert Errors.ZERO_AMOUNT();\n        if (minPosSize >= maxPosSize) revert Errors.INVALID_POS_SIZE();\n        strategies[strategyId].minPositionSize = minPosSize;\n        strategies[strategyId].maxPositionSize = maxPosSize;\n        emit StrategyPosSizeUpdated(strategyId, minPosSize, maxPosSize);\n    }\n\n    /// @notice Set maximum Loan-To-Value (LTV) ratios for collaterals in a given strategy.\n    /// @dev This function validates the input arrays, sets the maxLTVs for each collateral, and emits an event.\n    /// @param strategyId ID of the strategy for which the maxLTVs are being set.\n    /// @param collaterals Array of addresses for each collateral token.\n    /// @param maxLTVs Array of maxLTV values corresponding to each collateral token.\n    function setCollateralsMaxLTVs(\n        uint256 strategyId,\n        address[] memory collaterals,\n        uint256[] memory maxLTVs\n    ) external existingStrategy(strategyId) onlyOwner {\n        if (collaterals.length != maxLTVs.length || collaterals.length == 0)\n            revert Errors.INPUT_ARRAY_MISMATCH();\n\n        for (uint256 i = 0; i < collaterals.length; i++) {\n            if (collaterals[i] == address(0)) revert Errors.ZERO_ADDRESS();\n            if (maxLTVs[i] == 0) revert Errors.ZERO_AMOUNT();\n            maxLTV[strategyId][collaterals[i]] = maxLTVs[i];\n        }\n\n        emit CollateralsMaxLTVSet(strategyId, collaterals, maxLTVs);\n    }\n\n    /// @notice Internal function to validate if the current position adheres to the maxLTV of the strategy.\n    /// @dev If the debtValue of the position is greater than permissible, the transaction will revert.\n    /// @param strategyId Strategy ID to validate against.\n    function _validateMaxLTV(uint256 strategyId) internal {\n        uint positionId = bank.POSITION_ID();\n        IBank.Position memory pos = bank.getPositionInfo(positionId);\n        uint256 debtValue = bank.getDebtValue(positionId);\n        uint uValue = bank.getIsolatedCollateralValue(positionId);\n\n        if (\n            debtValue >\n            (uValue * maxLTV[strategyId][pos.underlyingToken]) /\n                Constants.DENOMINATOR\n        ) revert Errors.EXCEED_MAX_LTV();\n    }\n\n    /// @notice Internal function to validate if the current position size is within the strategy's bounds.\n    /// @param strategyId Strategy ID to validate against.\n    function _validatePosSize(uint256 strategyId) internal {\n        Strategy memory strategy = strategies[strategyId];\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n\n        /// Get previous position size\n        uint256 prevPosSize;\n        if (pos.collToken != address(0)) {\n            prevPosSize = bank.oracle().getWrappedTokenValue(\n                pos.collToken,\n                pos.collId,\n                pos.collateralSize\n            );\n        }\n\n        /// Get newly added position size\n        uint256 addedPosSize;\n        IERC20Upgradeable lpToken = IERC20Upgradeable(strategy.vault);\n        uint256 lpBalance = lpToken.balanceOf(address(this));\n        uint256 lpPrice = bank.oracle().getPrice(address(lpToken));\n        addedPosSize =\n            (lpPrice * lpBalance) /\n            10 ** IERC20MetadataUpgradeable(address(lpToken)).decimals();\n        // Check if position size is within bounds\n        if (prevPosSize + addedPosSize > strategy.maxPositionSize)\n            revert Errors.EXCEED_MAX_POS_SIZE(strategyId);\n        if (prevPosSize + addedPosSize < strategy.minPositionSize)\n            revert Errors.EXCEED_MIN_POS_SIZE(strategyId);\n    }\n\n    /// @notice Internal function to refund the specified tokens to the current executor of the bank.\n    /// @param token Address of the token to refund.\n    function _doRefund(address token) internal {\n        uint256 balance = IERC20Upgradeable(token).balanceOf(address(this));\n        if (balance > 0) {\n            IERC20Upgradeable(token).safeTransfer(bank.EXECUTOR(), balance);\n        }\n    }\n\n    /// @notice Internal function to cut a fee from the rewards.\n    /// @param token Address of the reward token.\n    /// @return left Amount remaining after the fee cut.\n    function _doCutRewardsFee(address token) internal returns (uint256 left) {\n        uint256 rewardsBalance = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        if (rewardsBalance > 0) {\n            _ensureApprove(token, address(bank.feeManager()), rewardsBalance);\n            left = bank.feeManager().doCutRewardsFee(token, rewardsBalance);\n        }\n    }\n\n    /// @notice Internal function to cut the reward fee and refund the remaining rewards to the current bank executor.\n    /// @param token Address of the reward token.\n    function _doRefundRewards(address token) internal {\n        _doCutRewardsFee(token);\n        _doRefund(token);\n    }\n\n    /// @notice Internall function Deposit specified collateral into the bank.\n    /// @dev Only deposits the collateral if the amount specified is greater than zero.\n    /// @param token Address of the isolated collateral token to be deposited.\n    /// @param amount Amount of tokens to be deposited.\n    function _doLend(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.lend(token, amount);\n        }\n    }\n\n    /// @notice Internal function Withdraw specified collateral from the bank.\n    /// @dev Only withdraws the collateral if the amount specified is greater than zero.\n    /// @param token Address of the isolated collateral token to be withdrawn.\n    /// @param amount Amount of tokens to be withdrawn.\n    function _doWithdraw(address token, uint256 amount) internal {\n        if (amount > 0) {\n            bank.withdrawLend(token, amount);\n        }\n    }\n\n    /// @notice Internal function Borrow specified tokens from the bank for the current executor.\n    /// @dev The borrowing happens only if the specified amount is greater than zero.\n    /// @param token Address of the token to be borrowed.\n    /// @param amount Amount of tokens to borrow.\n    /// @return borrowedAmount Actual amount of tokens borrowed.\n    function _doBorrow(\n        address token,\n        uint256 amount\n    ) internal returns (uint256 borrowedAmount) {\n        if (amount > 0) {\n            borrowedAmount = bank.borrow(token, amount);\n        }\n    }\n\n    /// @notice Internall function Repay specified tokens to the bank for the current executor.\n    /// @dev Ensures approval of tokens to the bank and repays them. \n    ///      Only repays if the specified amount is greater than zero.\n    /// @param token Address of the token to be repaid to the bank.\n    /// @param amount Amount of tokens to repay.\n    function _doRepay(address token, uint256 amount) internal {\n        if (amount > 0) {\n            _ensureApprove(token, address(bank), amount);\n            bank.repay(token, amount);\n        }\n    }\n\n    /// @notice Internal function Deposit collateral tokens into the bank.\n    /// @dev Ensures approval of tokens to the werc20 contract, mints them, \n    ///      and then deposits them as collateral in the bank. \n    ///      Only deposits if the specified amount is greater than zero.\n    /// @param token Address of the collateral token to be deposited.\n    /// @param amount Amount of collateral tokens to deposit.\n    function _doPutCollateral(address token, uint256 amount) internal {\n        if (amount > 0) {\n            _ensureApprove(token, address(werc20), amount);\n            werc20.mint(token, amount);\n            bank.putCollateral(\n                address(werc20),\n                uint256(uint160(token)),\n                amount\n            );\n        }\n    }\n\n    /// @notice Internal function Withdraw collateral tokens from the bank.\n    /// @dev Burns the withdrawn tokens from werc20 contract after retrieval. \n    ///      Only withdraws if the specified amount is greater than zero.\n    /// @param token Address of the collateral token to be withdrawn.\n    /// @param amount Amount of collateral tokens to withdraw.\n    function _doTakeCollateral(address token, uint256 amount) internal {\n        if (amount > 0) {\n            amount = bank.takeCollateral(amount);\n            werc20.burn(token, amount);\n        }\n    }\n\n    /// @notice Increase isolated collateral to support the position\n    /// @param token Isolated collateral token address\n    /// @param amount Amount of token to deposit and increase position\n    function increasePosition(address token, uint256 amount) external {\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(token, amount);\n    }\n\n    /// @dev Reduce the isolated collateral of a position.\n    /// @param strategyId The ID of the strategy being used.\n    /// @param collToken Address of the isolated collateral token.\n    /// @param collShareAmount Amount of isolated collateral to reduce.\n    function reducePosition(\n        uint256 strategyId,\n        address collToken,\n        uint256 collShareAmount\n    ) external {\n        /// Validate strategy id\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address unwrappedCollToken = IERC20Wrapper(pos.collToken)\n            .getUnderlyingToken(pos.collId);\n        if (strategies[strategyId].vault != unwrappedCollToken)\n            revert Errors.INCORRECT_STRATEGY_ID(strategyId);\n\n        _doWithdraw(collToken, collShareAmount);\n        _doRefund(collToken);\n        _validateMaxLTV(strategyId);\n    }\n\n    /// @dev Fallback function. Can only receive ETH from WETH contract.\n    receive() external payable {\n        if (msg.sender != WETH) revert Errors.NOT_FROM_WETH(msg.sender);\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    ///      variables without shifting down storage in the inheritance chain.\n    ///      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/spell/ConvexSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/// @title ConvexSpell\n/// @author BlueberryProtocol\n/// @notice This contract serves as the factory for defining how the Blueberry Protocol \n///         interacts with Convex pools. It handles strategies, interactions with external contracts, \n///         and facilitates operations related to liquidity provision.\ncontract ConvexSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address of the Wrapped Convex Pools\n    IWConvexPools public wConvexPools;\n    /// @dev address of CurveOracle to retrieve pool information\n    ICurveOracle public crvOracle;\n    /// @dev address of CVX token\n    address public CVX;\n\n    /// @dev paraswap AugustusSwapper address for token swaps\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address for efficient token transfers\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n        \n    /// @notice Initializes the ConvexSpell contract with required parameters.\n    /// @param bank_ Address of the bank contract.\n    /// @param werc20_ Address of the wrapped ERC20 contract.\n    /// @param weth_ Address of the wrapped Ethereum contract.\n    /// @param wConvexPools_ Address of the wrapped Convex pools contract.\n    /// @param crvOracle_ Address of the Curve Oracle contract.\n    /// @param augustusSwapper_ Address of the paraswap AugustusSwapper.\n    /// @param tokenTransferProxy_ Address of the paraswap TokenTransferProxy.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wConvexPools_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wConvexPools_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wConvexPools = IWConvexPools(wConvexPools_);\n        CVX = address(wConvexPools.CVX());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWConvexPools(wConvexPools_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /// @notice Adds a new strategy to the spell.\n    /// @param crvLp Address of the Curve LP token for the strategy.\n    /// @param minPosSize Minimum position size in USD for the strategy (with 1e18 precision).\n    /// @param maxPosSize Maximum position size in USD for the strategy (with 1e18 precision).\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /// @notice Adds liquidity to a Curve pool with two underlying tokens and stakes in Curve gauge.\n    /// @param param Struct containing all required parameters for opening a position.\n    /// @param minLPMint Minimum LP tokens expected to mint for slippage control.\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        (address lpToken, , , , , ) = wConvexPools.getPoolInfoFromPoolId(\n            param.farmingPoolId\n        );\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        /// 3. Add liquidity on curve, get crvLp\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            lpToken\n        );\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i; i != 2; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i; i != 3; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i; i != 4; ++i) {\n                suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                    address(this)\n                );\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        /// 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n        /// 6. Take out existing collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 pid, ) = wConvexPools.decodeId(pos.collId);\n            if (param.farmingPoolId != pid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wConvexPools))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            (address[] memory rewardTokens, ) = wConvexPools.burn(pos.collId, pos.collateralSize);\n            // distribute multiple rewards to users\n            uint256 tokensLength = rewardTokens.length;\n            for (uint256 i; i != tokensLength; ++i) {\n                _doRefundRewards(rewardTokens[i]);\n            }\n        }\n\n        /// 7. Deposit on Convex Pool, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wConvexPools), lpAmount);\n        uint256 id = wConvexPools.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wConvexPools), id, lpAmount);\n    }\n\n    /// @notice Closes an existing liquidity position, unstakes from Curve gauge, and swaps rewards.\n    /// @param param Struct containing all required parameters for closing a position.\n    /// @param expectedRewards List of expected reward amounts for each token.\n    /// @param swapDatas Swap data for each reward token.\n    function closePositionFarm(\n        ClosePosParam calldata param,\n        uint256[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wConvexPools))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wConvexPools.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        uint256 amountPosRemove = param.amountPosRemove;\n\n        /// 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(amountPosRemove);\n        (address[] memory rewardTokens, ) = wConvexPools.burn(\n            pos.collId,\n            amountPosRemove\n        );\n\n        /// 2. Swap rewards tokens to debt token\n        _sellRewards(rewardTokens, expectedRewards, swapDatas);\n\n        /// 3. Remove liquidity\n        _removeLiquidity(param, pos, crvLp, amountPosRemove);\n\n        /// 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 5. Repay\n        {\n            /// Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        /// 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CVX);\n    }\n\n    /// @dev Removes liquidity from a Curve pool for a given position.\n    /// @param param Contains data required to close the position.\n    /// @param pos Data structure representing the current bank position.\n    /// @param crvLp Address of the Curve LP token.\n    /// @param amountPosRemove Amount of LP tokens to be removed from the pool. \n    ///        If set to max, will remove all available LP tokens.\n    function _removeLiquidity(\n        ClosePosParam memory param,\n        IBank.Position memory pos,\n        address crvLp,\n        uint256 amountPosRemove\n    ) internal {\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(\n            crvLp\n        );\n\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(address(this));\n        }\n\n        int128 tokenIndex;\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            if (tokens[i] == pos.debtToken) {\n                tokenIndex = int128(uint128(i));\n                break;\n            }\n        }\n\n        /// Removes liquidity from the Curve pool for the specified token.\n        ICurvePool(pool).remove_liquidity_one_coin(\n            amountPosRemove,\n            int128(tokenIndex),\n            param.amountOutMin\n        );\n    }\n\n    /// @dev Internal function Sells the accumulated reward tokens.\n    /// @param rewardTokens An array of addresses of the reward tokens to be sold.\n    /// @param expectedRewards Array containing the expected amounts of each reward token.\n    /// @param swapDatas Data required for performing the swaps.\n    function _sellRewards(\n        address[] memory rewardTokens,\n        uint[] calldata expectedRewards,\n        bytes[] calldata swapDatas\n    ) internal {\n        uint256 tokensLength = rewardTokens.length;\n        for (uint256 i; i != tokensLength; ++i) {\n            address sellToken = rewardTokens[i];\n\n            /// Apply any potential fees on the reward.\n            _doCutRewardsFee(sellToken);\n\n            uint expectedReward = expectedRewards[i];\n            /// If the expected reward is zero, skip to the next token.\n            if (expectedReward == 0) continue;\n            /// Swap the reward token for another desired token. If the swap fails, revert with an error.\n            if (\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    sellToken,\n                    expectedReward,\n                    swapDatas[i]\n                )\n            ) revert Errors.SWAP_FAILED(sellToken);\n            /// Refund any leftover (dust) amounts after the swap to the contract owner\n            _doRefund(sellToken);\n        }\n    }\n}\n"
    },
    "contracts/spell/CurveSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/ICurveOracle.sol\";\nimport \"../interfaces/IWCurveGauge.sol\";\nimport \"../interfaces/curve/ICurvePool.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title CurveSpell\n * @author BlueberryProtocol\n * @notice CurveSpell is the factory contract that\n * defines how Blueberry Protocol interacts with Curve pools\n */\ncontract CurveSpell is BasicSpell {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /// @dev address of Wrapped Curve Gauge\n    IWCurveGauge public wCurveGauge;\n    /// @dev address of CurveOracle\n    ICurveOracle public crvOracle;\n    /// @dev address of CRV token\n    address public CRV;\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wCurveGauge_,\n        address crvOracle_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wCurveGauge_ == address(0) || crvOracle_ == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        wCurveGauge = IWCurveGauge(wCurveGauge_);\n        CRV = address(wCurveGauge.CRV());\n        crvOracle = ICurveOracle(crvOracle_);\n        IWCurveGauge(wCurveGauge_).setApprovalForAll(address(bank_), true);\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n    }\n\n    /**\n     * @notice Add strategy to the spell\n     * @param crvLp Address of crv lp token for given strategy\n     * @param minPosSize, USD price of minimum position size for given strategy, based 1e18\n     * @param maxPosSize, USD price of maximum position size for given strategy, based 1e18\n     */\n    function addStrategy(\n        address crvLp,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(crvLp, minPosSize, maxPosSize);\n    }\n\n    /**\n     * @notice Add liquidity to Curve pool with 2 underlying tokens, with staking to Curve gauge\n     * @param minLPMint Desired LP token amount (slippage control)\n     */\n    function openPositionFarm(\n        OpenPosParam calldata param,\n        uint256 minLPMint\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address lp = strategies[param.strategyId].vault;\n        if (wCurveGauge.getLpFromGaugeId(param.farmingPoolId) != lp)\n            revert Errors.INCORRECT_LP(lp);\n        (address pool, address[] memory tokens, ) = crvOracle.getPoolInfo(lp);\n\n        // 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        // 2. Borrow specific amounts\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        // 3. Add liquidity on curve\n        address borrowToken = param.borrowToken;\n        _ensureApprove(param.borrowToken, pool, borrowBalance);\n        if (tokens.length == 2) {\n            uint256[2] memory suppliedAmts;\n            for (uint256 i = 0; i < 2; i++) {\n                if (tokens[i] == borrowToken) {\n                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                        address(this)\n                    );\n                    break;\n                }\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 3) {\n            uint256[3] memory suppliedAmts;\n            for (uint256 i = 0; i < 3; i++) {\n                if (tokens[i] == borrowToken) {\n                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                        address(this)\n                    );\n                    break;\n                }\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        } else if (tokens.length == 4) {\n            uint256[4] memory suppliedAmts;\n            for (uint256 i = 0; i < 4; i++) {\n                if (tokens[i] == borrowToken) {\n                    suppliedAmts[i] = IERC20Upgradeable(tokens[i]).balanceOf(\n                        address(this)\n                    );\n                    break;\n                }\n            }\n            ICurvePool(pool).add_liquidity(suppliedAmts, minLPMint);\n        }\n\n        // 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        // 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n\n        // 6. Take out collateral and burn\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collateralSize > 0) {\n            (uint256 decodedGid, ) = wCurveGauge.decodeId(pos.collId);\n            if (param.farmingPoolId != decodedGid)\n                revert Errors.INCORRECT_PID(param.farmingPoolId);\n            if (pos.collToken != address(wCurveGauge))\n                revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n            bank.takeCollateral(pos.collateralSize);\n            wCurveGauge.burn(pos.collId, pos.collateralSize);\n            _doRefundRewards(CRV);\n        }\n\n        // 7. Deposit on Curve Gauge, Put wrapped collateral tokens on Blueberry Bank\n        uint256 lpAmount = IERC20Upgradeable(lp).balanceOf(address(this));\n        _ensureApprove(lp, address(wCurveGauge), lpAmount);\n        uint256 id = wCurveGauge.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wCurveGauge), id, lpAmount);\n    }\n\n    function closePositionFarm(\n        ClosePosParam memory param,\n        uint256[] calldata amounts,\n        bytes[] calldata swapDatas,\n        bool isKilled,\n        uint256 deadline\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        if (block.timestamp > deadline) revert Errors.EXPIRED(deadline);\n\n        address crvLp = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        if (pos.collToken != address(wCurveGauge))\n            revert Errors.INCORRECT_COLTOKEN(pos.collToken);\n        if (wCurveGauge.getUnderlyingToken(pos.collId) != crvLp)\n            revert Errors.INCORRECT_UNDERLYING(crvLp);\n\n        // 1. Take out collateral - Burn wrapped tokens, receive crv lp tokens and harvest CRV\n        bank.takeCollateral(param.amountPosRemove);\n        wCurveGauge.burn(pos.collId, param.amountPosRemove);\n\n        {\n            // 2. Swap rewards tokens to debt token\n            _swapOnParaswap(CRV, amounts[0], swapDatas[0]);\n        }\n\n        {\n            address[] memory tokens;\n            {\n                address pool;\n                (pool, tokens, ) = crvOracle.getPoolInfo(crvLp);\n\n                // 3. Calculate actual amount to remove\n                uint256 amountPosRemove = param.amountPosRemove;\n                if (amountPosRemove == type(uint256).max) {\n                    amountPosRemove = IERC20Upgradeable(crvLp).balanceOf(\n                        address(this)\n                    );\n                }\n\n                // 4. Remove liquidity\n                _removeLiquidity(\n                    param,\n                    isKilled,\n                    pool,\n                    tokens,\n                    pos,\n                    amountPosRemove\n                );\n            }\n\n            if (isKilled) {\n                uint256 len = tokens.length;\n                for (uint256 i; i != len; ++i) {\n                    if (tokens[i] != pos.debtToken) {\n                        _swapOnParaswap(\n                            tokens[i],\n                            amounts[i + 1],\n                            swapDatas[i + 1]\n                        );\n                    }\n                }\n            }\n        }\n\n        // 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        // 6. Repay\n        {\n            // Compute repay amount if MAX_INT is supplied (max debt)\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        // 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n        _doRefund(CRV);\n    }\n\n    function _removeLiquidity(\n        ClosePosParam memory param,\n        bool isKilled,\n        address pool,\n        address[] memory tokens,\n        IBank.Position memory pos,\n        uint256 amountPosRemove\n    ) internal {\n        uint256 tokenIndex;\n        {\n            uint256 len = tokens.length;\n            for (uint256 i; i != len; ++i) {\n                if (tokens[i] == pos.debtToken) {\n                    tokenIndex = i;\n                    break;\n                }\n            }\n        }\n\n        if (isKilled) {\n            uint256 len = tokens.length;\n            if (len == 2) {\n                uint256[2] memory minOuts;\n                ICurvePool(pool).remove_liquidity(amountPosRemove, minOuts);\n            } else if (len == 3) {\n                uint256[3] memory minOuts;\n                ICurvePool(pool).remove_liquidity(amountPosRemove, minOuts);\n            } else if (len == 4) {\n                uint256[4] memory minOuts;\n                ICurvePool(pool).remove_liquidity(amountPosRemove, minOuts);\n            } else {\n                revert(\"Invalid pool length\");\n            }\n        } else {\n            ICurvePool(pool).remove_liquidity_one_coin(\n                amountPosRemove,\n                int128(uint128(tokenIndex)),\n                param.amountOutMin\n            );\n        }\n    }\n\n    function _swapOnParaswap(\n        address token,\n        uint256 amount,\n        bytes calldata swapData\n    ) internal {\n        if (amount == 0) return;\n        if (\n            !PSwapLib.swap(\n                augustusSwapper,\n                tokenTransferProxy,\n                token,\n                amount,\n                swapData\n            )\n        ) revert Errors.SWAP_FAILED(token);\n\n        // Refund rest amount to owner\n        _doRefund(token);\n    }\n}\n"
    },
    "contracts/spell/IchiSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\nimport \"./BasicSpell.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/ichi/IICHIVault.sol\";\nimport \"../interfaces/uniswap/IUniswapV3Router.sol\";\n\n/// @title IchiSpell\n/// @author BlueberryProtocol\n/// @notice Factory contract that defines the interaction between the Blueberry Protocol and Ichi Vaults.\ncontract IchiSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Temporary state to store Uniswap V3 pool for swapping operations.\n    IUniswapV3Pool private SWAP_POOL;\n\n    /// @dev Address of the Uniswap V3 router.\n    IUniswapV3Router private uniV3Router;\n\n    /// @dev Address of the ICHI farm wrapper.\n    IWIchiFarm public wIchiFarm;\n    /// @dev Address of the ICHI token.\n    address public ICHI;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes contract with essential external dependencies.\n    /// @param bank_ Address of the bank.\n    /// @param werc20_ Address of the wrapped ERC20.\n    /// @param weth_ Address of WETH.\n    /// @param wichiFarm_ Address of ICHI farm wrapper.\n    /// @param uniV3Router_ Address of the Uniswap V3 router.\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address wichiFarm_,\n        address uniV3Router_\n    ) external initializer {\n        __BasicSpell_init(bank_, werc20_, weth_);\n        if (wichiFarm_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        wIchiFarm = IWIchiFarm(wichiFarm_);\n        ICHI = address(wIchiFarm.ICHI());\n        wIchiFarm.setApprovalForAll(address(bank_), true);\n\n        uniV3Router = IUniswapV3Router(uniV3Router_);\n    }\n\n    /// @notice Adds a strategy to the contract.\n    /// @param vault Address of the vault linked to the strategy.\n    /// @param minPosSize Minimum position size in USD, normalized to 1e18.\n    /// @param maxPosSize Maximum position size in USD, normalized to 1e18.\n    function addStrategy(\n        address vault,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(vault, minPosSize, maxPosSize);\n    }\n\n    /// @notice Handles the deposit logic, including lending and borrowing\n    ///         operations, and depositing borrowed tokens in the ICHI vault.\n    /// @param param Parameters required for the deposit operation.\n    function _deposit(OpenPosParam calldata param) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        IICHIVault vault = IICHIVault(strategy.vault);\n        if (\n            vault.token0() != param.borrowToken &&\n            vault.token1() != param.borrowToken\n        ) revert Errors.INCORRECT_DEBT(param.borrowToken);\n        uint256 borrowBalance = _doBorrow(\n            param.borrowToken,\n            param.borrowAmount\n        );\n\n        /// 3. Add liquidity - Deposit on ICHI Vault\n        bool isTokenA = vault.token0() == param.borrowToken;\n        _ensureApprove(param.borrowToken, address(vault), borrowBalance);\n\n        uint ichiVaultShare;\n        if (isTokenA) {\n            ichiVaultShare = vault.deposit(borrowBalance, 0, address(this));\n        } else {\n            ichiVaultShare = vault.deposit(0, borrowBalance, address(this));\n        }\n\n        /// 4. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 5. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n    }\n\n    /// @notice Deposits assets into an IchiVault.\n    /// @param param Parameters required for the open position operation.\n    /// @dev param struct found in {BasicSpell}.\n    function openPosition(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// 1-5 Deposit on ichi vault\n        _deposit(param);\n\n        /// 6. Put collateral - ICHI Vault Lp Token\n        address vault = strategies[param.strategyId].vault;\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(vault).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Deposits assets into an IchiVault and then farms them in Ichi Farm.\n    /// @param param Parameters required for the open position operation.\n    /// @dev param struct found in {BasicSpell}.\n    function openPositionFarm(\n        OpenPosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        address lpToken = wIchiFarm.ichiFarm().lpToken(param.farmingPoolId);\n        if (strategy.vault != lpToken) revert Errors.INCORRECT_LP(lpToken);\n\n        /// 1-5 Deposit on ichi vault\n        _deposit(param);\n\n        /// 6. Take out collateral and burn\n        {\n            IBank.Position memory pos = bank.getCurrentPositionInfo();\n            address posCollToken = pos.collToken;\n            uint256 collId = pos.collId;\n            uint256 collSize = pos.collateralSize;\n            if (collSize > 0) {\n                (uint256 decodedPid, ) = wIchiFarm.decodeId(collId);\n                if (param.farmingPoolId != decodedPid)\n                    revert Errors.INCORRECT_PID(param.farmingPoolId);\n                if (posCollToken != address(wIchiFarm))\n                    revert Errors.INCORRECT_COLTOKEN(posCollToken);\n                bank.takeCollateral(collSize);\n                wIchiFarm.burn(collId, collSize);\n                _doRefundRewards(ICHI);\n            }\n        }\n\n        /// 5. Deposit on farming pool, put collateral\n        uint256 lpAmount = IERC20Upgradeable(lpToken).balanceOf(address(this));\n        _ensureApprove(lpToken, address(wIchiFarm), lpAmount);\n        uint256 id = wIchiFarm.mint(param.farmingPoolId, lpAmount);\n        bank.putCollateral(address(wIchiFarm), id, lpAmount);\n    }\n\n    /// @notice Handles the withdrawal logic, including withdrawing \n    ///         from the ICHI vault, swapping tokens, and repaying the debt.\n    /// @param param Parameters required for the withdrawal operation.\n    /// @dev param struct found in {BasicSpell}.\n    function _withdraw(ClosePosParam calldata param) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n        IICHIVault vault = IICHIVault(strategy.vault);\n\n        /// 1. Compute repay amount if MAX_INT is supplied (max debt)\n        uint256 amountRepay = param.amountRepay;\n        if (amountRepay == type(uint256).max) {\n            amountRepay = bank.currentPositionDebt(bank.POSITION_ID());\n        }\n\n        /// 2. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        /// 3. Withdraw liquidity from ICHI vault\n        vault.withdraw(amountPosRemove, address(this));\n\n        /// 4. Swap withdrawn tokens to debt token\n        bool isTokenA = vault.token0() == param.borrowToken;\n        uint256 amountIn = IERC20Upgradeable(\n            isTokenA ? vault.token1() : vault.token0()\n        ).balanceOf(address(this));\n\n        if (amountIn > 0) {\n            address[] memory swapPath = new address[](2);\n            swapPath[0] = isTokenA ? vault.token1() : vault.token0();\n            swapPath[1] = isTokenA ? vault.token0() : vault.token1();\n\n            IUniswapV3Router.ExactInputSingleParams\n                memory params = IUniswapV3Router.ExactInputSingleParams({\n                    tokenIn: swapPath[0],\n                    tokenOut: swapPath[1],\n                    fee: IUniswapV3Pool(vault.pool()).fee(),\n                    recipient: address(this),\n                    deadline: block.timestamp,\n                    amountIn: amountIn,\n                    amountOutMinimum: param.amountOutMin,\n                    sqrtPriceLimitX96: 0\n                });\n\n            _ensureApprove(params.tokenIn, address(uniV3Router), amountIn);\n            uniV3Router.exactInputSingle(params);\n        }\n\n        /// 5. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 6. Repay\n        _doRepay(param.borrowToken, amountRepay);\n\n        _validateMaxLTV(param.strategyId);\n\n        /// 7. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @notice Withdraws assets from an ICHI Vault.\n    /// @param param Parameters required for the close position operation.\n    /// @dev param struct found in {BasicSpell}.\n    function closePosition(\n        ClosePosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        /// 1. Take out collateral\n        _doTakeCollateral(\n            strategies[param.strategyId].vault,\n            param.amountPosRemove\n        );\n\n        /// 2-8. Remove liquidity\n        _withdraw(param);\n    }\n\n    /// @notice Withdraws assets from an ICHI Vault and from Ichi Farm.\n    /// @param param Parameters required for the close position operation.\n    /// @dev param struct found in {BasicSpell}.\n    function closePositionFarm(\n        ClosePosParam calldata param\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWIchiFarm(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(wIchiFarm))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        /// 1. Take out collateral\n        bank.takeCollateral(param.amountPosRemove);\n        wIchiFarm.burn(collId, param.amountPosRemove);\n        _doRefundRewards(ICHI);\n\n        /// 2-8. Remove liquidity\n        _withdraw(param);\n\n        /// 9. Refund ichi token\n        _doRefund(ICHI);\n    }\n}\n"
    },
    "contracts/spell/ShortLongSpell.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\nimport \"./BasicSpell.sol\";\n\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/IWERC20.sol\";\nimport \"../libraries/Paraswap/PSwapLib.sol\";\n\n/**\n * @title Short/Long Spell\n * @author BlueberryProtocol\n * @notice Short/Long Spell is the factory contract that\n * defines how Blueberry Protocol interacts for leveraging\n * an asset either long or short\n */\ncontract ShortLongSpell is BasicSpell {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev paraswap AugustusSwapper address\n    address public augustusSwapper;\n\n    /// @dev paraswap TokenTransferProxy address\n    address public tokenTransferProxy;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract\n    /// @param bank_ The bank interface\n    /// @param werc20_ Wrapped ERC20 interface\n    /// @param weth_ Wrapped Ether address\n    /// @param augustusSwapper_ Augustus Swapper address\n    /// @param tokenTransferProxy_ Token Transfer Proxy address\n    function initialize(\n        IBank bank_,\n        address werc20_,\n        address weth_,\n        address augustusSwapper_,\n        address tokenTransferProxy_\n    ) external initializer {\n        if (augustusSwapper_ == address(0)) revert Errors.ZERO_ADDRESS();\n        if (tokenTransferProxy_ == address(0)) revert Errors.ZERO_ADDRESS();\n\n        augustusSwapper = augustusSwapper_;\n        tokenTransferProxy = tokenTransferProxy_;\n\n        __BasicSpell_init(bank_, werc20_, weth_);\n    }\n\n    /// @notice Internal function to swap token using paraswap assets\n    /// @dev Deposit isolated underlying to Blueberry Money Market,\n    ///      Borrow tokens from Blueberry Money Market,\n    ///      Swap borrowed token to another token\n    ///      Then deposit swapped token to softvault,\n    /// @param param Parameters for opening position\n    /// @dev params found in OpenPosParam struct in {BasicSpell}\n    /// @param swapData Data for paraswap swap\n    /// @dev swapData found in bytes struct in {PSwapLib}\n    function _deposit(\n        OpenPosParam calldata param,\n        bytes calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        /// 1. Deposit isolated collaterals on Blueberry Money Market\n        _doLend(param.collToken, param.collAmount);\n\n        /// 2. Borrow specific amounts\n        _doBorrow(param.borrowToken, param.borrowAmount);\n\n        /// 3. Swap borrowed token to strategy token\n        IERC20Upgradeable swapToken = ISoftVault(strategy.vault).uToken();\n        uint256 dstTokenAmt = swapToken.balanceOf(address(this));\n\n        address borrowToken = param.borrowToken;\n        if (\n            !PSwapLib.swap(\n                augustusSwapper,\n                tokenTransferProxy,\n                borrowToken,\n                param.borrowAmount,\n                swapData\n            )\n        ) revert Errors.SWAP_FAILED(borrowToken);\n        dstTokenAmt = swapToken.balanceOf(address(this)) - dstTokenAmt;\n        if (dstTokenAmt == 0) revert Errors.SWAP_FAILED(borrowToken);\n\n        /// 4. Deposit to SoftVault directly\n        _ensureApprove(\n            address(swapToken),\n            address(strategy.vault),\n            dstTokenAmt\n        );\n        ISoftVault(strategy.vault).deposit(dstTokenAmt);\n\n        /// 5. Validate MAX LTV\n        _validateMaxLTV(param.strategyId);\n\n        /// 6. Validate Max Pos Size\n        _validatePosSize(param.strategyId);\n    }\n\n    /// @notice Opens a position using provided parameters and swap data.\n    /// @dev This function first deposits an isolated underlying asset to Blueberry Money Market,\n    /// then borrows tokens from it. The borrowed tokens are swapped for another token using\n    /// ParaSwap and the resulting tokens are deposited into the softvault.\n    /// \n    /// Pre-conditions:\n    /// - Strategy for `param.strategyId` must exist.\n    /// - Collateral for `param.strategyId` and `param.collToken` must exist.\n    /// \n    /// @param param Parameters required to open the position, described in the `OpenPosParam` struct from {BasicSpell}.\n    /// @param swapData Specific data needed for the ParaSwap swap, structured in the `bytes` format from {PSwapLib}.\n    function openPosition(\n        OpenPosParam calldata param,\n        bytes calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n        if (address(ISoftVault(strategy.vault).uToken()) == param.borrowToken)\n            revert Errors.INCORRECT_LP(param.borrowToken);\n\n        /// 1-3 Swap to strategy underlying token, deposit to softvault\n        _deposit(param, swapData);\n\n        /// 4. Put collateral - strategy token\n        address vault = strategies[param.strategyId].vault;\n\n        _doPutCollateral(\n            vault,\n            IERC20Upgradeable(ISoftVault(vault)).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Internal utility function to handle the withdrawal of assets from SoftVault.\n    /// @param param Parameters required for the withdrawal, described in the `ClosePosParam` struct.\n    /// @param swapData Specific data needed for the ParaSwap swap.\n    function _withdraw(\n        ClosePosParam calldata param,\n        bytes calldata swapData\n    ) internal {\n        Strategy memory strategy = strategies[param.strategyId];\n        ISoftVault vault = ISoftVault(strategy.vault);\n        uint256 positionId = bank.POSITION_ID();\n\n        /// 1. Calculate actual amount to remove\n        uint256 amountPosRemove = param.amountPosRemove;\n        if (amountPosRemove == type(uint256).max) {\n            amountPosRemove = vault.balanceOf(address(this));\n        }\n\n        /// 2. Withdraw from softvault\n        uint256 swapAmount = vault.withdraw(amountPosRemove);\n\n        /// 3. Swap strategy token to isolated collateral token\n        {\n            IERC20Upgradeable uToken = ISoftVault(strategy.vault).uToken();\n            uint256 balanceBefore = uToken.balanceOf(address(this));\n\n            if (\n                !PSwapLib.swap(\n                    augustusSwapper,\n                    tokenTransferProxy,\n                    address(uToken),\n                    swapAmount,\n                    swapData\n                )\n            ) revert Errors.SWAP_FAILED(address(uToken));\n\n            if (uToken.balanceOf(address(this)) > balanceBefore - swapAmount) {\n                revert Errors.INCORRECT_LP(address(uToken));\n            }\n        }\n\n        /// 4. Withdraw isolated collateral from Bank\n        _doWithdraw(param.collToken, param.amountShareWithdraw);\n\n        /// 5. Repay\n        {\n            uint256 amountRepay = param.amountRepay;\n            if (amountRepay == type(uint256).max) {\n                amountRepay = bank.currentPositionDebt(positionId);\n            }\n            _doRepay(param.borrowToken, amountRepay);\n        }\n\n        _validateMaxLTV(param.strategyId);\n\n        /// 6. Refund\n        _doRefund(param.borrowToken);\n        _doRefund(param.collToken);\n    }\n\n    /// @notice Externally callable function to close a position using provided parameters and swap data.\n    /// @dev This function is a higher-level action that internally calls `_withdraw` to manage the closing \n    /// of a position. It ensures the given strategy and collateral exist, and then carries out the required \n    /// operations to close the position.\n    /// \n    /// Pre-conditions:\n    /// - Strategy for `param.strategyId` must exist.\n    /// - Collateral for `param.strategyId` and `param.collToken` must exist.\n    /// \n    /// @param param Parameters required to close the position, described in the `ClosePosParam` struct.\n    /// @param swapData Specific data needed for the ParaSwap swap.\n    function closePosition(\n        ClosePosParam calldata param,\n        bytes calldata swapData\n    )\n        external\n        existingStrategy(param.strategyId)\n        existingCollateral(param.strategyId, param.collToken)\n    {\n        Strategy memory strategy = strategies[param.strategyId];\n\n        address vault = strategies[param.strategyId].vault;\n        IBank.Position memory pos = bank.getCurrentPositionInfo();\n        address posCollToken = pos.collToken;\n        uint256 collId = pos.collId;\n        if (IWERC20(posCollToken).getUnderlyingToken(collId) != vault)\n            revert Errors.INCORRECT_UNDERLYING(vault);\n        if (posCollToken != address(werc20))\n            revert Errors.INCORRECT_COLTOKEN(posCollToken);\n\n        /// 1. Take out collateral\n        uint burnAmount = bank.takeCollateral(param.amountPosRemove);\n\n        werc20.burn(address(ISoftVault(strategy.vault)), burnAmount);\n\n        /// 2-7. Remove liquidity\n        _withdraw(param, swapData);\n    }\n\n    /// @notice Add strategy to the spell\n    /// @param swapToken Address of token for given strategy\n    /// @param minPosSize USD price of minimum position size for given strategy, based 1e18\n    /// @param maxPosSize USD price of maximum position size for given strategy, based 1e18\n    function addStrategy(\n        address swapToken,\n        uint256 minPosSize,\n        uint256 maxPosSize\n    ) external onlyOwner {\n        _addStrategy(swapToken, minPosSize, maxPosSize);\n    }\n}\n"
    },
    "contracts/utils/BlueBerryConst.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\n/// title BlueberryConst\n/// @notice containing all general constants used in Blueberry protocol\npragma solidity 0.8.16;\n\n/// @dev Common denominator for percentage-based calculations.\nuint256 constant DENOMINATOR = 10000;\n\n/// @dev Minimum threshold for liquidity operations, represented as a fraction of the DENOMINATOR.\nuint256 constant MIN_LIQ_THRESHOLD = 8000; // represent 80%\n\n/// @dev Precision factor to maintain price accuracy.\nuint256 constant PRICE_PRECISION = 1e18;\n\n/// @dev Maximum allowed price deviation, represented as a fraction of the DENOMINATOR.\nuint256 constant MAX_PRICE_DEVIATION = 1000; // represent 10%\n\n/// @dev Minimum time interval for specific time-dependent operations.\nuint32 constant MIN_TIME_GAP = 1 hours;\n\n/// @dev Maximum time interval for specific time-dependent operations.\nuint32 constant MAX_TIME_GAP = 2 days;\n\n/// @dev Maximum allowed fee rate, represented as a fraction of the DENOMINATOR.\nuint256 constant MAX_FEE_RATE = 2000; // represent 20%\n\n/// @dev Maximum allowed time for vault withdrawal fee calculations.\nuint256 constant MAX_WITHDRAW_VAULT_FEE_WINDOW = 60 days;\n\n/// @dev Maximum delay permitted for swap operations.\nuint32 constant MAX_DELAY_ON_SWAP = 2 hours;\n\n/// @dev Allowed grace period time for sequencer operations.\nuint32 constant SEQUENCER_GRACE_PERIOD_TIME = 3600;\n\n/// @dev Precision factor for Chainlink price feed values.\nuint256 constant CHAINLINK_PRICE_FEED_PRECISION = 1e8;\n\n/// @dev Warm-up period before a liquidation repayment can be initiated.\nuint256 constant LIQUIDATION_REPAY_WARM_UP_PERIOD = 4 hours;\n"
    },
    "contracts/utils/BlueBerryErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\n/// title BlueberryErrors\n/// @notice containing all errors used in Blueberry protocol\npragma solidity 0.8.16;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                COMMON ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when an action involves zero amount of tokens.\nerror ZERO_AMOUNT();\n\n/// @notice Thrown when the address provided is the zero address.\nerror ZERO_ADDRESS();\n\n/// @notice Thrown when the lengths of input arrays do not match.\nerror INPUT_ARRAY_MISMATCH();\n\n/*//////////////////////////////////////////////////////////////////////////\n                                ORACLE ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the delay time exceeds allowed limits.\nerror TOO_LONG_DELAY(uint256 delayTime);\n\n/// @notice Thrown when there's no maximum delay set for a token.\nerror NO_MAX_DELAY(address token);\n\n/// @notice Thrown when the price information for a token is outdated.\nerror PRICE_OUTDATED(address token);\n\n/// @notice Thrown when there's no symbol mapping for the token.\nerror NO_SYM_MAPPING(address token);\n\n/// @notice Thrown when the price obtained is negative.\nerror PRICE_NEGATIVE(address token);\n\n/// @notice Thrown when the sequencer is offline\nerror SEQUENCER_DOWN(address sequencer);\n\n/// @notice Thrown when the grace period for a sequencer is not over yet.\nerror SEQUENCER_GRACE_PERIOD_NOT_OVER(address sequencer);\n\n/// @notice Thrown when the price deviation exceeds allowed limits.\nerror OUT_OF_DEVIATION_CAP(uint256 deviation);\n\n/// @notice Thrown when the number of sources exceeds the allowed length.\nerror EXCEED_SOURCE_LEN(uint256 length);\n\n/// @notice Thrown when no primary source is available for the token.\nerror NO_PRIMARY_SOURCE(address token);\n\n/// @notice Thrown when no valid price source is available for the token.\nerror NO_VALID_SOURCE(address token);\n\n/// @notice Thrown when the deviation value exceeds the threshold.\nerror EXCEED_DEVIATION();\n\n/// @notice Thrown when the mean price is below the acceptable threshold.\nerror TOO_LOW_MEAN(uint256 mean);\n\n/// @notice Thrown when no mean price is set for the token.\nerror NO_MEAN(address token);\n\n/// @notice Thrown when no stable pool exists for the token.\nerror NO_STABLEPOOL(address token);\n\n/// @notice Thrown when the price fetch process fails for a token.\nerror PRICE_FAILED(address token);\n\n/// @notice Thrown when the liquidation threshold is set too high.\nerror LIQ_THRESHOLD_TOO_HIGH(uint256 threshold);\n\n/// @notice Thrown when the liquidation threshold is set too low.\nerror LIQ_THRESHOLD_TOO_LOW(uint256 threshold);\n\n/// @notice Thrown when the oracle doesn't support a specific token.\nerror ORACLE_NOT_SUPPORT(address token);\n\n/// @notice Thrown when the oracle doesn't support a specific LP pair token.\nerror ORACLE_NOT_SUPPORT_LP(address lp);\n\n/// @notice Thrown when the oracle doesn't support a specific wToken.\nerror ORACLE_NOT_SUPPORT_WTOKEN(address wToken);\n\n/// @notice Thrown when there is no route to fetch data for the oracle\nerror NO_ORACLE_ROUTE(address token);\n\n/// @notice Thrown when a value is out of an acceptable range.\nerror VALUE_OUT_OF_RANGE();\n\n/// @notice Thrown when specified limits are incorrect.\nerror INCORRECT_LIMITS();\n\n/// @notice Thrown when Curve LP is already registered.\nerror CRV_LP_ALREADY_REGISTERED(address lp);\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                            GENERAL SPELL ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when the caller isn't recognized as a bank.\nerror NOT_BANK(address caller);\n\n/// @notice Thrown when refunding ETH encounters an issue.\nerror REFUND_ETH_FAILED(uint256 balance);\n\n/// @notice Thrown when a transaction isn't initiated by WETH.\nerror NOT_FROM_WETH(address from);\n\n/// @notice Thrown when the liquidity pool isn't whitelisted\nerror LP_NOT_WHITELISTED(address lp);\n\n/// @notice Thrown when the collateral doesn't exist for a strategy.\nerror COLLATERAL_NOT_EXIST(uint256 strategyId, address colToken);\n\n/// @notice Thrown when the strategy ID doesn't correspond to an existing strategy.\nerror STRATEGY_NOT_EXIST(address spell, uint256 strategyId);\n\n/// @notice Thrown when the position size exceeds maximum limits.\nerror EXCEED_MAX_POS_SIZE(uint256 strategyId);\n\n/// @notice Thrown when the position size is below minimum requirements.\nerror EXCEED_MIN_POS_SIZE(uint256 strategyId);\n\n/// @notice Thrown when the loan-to-value ratio exceeds allowed maximum.\nerror EXCEED_MAX_LTV();\n\n/// @notice Thrown when the strategy ID provided is incorrect.\nerror INCORRECT_STRATEGY_ID(uint256 strategyId);\n\n/// @notice Thrown when the position size is invalid.\nerror INVALID_POS_SIZE();\n\n/// @notice Thrown when an incorrect liquidity pool token is provided.\nerror INCORRECT_LP(address lpToken);\n\n/// @notice Thrown when an incorrect pool ID is provided.\nerror INCORRECT_PID(uint256 pid);\n\n/// @notice Thrown when an incorrect collateral token is provided.\nerror INCORRECT_COLTOKEN(address colToken);\n\n/// @notice Thrown when an incorrect underlying token is provided.\nerror INCORRECT_UNDERLYING(address uToken);\nerror INCORRECT_DEBT(address debtToken);\nerror NOT_FROM_UNIV3(address sender);\nerror SWAP_FAILED(address swapToken);\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                            CURVE SPELL ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when no gauge is present.\nerror NO_GAUGE();\n\n/// @notice Thrown when a gauge already exists for the provided pid and gid.\nerror EXISTING_GAUGE(uint256 pid, uint256 gid);\n\n/// @notice Thrown when no Curve pool is found for the given pid.\nerror NO_CURVE_POOL(uint256 pid);\n\n/// @notice Thrown when no LP has been registered.\nerror NO_LP_REGISTERED(address lp);\n\n\n/*//////////////////////////////////////////////////////////////////////////\n                                VAULT ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when borrowing from the vault fails.\nerror BORROW_FAILED(uint256 amount);\n\n/// @notice Thrown when repaying to the vault fails.\nerror REPAY_FAILED(uint256 amount);\n\n/// @notice Thrown when lending to the vault fails.\nerror LEND_FAILED(uint256 amount);\n\n/// @notice Thrown when redeeming from the vault fails.\nerror REDEEM_FAILED(uint256 amount);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                WRAPPER ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when an invalid token ID is provided.\nerror INVALID_TOKEN_ID(uint256 tokenId);\n\n/// @notice Thrown when an incorrect pool ID is provided.\nerror BAD_PID(uint256 pid);\n\n/// @notice Thrown when a mismatch in reward per share is detected.\nerror BAD_REWARD_PER_SHARE(uint256 rewardPerShare);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                BANK ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when a function is called without a required execution flag.\nerror NOT_UNDER_EXECUTION();\n\n/// @notice Thrown when a transaction isn't initiated \n/// by an externally owned account (EOA).\nerror NOT_EOA(address from);\n\n/// @notice Thrown when a transaction isn't initiated by the expected spell.\nerror NOT_FROM_SPELL(address from);\n\n/// @notice Thrown when the sender is not the owner of a given position ID.\nerror NOT_FROM_OWNER(uint256 positionId, address sender);\n\n\n/// @notice Thrown when a spell address isn't whitelisted.\nerror SPELL_NOT_WHITELISTED(address spell);\n\n/// @notice Thrown when a token isn't whitelisted.\nerror TOKEN_NOT_WHITELISTED(address token);\n\n/// @notice Thrown when a bank isn't listed for a given token.\nerror BANK_NOT_LISTED(address token);\n\n/// @notice Thrown when a bank is already listed for a given token.\nerror BANK_ALREADY_LISTED();\n\n/// @notice Thrown when the bank limit is reached.\nerror BANK_LIMIT();\n\n/// @notice Thrown when the BTOKEN is already added.\nerror BTOKEN_ALREADY_ADDED();\n\n/// @notice Thrown when the lending action isn't allowed.\nerror LEND_NOT_ALLOWED();\n\n/// @notice Thrown when the borrowing action isn't allowed.\nerror BORROW_NOT_ALLOWED();\n\n/// @notice Thrown when the repaying action isn't allowed.\nerror REPAY_NOT_ALLOWED();\n\n/// @notice Thrown when the redeeming action isn't allowed.\nerror WITHDRAW_LEND_NOT_ALLOWED();\n\n/// @notice Thrown when certain actions are locked.\nerror LOCKED();\n\n/// @notice Thrown when an action isn't executed.\nerror NOT_IN_EXEC();\n\n/// @notice Thrown when the repayment allowance hasn't been warmed up.\nerror REPAY_ALLOW_NOT_WARMED_UP();\n\n/// @notice Thrown when a different collateral type exists.\nerror DIFF_COL_EXIST(address collToken);\n\n/// @notice Thrown when a position is not eligible for liquidation.\nerror NOT_LIQUIDATABLE(uint256 positionId);\n\n/// @notice Thrown when a position is flagged as bad or invalid.\nerror BAD_POSITION(uint256 posId);\n\n/// @notice Thrown when collateral for a specific position is flagged as bad or invalid.\nerror BAD_COLLATERAL(uint256 positionId);\n\n/// @notice Thrown when there's insufficient collateral for an operation.\nerror INSUFFICIENT_COLLATERAL();\n\n/// @notice Thrown when an attempted repayment exceeds the actual debt.\nerror REPAY_EXCEEDS_DEBT(uint256 repay, uint256 debt);\n\n/// @notice Thrown when an invalid utility token is provided.\nerror INVALID_UTOKEN(address uToken);\n\n/// @notice Thrown when a borrow operation results in zero shares.\nerror BORROW_ZERO_SHARE(uint256 borrowAmount);\n\n/*//////////////////////////////////////////////////////////////////////////\n                            CONFIGURATION ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when slippage exceeds the allowed limit.\nerror EXCEED_SLIPPAGE(uint256 ratio);\n\n/// @notice Thrown when a certain ratio is too high for an operation.\nerror RATIO_TOO_HIGH(uint256 ratio);\n\n/// @notice Thrown when an invalid fee distribution is detected.\nerror INVALID_FEE_DISTRIBUTION();\n\n/// @notice Thrown when no treasury is set for fee distribution.\nerror NO_TREASURY_SET();\n\n/// @notice Thrown when a fee window has already started.\nerror FEE_WINDOW_ALREADY_STARTED();\n\n/// @notice Thrown when a fee window duration is too long.\nerror FEE_WINDOW_TOO_LONG(uint256 windowTime);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                UTILITY ERRORS\n//////////////////////////////////////////////////////////////////////////*/\n\n/// @notice Thrown when a cast operation fails.\nerror CAST();\n\n/// @notice Thrown when an operation has surpassed its deadline.\nerror EXPIRED(uint256 deadline);\n"
    },
    "contracts/utils/EnsureApprove.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\n/// @title EnsureApprove\n/// @notice Helper to ensure approvals are set correctly\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nabstract contract EnsureApprove {\n    /// @dev Reset approval to zero and then approve spender with amount\n    /// @param token Address of token to approve\n    /// @param spender Address to approve\n    /// @param amount Amount to approve\n    function _ensureApprove(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        IERC20(token).approve(spender, 0);\n        IERC20(token).approve(spender, amount);\n    }\n}\n"
    },
    "contracts/utils/ERC1155NaiveReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\n\n/// @title ERC1155NaiveReceiver\n/// @notice A receiver contract that naively accepts all ERC1155 transfers.\ncontract ERC1155NaiveReceiver is IERC1155Receiver {\n    /// @notice Handle the receipt of a single ERC1155 token type.\n    /// @dev This function is called at the end of a \n    /// `safeTransferFrom` after the balance has been updated.\n    function onERC1155Received(\n        address /* operator */,\n        address /* from */,\n        uint256 /* id */,\n        uint256 /* value */,\n        bytes calldata /* data */\n    ) external pure override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /// @notice Handle the receipt of multiple ERC1155 token types.\n    /// @dev This function is called at the end of a \n    /// `safeBatchTransferFrom` after the balances have been updated.\n    function onERC1155BatchReceived(\n        address /* operator */,\n        address /* from */,\n        uint256[] calldata /* ids */,\n        uint256[] calldata /* values */,\n        bytes calldata /* data */\n    ) external pure override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /// @notice Checks if the contract supports a given interface.\n    /// @dev Returns true if the interfaceId is 0x01ffc9a7 (IERC1155Receiver).\n    function supportsInterface(\n        bytes4 interfaceId\n    ) external view virtual override returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId;\n    }\n}\n"
    },
    "contracts/vault/HardVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IProtocolConfig.sol\";\nimport \"../interfaces/IHardVault.sol\";\n\n/// @title HardVault\n/// @notice The HardVault contract is used to lock LP tokens as collateral.\n///         This vault simply holds onto LP tokens deposited by users, serving as collateral storage.\n/// @dev The HardVault is an ERC1155 contract where each LP token is associated with a unique tokenId.\n///      The tokenId is derived from the LP token address. Only LP tokens listed by the Blueberry team\n///      can be used as collateral in this vault.\ncontract HardVault is\n    OwnableUpgradeable,\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    EnsureApprove,\n    IHardVault\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev address of protocol config\n    IProtocolConfig public config;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                    EVENTS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Emitted when a user deposits ERC20 tokens into the vault.\n    /// @param account Address of the user.\n    /// @param amount Amount of ERC20 tokens deposited.\n    /// @param shareAmount Amount of ERC1155 tokens minted.\n    event Deposited(\n        address indexed account,\n        uint256 amount,\n        uint256 shareAmount\n    );\n\n    /// @dev Emitted when a user withdraws ERC20 tokens from the vault.\n    /// @param account Address of the user.\n    /// @param amount Amount of ERC20 tokens withdrawn.\n    /// @param shareAmount Amount of ERC1155 tokens burned.\n    event Withdrawn(\n        address indexed account,\n        uint256 amount,\n        uint256 shareAmount\n    );\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the HardVault contract with protocol configuration.\n    /// @param _config Address of the protocol configuration.\n    function initialize(IProtocolConfig _config) external initializer {\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __ERC1155_init(\"HardVault\");\n\n        if (address(_config) == address(0)) revert Errors.ZERO_ADDRESS();\n        config = _config;\n    }\n\n    /// @dev Encodes a given ERC20 token address into a unique tokenId.\n    /// @param uToken Address of the ERC20 token.\n    /// @return TokenId representing the token.\n    function _encodeTokenId(address uToken) internal pure returns (uint) {\n        return uint256(uint160(uToken));\n    }\n\n    /// @dev Decodes a given tokenId back into the ERC20 token address.\n    /// @param tokenId The tokenId to decode.\n    /// @return Address of the corresponding ERC20 token.\n    function _decodeTokenId(uint tokenId) internal pure returns (address) {\n        return address(uint160(tokenId));\n    }\n\n    /// @notice Gets the balance of a specific ERC20 token for a user.\n    /// @param token Address of the ERC20 token.\n    /// @param user Address of the user.\n    /// @return Balance of the user for the given token.\n    function balanceOfERC20(\n        address token,\n        address user\n    ) external view override returns (uint256) {\n        return balanceOf(user, _encodeTokenId(token));\n    }\n\n    /// @notice Maps a tokenId to its underlying ERC20 token.\n    /// @param tokenId The tokenId to resolve.\n    /// @return token Address of the corresponding ERC20 token.\n    function getUnderlyingToken(\n        uint256 tokenId\n    ) external pure override returns (address token) {\n        token = _decodeTokenId(tokenId);\n        if (_encodeTokenId(token) != tokenId)\n            revert Errors.INVALID_TOKEN_ID(tokenId);\n    }\n\n    /// @notice Allows a user to deposit ERC20 tokens into the vault and mint corresponding ERC1155 tokens.\n    /// @dev Emits a {Deposited} event.\n    /// @param token The ERC20 token to deposit.\n    /// @param amount The amount of ERC20 tokens to deposit.\n    /// @return shareAmount The amount of ERC1155 tokens minted in return.\n    function deposit(\n        address token,\n        uint256 amount\n    ) external override nonReentrant returns (uint256 shareAmount) {\n        if (amount == 0) revert Errors.ZERO_AMOUNT();\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        uToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        shareAmount = uBalanceAfter - uBalanceBefore;\n        _mint(msg.sender, uint256(uint160(token)), shareAmount, \"\");\n\n        emit Deposited(msg.sender, amount, shareAmount);\n    }\n\n    /// @notice Allows a user to burn their ERC1155 tokens and withdraw the underlying ERC20 tokens.\n    /// @dev Emits a {Withdrawn} event.\n    /// @param token The ERC20 token to withdraw.\n    /// @param shareAmount The amount of ERC1155 tokens to burn.\n    /// @return withdrawAmount The amount of ERC20 tokens withdrawn.\n    function withdraw(\n        address token,\n        uint256 shareAmount\n    ) external override nonReentrant returns (uint256 withdrawAmount) {\n        if (shareAmount == 0) revert Errors.ZERO_AMOUNT();\n        IERC20Upgradeable uToken = IERC20Upgradeable(token);\n        _burn(msg.sender, _encodeTokenId(token), shareAmount);\n\n        /// Apply withdrawal fee if within the fee window (e.g., 2 months)\n        _ensureApprove(\n            address(uToken),\n            address(config.feeManager()),\n            shareAmount\n        );\n        withdrawAmount = config.feeManager().doCutVaultWithdrawFee(\n            address(uToken),\n            shareAmount\n        );\n        uToken.safeTransfer(msg.sender, withdrawAmount);\n\n        emit Withdrawn(msg.sender, withdrawAmount, shareAmount);\n    }\n}\n"
    },
    "contracts/vault/SoftVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IProtocolConfig.sol\";\nimport \"../interfaces/ISoftVault.sol\";\nimport \"../interfaces/compound/ICErc20.sol\";\n\n/// @author BlueberryProtocol\n/// @title Soft Vault\n/// @notice Soft Vault is a spot where users lend and borrow tokens from/to Blueberry Money Market.\n/// @dev SoftVault is communicating with bTokens to lend and borrow underlying tokens from/to Blueberry Money Market.\n///      Underlying tokens can be ERC20 tokens listed by Blueberry team, such as USDC, USDT, DAI, WETH, ...\ncontract SoftVault is\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    ReentrancyGuardUpgradeable,\n    EnsureApprove,\n    ISoftVault\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev address of bToken for underlying token\n    ICErc20 public bToken;\n    /// @dev address of underlying token\n    IERC20Upgradeable public uToken;\n    /// @dev address of protocol config\n    IProtocolConfig public config;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract\n    /// @param _config Address of protocol configuration\n    /// @param _bToken Address of bToken\n    /// @param _name ERC20 name for the SoftVault token\n    /// @param _symbol ERC20 symbol for the SoftVault token\n    function initialize(\n        IProtocolConfig _config,\n        ICErc20 _bToken,\n        string memory _name,\n        string memory _symbol\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __Ownable_init();\n        __ERC20_init(_name, _symbol);\n\n        if (address(_bToken) == address(0) || address(_config) == address(0))\n            revert Errors.ZERO_ADDRESS();\n\n        IERC20Upgradeable _uToken = IERC20Upgradeable(_bToken.underlying());\n        config = _config;\n        bToken = _bToken;\n        uToken = _uToken;\n    }\n\n    /// @dev Vault has same decimal as bToken, bToken has same decimal as underlyingToken\n    function decimals() public view override returns (uint8) {\n        return bToken.decimals();\n    }\n\n    /// @notice Deposit underlying assets on Blueberry Money Market and issue share token\n    /// @dev Emits a {Deposited} event.\n    /// @param amount Underlying token amount to deposit\n    /// @return shareAmount same as bToken amount received\n    function deposit(\n        uint256 amount\n    ) external override nonReentrant returns (uint256 shareAmount) {\n        if (amount == 0) revert Errors.ZERO_AMOUNT();\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        uToken.safeTransferFrom(msg.sender, address(this), amount);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        uint256 cBalanceBefore = bToken.balanceOf(address(this));\n        _ensureApprove(address(uToken), address(bToken), amount);\n        if (bToken.mint(uBalanceAfter - uBalanceBefore) != 0)\n            revert Errors.LEND_FAILED(amount);\n        uint256 cBalanceAfter = bToken.balanceOf(address(this));\n\n        shareAmount = cBalanceAfter - cBalanceBefore;\n        _mint(msg.sender, shareAmount);\n\n        emit Deposited(msg.sender, amount, shareAmount);\n    }\n\n    /// @notice Withdraw underlying assets from Blueberry Money Market\n    /// @dev Emits a {Withdrawn} event.\n    /// @dev It cuts vault withdraw fee when you withdraw within the vault withdraw window\n    /// @param shareAmount Amount of bTokens to redeem\n    /// @return withdrawAmount Amount of underlying assets withdrawn\n    function withdraw(\n        uint256 shareAmount\n    ) external override nonReentrant returns (uint256 withdrawAmount) {\n        if (shareAmount == 0) revert Errors.ZERO_AMOUNT();\n\n        _burn(msg.sender, shareAmount);\n\n        uint256 uBalanceBefore = uToken.balanceOf(address(this));\n        if (bToken.redeem(shareAmount) != 0)\n            revert Errors.REDEEM_FAILED(shareAmount);\n        uint256 uBalanceAfter = uToken.balanceOf(address(this));\n\n        withdrawAmount = uBalanceAfter - uBalanceBefore;\n        _ensureApprove(\n            address(uToken),\n            address(config.feeManager()),\n            withdrawAmount\n        );\n        withdrawAmount = config.feeManager().doCutVaultWithdrawFee(\n            address(uToken),\n            withdrawAmount\n        );\n        uToken.safeTransfer(msg.sender, withdrawAmount);\n\n        emit Withdrawn(msg.sender, withdrawAmount, shareAmount);\n    }\n}\n"
    },
    "contracts/wrapper/WAuraPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWAuraPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/aura/IAuraRewarder.sol\";\nimport \"../interfaces/aura/IAuraExtraRewarder.sol\";\nimport \"../interfaces/aura/IAura.sol\";\n\n/**\n * @title WAuraPools\n * @author BlueberryProtocol\n * @notice Wrapped Aura Pools is the wrapper of LP positions\n * @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n *      and do not generate yields. LP Tokens are identified by tokenIds\n *      encoded from lp token address.\n */\ncontract WAuraPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWAuraPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Aura Pools contract\n    IAuraPools public auraPools;\n    /// @dev Address to AURA token\n    IAura public AURA;\n    /// @dev Address to STASH_AURA token\n    address public STASH_AURA;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Aura extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    uint public REWARD_MULTIPLIER_DENOMINATOR;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes contract with dependencies\n    /// @param aura_ The AURA token address\n    /// @param auraPools_ The auraPools contract address\n    /// @param stash_aura_ The stash for AURA\n    function initialize(\n        address aura_,\n        address auraPools_,\n        address stash_aura_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WAuraPools\");\n        AURA = IAura(aura_);\n        STASH_AURA = stash_aura_;\n        auraPools = IAuraPools(auraPools_);\n        REWARD_MULTIPLIER_DENOMINATOR = auraPools\n            .REWARD_MULTIPLIER_DENOMINATOR();\n    }\n\n    /// @notice Encodes pool id and AURA per share into an ERC1155 token id\n    /// @param pid The pool id (The first 16-bits)\n    /// @param auraPerShare Amount of AURA per share, multiplied by 1e18 (The last 240-bits)\n    /// @return id The resulting ERC1155 token id\n\n    function encodeId(\n        uint256 pid,\n        uint256 auraPerShare\n    ) public pure returns (uint256 id) {\n        // Ensure the pool id and auraPerShare are within expected bounds\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (auraPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(auraPerShare);\n        return (pid << 240) | auraPerShare;\n    }\n\n    /// @notice Decodes ERC1155 token id to pool id and AURA per share\n    /// @param id The ERC1155 token id\n    /// @return gid The decoded pool id\n    /// @return auraPerShare The decoded amount of AURA per share\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 auraPerShare) {\n        gid = id >> 240; // Extracting the first 16 bits\n        auraPerShare = id & ((1 << 240) - 1); // Extracting the last 240 bits\n    }\n\n    /// @notice Retrieves the underlying ERC20 token of the specified ERC1155 token id\n    /// @param id The ERC1155 token id\n    /// @return uToken Address of the underlying ERC20 token\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Gets the Balancer vault for a given BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Vault associated with the provided BPT token\n    function getVault(address bpt) public view returns (IBalancerVault) {\n        return IBalancerVault(IBalancerPool(bpt).getVault());\n    }\n\n    /// @notice Retrieves pool tokens from a given BPT address\n    /// @param bpt Address of the BPT token\n    /// @return tokens Array of token addresses in the pool\n    /// @return balances Corresponding balances of the tokens in the pool\n    /// @return lastChangedBlock The last block when the pool composition changed\n    function getPoolTokens(\n        address bpt\n    )\n        external\n        view\n        returns (\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256 lastChangedBlock\n        )\n    {\n        return getVault(bpt).getPoolTokens(IBalancerPool(bpt).getPoolId());\n    }\n\n    /// @notice Retrieves pool id from a BPT token\n    /// @param bpt Address of the BPT token\n    /// @return Pool id associated with the BPT token\n    function getBPTPoolId(address bpt) public view returns (bytes32) {\n        return IBalancerPool(bpt).getPoolId();\n    }\n\n    /// @notice Fetches pool information using a provided aura finance pool id\n    /// @param pid The aura finance pool id\n    /// @return lptoken Address of the LP token\n    /// @return token Address of the associated token\n    /// @return gauge Address of the gauge\n    /// @return auraRewards Address for AURA rewards\n    /// @return stash Address of the stash\n    /// @return shutdown Boolean indicating if the pool is shut down\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address auraRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return auraPools.poolInfo(pid);\n    }\n\n    /// @notice Calculate the amount of pending reward for a given LP amount.\n    /// @param stRewardPerShare The stored reward per share value.\n    /// @param rewarder The address of the rewarder contract.\n    /// @param amount The amount of LP for which reward is being calculated.\n    /// @param lpDecimals The number of decimals of the LP token.\n    /// @return rewards The calculated reward amount.\n    function _getPendingReward(\n        uint256 stRewardPerShare,\n        address rewarder,\n        uint256 amount,\n        uint256 lpDecimals\n    ) internal view returns (uint256 rewards) {\n        /// Retrieve current reward per token from rewarder\n        uint256 enRewardPerShare = IAuraRewarder(rewarder).rewardPerToken();\n        /// Calculatethe difference in reward per share\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        /// Calculate the total rewards base on share and amount.\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// @notice  Calculate the pending AURA reward amount.\n    /// @dev AuraMinter can mint additional tokens after `inflationProtectionTime` has passed\n    /// And its value is `1749120350`  ==> Thursday 5 June 2025 12:32:30 PM GMT+07:00\n    /// @param auraRewarder Address of Aura rewarder contract\n    /// @param balAmount The amount of BAL reward for AURA calculation.\n    /// @dev AURA token is minted in booster contract following the mint logic in the below\n    function _getAuraPendingReward(\n        address auraRewarder,\n        uint256 balAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// AURA mint request amount = amount * reward_multiplier / reward_multiplier_denominator\n        uint256 mintRequestAmount = (balAmount *\n            auraPools.getRewardMultipliers(auraRewarder)) /\n            REWARD_MULTIPLIER_DENOMINATOR;\n\n        /// AURA token mint logic\n        /// e.g. emissionsMinted = 6e25 - 5e25 - 0 = 1e25;\n        uint256 totalSupply = AURA.totalSupply();\n        uint256 initAmount = AURA.INIT_MINT_AMOUNT();\n        uint256 minterMinted;\n        uint256 reductionPerCliff = AURA.reductionPerCliff();\n        uint256 totalCliffs = AURA.totalCliffs();\n        uint256 emissionMaxSupply = AURA.EMISSIONS_MAX_SUPPLY();\n\n        uint256 emissionsMinted = totalSupply - initAmount - minterMinted;\n        /// e.g. reductionPerCliff = 5e25 / 500 = 1e23\n        /// e.g. cliff = 1e25 / 1e23 = 100\n        uint256 cliff = emissionsMinted / reductionPerCliff;\n\n        /// e.g. 100 < 500\n        if (cliff < totalCliffs) {\n            /// e.g. (new) reduction = (500 - 100) * 2.5 + 700 = 1700;\n            /// e.g. (new) reduction = (500 - 250) * 2.5 + 700 = 1325;\n            /// e.g. (new) reduction = (500 - 400) * 2.5 + 700 = 950;\n            uint256 reduction = ((totalCliffs - cliff) * 5) / 2 + 700;\n            /// e.g. (new) amount = 1e19 * 1700 / 500 =  34e18;\n            /// e.g. (new) amount = 1e19 * 1325 / 500 =  26.5e18;\n            /// e.g. (new) amount = 1e19 * 950 / 500  =  19e17;\n            mintAmount = (mintRequestAmount * reduction) / totalCliffs;\n\n            /// e.g. amtTillMax = 5e25 - 1e25 = 4e25\n            uint256 amtTillMax = emissionMaxSupply - emissionsMinted;\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// @notice Retrieve pending rewards for a given tokenId and amount.\n    /// @dev The rewards can be split among multiple tokens.\n    /// @param tokenId The ID of the token.\n    /// @param amount The amount of the token.\n    /// @return tokens Array of token addresses.\n    /// @return rewards Array of corresponding reward amounts.\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stAuraPerShare) = decodeId(tokenId);\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint256 extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// BAL reward\n        tokens[0] = IAuraRewarder(auraRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stAuraPerShare,\n            auraRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// AURA reward\n        tokens[1] = address(AURA);\n        rewards[1] = _getAuraPendingReward(auraRewarder, rewards[0]);\n\n        /// Additional rewards\n        for (uint256 i; i != extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IAuraRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Mint an ERC1155 token corresponding to the provided LP token amount.\n    /// @param pid The ID of the AURA pool.\n    /// @param amount The amount of the LP token to be wrapped.\n    /// @return id The minted ERC1155 token's ID.\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(auraPools), amount);\n        auraPools.deposit(pid, amount, true);\n\n        /// BAL reward handle logic\n        uint256 balRewardPerToken = IAuraRewarder(auraRewarder)\n            .rewardPerToken();\n        id = encodeId(pid, balRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n\n        /// Store extra rewards info\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n        for (uint256 i; i != extraRewardsCount; ) {\n            address extraRewarder = IAuraRewarder(auraRewarder).extraRewards(i);\n            uint256 rewardPerToken = IAuraRewarder(extraRewarder)\n                .rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Burn the provided ERC1155 token and redeem its underlying ERC20 token.\n    /// @param id The ID of the ERC1155 token to burn.\n    /// @param amount The amount of the ERC1155 token to burn.\n    /// @return rewardTokens An array of reward tokens that the user is eligible to receive.\n    /// @return rewards The corresponding amounts of reward tokens.\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address auraRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n\n        /// Claim Rewards\n        IAuraRewarder(auraRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        auraPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint256 extraRewardsCount = IAuraRewarder(auraRewarder)\n            .extraRewardsLength();\n\n        for (uint256 i; i != extraRewardsCount; ) {\n            _syncExtraReward(IAuraRewarder(auraRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint256 i; i != storedExtraRewardLength; ) {\n                IAuraExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint256 rewardTokensLength = rewardTokens.length;\n        for (uint256 i; i != rewardTokensLength; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Get the full set of extra rewards.\n    /// @return An array containing the addresses of extra reward tokens.\n    function extraRewardsLength() external view returns (uint256) {\n        return extraRewards.length;\n    }\n\n    /// @notice Internal function to sync any extra rewards with the contract.\n    /// @param extraReward The address of the extra reward token.\n    /// @dev Adds the extra reward to the internal list if not already present.\n    function _syncExtraReward(address extraReward) private {\n        if (extraRewardsIdx[extraReward] == 0) {\n            extraRewards.push(extraReward);\n            extraRewardsIdx[extraReward] = extraRewards.length;\n        }\n    }\n}\n"
    },
    "contracts/wrapper/WConvexPools.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IWConvexPools.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/convex/IRewarder.sol\";\nimport \"../interfaces/convex/ICvxExtraRewarder.sol\";\nimport \"../interfaces/convex/IConvex.sol\";\n\n/// @title WConvexPools\n/// @author BlueberryProtocol\n/// @notice Wrapped Convex Pools is the wrapper of LP positions.\n/// @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank\n///      and do not generate yields. LP Tokens are identified by tokenIds\n///      encoded from lp token address.\ncontract WConvexPools is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWConvexPools\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Address to Convex Pools contract\n    ICvxPools public cvxPools;\n    /// @dev Address to CVX token\n    IConvex public CVX;\n    /// @dev Mapping from token id to accExtPerShare\n    mapping(uint256 => mapping(address => uint256)) public accExtPerShare;\n    /// @dev Extra rewards addresses\n    address[] public extraRewards;\n    /// @dev The index of extra rewards\n    mapping(address => uint256) public extraRewardsIdx;\n\n    /// @dev Initialize the smart contract references.\n    /// @param cvx_ Address of the CVX token.\n    /// @param cvxPools_ Address of the Convex Pools.\n    function initialize(address cvx_, address cvxPools_) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WConvexPools\");\n        CVX = IConvex(cvx_);\n        cvxPools = ICvxPools(cvxPools_);\n    }\n\n    /// @notice Encode pid and cvxPerShare into an ERC1155 token id.\n    /// @param pid Pool id which is the first 16 bits.\n    /// @param cvxPerShare CVX amount per share, which should be multiplied by 1e18 and is the last 240 bits.\n    /// @return id The encoded token id.\n    function encodeId(\n        uint256 pid,\n        uint256 cvxPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (cvxPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(cvxPerShare);\n        return (pid << 240) | cvxPerShare;\n    }\n\n    /// @notice Decode an ERC1155 token id into its pid and cvxPerShare components.\n    /// @param id Token id.\n    /// @return pid The decoded pool id.\n    /// @return cvxPerShare The decoded CVX amount per share.\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 pid, uint256 cvxPerShare) {\n        pid = id >> 240; // Extract the first 16 bits\n        cvxPerShare = id & ((1 << 240) - 1); // Extract the last 240 bits\n    }\n\n    /// @notice Fetch the underlying ERC20 token of the given ERC1155 token id.\n    /// @param id Token id.\n    /// @return uToken Address of the underlying ERC20 token.\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address uToken) {\n        (uint256 pid, ) = decodeId(id);\n        (uToken, , , , , ) = getPoolInfoFromPoolId(pid);\n    }\n\n    /// @notice Fetch pool information from the Convex Booster.\n    /// @param pid Convex pool id.\n    /// @return lptoken Address of the liquidity provider token.\n    /// @return token Address of the reward token.\n    /// @return gauge Address of the gauge contract.\n    /// @return crvRewards Address of the Curve rewards contract.\n    /// @return stash Address of the stash contract.\n    /// @return shutdown Indicates if the pool is shutdown.\n    function getPoolInfoFromPoolId(\n        uint256 pid\n    )\n        public\n        view\n        returns (\n            address lptoken,\n            address token,\n            address gauge,\n            address crvRewards,\n            address stash,\n            bool shutdown\n        )\n    {\n        return cvxPools.poolInfo(pid);\n    }\n\n    /// @notice Get pending reward amount\n    /// @param stRewardPerShare reward per share\n    /// @param rewarder Address of rewarder contract\n    /// @param amount lp amount\n    /// @param lpDecimals lp decimals\n    function _getPendingReward(\n        uint stRewardPerShare,\n        address rewarder,\n        uint amount,\n        uint lpDecimals\n    ) internal view returns (uint rewards) {\n        uint256 enRewardPerShare = IRewarder(rewarder).rewardPerToken();\n        uint256 share = enRewardPerShare > stRewardPerShare\n            ? enRewardPerShare - stRewardPerShare\n            : 0;\n        rewards = (share * amount) / (10 ** lpDecimals);\n    }\n\n    /// Calculates the CVX pending reward based on CRV reward\n    /// @param crvAmount Amount of CRV reward\n    /// @return mintAmount The pending CVX reward\n    function _getCvxPendingReward(\n        uint256 crvAmount\n    ) internal view returns (uint256 mintAmount) {\n        /// CVX token mint logic\n        uint256 totalCliffs = CVX.totalCliffs();\n        uint256 totalSupply = CVX.totalSupply();\n        uint256 maxSupply = CVX.maxSupply();\n        uint256 reductionPerCliff = CVX.reductionPerCliff();\n        uint256 cliff = totalSupply / reductionPerCliff;\n\n        if (totalSupply == 0) {\n            mintAmount = crvAmount;\n        }\n\n        if (cliff < totalCliffs) {\n            uint256 reduction = totalCliffs - cliff;\n            mintAmount = (crvAmount * reduction) / totalCliffs;\n            uint256 amtTillMax = maxSupply - totalSupply;\n\n            if (mintAmount > amtTillMax) {\n                mintAmount = amtTillMax;\n            }\n        }\n    }\n\n    /// Returns pending rewards from the farming pool\n    /// @param tokenId Token Id\n    /// @param amount Amount of share\n    /// @return tokens An array of token addresses for rewards\n    /// @return rewards An array of pending rewards corresponding to the tokens\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stCrvPerShare) = decodeId(tokenId);\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        uint256 lpDecimals = IERC20MetadataUpgradeable(lpToken).decimals();\n        uint extraRewardsCount = extraRewards.length;\n        tokens = new address[](extraRewardsCount + 2);\n        rewards = new uint256[](extraRewardsCount + 2);\n\n        /// CRV reward\n        tokens[0] = IRewarder(cvxRewarder).rewardToken();\n        rewards[0] = _getPendingReward(\n            stCrvPerShare,\n            cvxRewarder,\n            amount,\n            lpDecimals\n        );\n\n        /// CVX reward\n        tokens[1] = address(CVX);\n        rewards[1] = _getCvxPendingReward(rewards[0]);\n\n        for (uint i = 0; i < extraRewardsCount; ) {\n            address rewarder = extraRewards[i];\n            uint256 stRewardPerShare = accExtPerShare[tokenId][rewarder];\n            tokens[i + 2] = IRewarder(rewarder).rewardToken();\n            if (stRewardPerShare == 0) {\n                rewards[i + 2] = 0;\n            } else {\n                rewards[i + 2] = _getPendingReward(\n                    stRewardPerShare == type(uint).max ? 0 : stRewardPerShare,\n                    rewarder,\n                    amount,\n                    lpDecimals\n                );\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Mints ERC1155 token for the given LP token\n    /// @param pid Convex Pool id\n    /// @param amount Token amount to wrap\n    /// @return id The minted token ID\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256 id) {\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(cvxPools), amount);\n        cvxPools.deposit(pid, amount, true);\n\n        uint256 crvRewardPerToken = IRewarder(cvxRewarder).rewardPerToken();\n        id = encodeId(pid, crvRewardPerToken);\n        _mint(msg.sender, id, amount, \"\");\n        /// Store extra rewards info\n        uint extraRewardsCount = IRewarder(cvxRewarder).extraRewardsLength();\n        for (uint i; i < extraRewardsCount; ) {\n            address extraRewarder = IRewarder(cvxRewarder).extraRewards(i);\n            uint rewardPerToken = IRewarder(extraRewarder).rewardPerToken();\n            accExtPerShare[id][extraRewarder] = rewardPerToken == 0\n                ? type(uint).max\n                : rewardPerToken;\n\n            _syncExtraReward(extraRewarder);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Burns ERC1155 token to redeem ERC20 token back and harvest rewards\n    /// @param id Token id to burn\n    /// @param amount Token amount to burn\n    /// @return rewardTokens The array of reward token addresses\n    /// @return rewards The array of harvested reward amounts\n    function burn(\n        uint256 id,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        returns (address[] memory rewardTokens, uint256[] memory rewards)\n    {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        (address lpToken, , , address cvxRewarder, , ) = getPoolInfoFromPoolId(\n            pid\n        );\n        /// Claim Rewards\n        IRewarder(cvxRewarder).withdraw(amount, true);\n        /// Withdraw LP\n        cvxPools.withdraw(pid, amount);\n\n        /// Transfer LP Tokens\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        uint extraRewardsCount = IRewarder(cvxRewarder).extraRewardsLength();\n\n        for (uint i; i < extraRewardsCount; ) {\n            _syncExtraReward(IRewarder(cvxRewarder).extraRewards(i));\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint storedExtraRewardLength = extraRewards.length;\n        bool hasDiffExtraRewards = extraRewardsCount != storedExtraRewardLength;\n\n        /// Transfer Reward Tokens\n        (rewardTokens, rewards) = pendingRewards(id, amount);\n\n        /// Withdraw manually\n        if (hasDiffExtraRewards) {\n            for (uint i; i < storedExtraRewardLength; ) {\n                ICvxExtraRewarder(extraRewards[i]).getReward();\n\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        uint rewardLen = rewardTokens.length;\n        for (uint i; i < rewardLen; ) {\n            IERC20Upgradeable(rewardTokens[i]).safeTransfer(\n                msg.sender,\n                rewards[i]\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// Gets the length of the extra rewards array\n    /// @return Length of the extra rewards array\n    function extraRewardsLength() external view returns (uint) {\n        return extraRewards.length;\n    }\n\n    /// Internal function to synchronize extra rewards\n    function _syncExtraReward(address extraReward) private {\n        if (extraRewardsIdx[extraReward] == 0) {\n            extraRewards.push(extraReward);\n            extraRewardsIdx[extraReward] = extraRewards.length;\n        }\n    }\n}\n"
    },
    "contracts/wrapper/WCurveGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/IWCurveGauge.sol\";\nimport \"../interfaces/curve/ILiquidityGauge.sol\";\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     INTERFACE\n    //////////////////////////////////////////////////////////////////////////*/\ninterface ILiquidityGaugeMinter {\n    function mint(address gauge) external;\n}\n\n/// @title WCurveGauge - Wrapper for Curve Gauge Positions.\n/// @author BlueberryProtocol\n/// @notice This contract allows for wrapping of Gauge positions into a custom ERC1155 token.\n/// @dev LP Tokens are identified by tokenIds, which are encoded from the LP token address.\n///      This contract assumes leveraged LP Tokens are held in the BlueberryBank and do not generate yields.\ncontract WCurveGauge is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    EnsureApprove,\n    IERC20Wrapper,\n    IWCurveGauge\n{\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @dev Address of Curve Registry\n    ICurveRegistry public registry;\n    /// @dev Address of Curve Gauge Controller\n    ICurveGaugeController public gaugeController;\n    /// @dev Address of CRV token\n    IERC20Upgradeable public CRV;\n    /// Mapping to keep track of accumulated CRV per share for each gauge.\n    mapping(uint256 => uint256) public accCrvPerShares;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Initializes the contract with provided addresses.\n    /// @param crv_ Address of the CRV token.\n    /// @param crvRegistry_ Address of the Curve Registry.\n    /// @param gaugeController_ Address of the Gauge Controller.\n    function initialize(\n        address crv_,\n        address crvRegistry_,\n        address gaugeController_\n    ) external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WCurveGauge\");\n        CRV = IERC20Upgradeable(crv_);\n        registry = ICurveRegistry(crvRegistry_);\n        gaugeController = ICurveGaugeController(gaugeController_);\n    }\n\n    /// @notice Encode pool id and CRV amount per share into a unique ERC1155 token id.\n    /// @param pid Pool id (the first 16-bit).\n    /// @param crvPerShare CRV amount per share (multiplied by 1e18 - for the last 240 bits).\n    /// @return id The unique token id.\n    function encodeId(\n        uint256 pid,\n        uint256 crvPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (crvPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(crvPerShare);\n        return (pid << 240) | crvPerShare;\n    }\n\n    /// @notice Decode an ERC1155 token id into its components: pool id and CRV per share.\n    /// @param id Unique token id.\n    /// @return gid The pool id.\n    /// @return crvPerShare The CRV amount per share.\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 gid, uint256 crvPerShare) {\n        gid = id >> 240; // Extracting the first 16 bits\n        crvPerShare = id & ((1 << 240) - 1); // Extracting the last 240 bits\n    }\n\n    /// @notice Get the underlying ERC20 token for a given ERC1155 token id.\n    /// @param id The ERC1155 token id.\n    /// @return Address of the underlying ERC20 token.\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address) {\n        (uint256 gid, ) = decodeId(id);\n        return getLpFromGaugeId(gid);\n    }\n\n    /// @notice Given a gauge id, fetch the associated LP token.\n    /// @param gid The gauge id.\n    /// @return Address of the LP token.\n    function getLpFromGaugeId(uint256 gid) public view returns (address) {\n        return ILiquidityGauge(gaugeController.gauges(gid)).lp_token();\n    }\n\n    /// @notice Calculate pending rewards for a given ERC1155 token amount.\n    /// @param tokenId Token id.\n    /// @param amount Amount of tokens.\n    /// @return tokens Addresses of reward tokens.\n    /// @return rewards Amounts of rewards corresponding to each token.\n    function pendingRewards(\n        uint256 tokenId,\n        uint256 amount\n    )\n        public\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 gid, uint256 stCrvPerShare) = decodeId(tokenId);\n\n        ILiquidityGauge gauge = ILiquidityGauge(gaugeController.gauges(gid));\n        uint256 claimableCrv = gauge.claimable_tokens(address(this));\n        uint256 supply = gauge.balanceOf(address(this));\n        uint256 enCrvPerShare = accCrvPerShares[gid] +\n            ((claimableCrv * 1e18) / supply);\n\n        uint256 crvRewards = enCrvPerShare > stCrvPerShare\n            ? ((enCrvPerShare - stCrvPerShare) * amount) / 1e18\n            : 0;\n\n        tokens = new address[](1);\n        rewards = new uint256[](1);\n        tokens[0] = address(CRV);\n        rewards[0] = crvRewards;\n    }\n\n    /// @notice Wrap an LP token into an ERC1155 token.\n    /// @param gid Gauge id.\n    /// @param amount Amount of LP tokens to wrap.\n    /// @return id The resulting ERC1155 token id.\n    function mint(\n        uint256 gid,\n        uint256 amount\n    ) external nonReentrant returns (uint256) {\n        ILiquidityGauge gauge = ILiquidityGauge(gaugeController.gauges(gid));\n        if (address(gauge) == address(0)) revert Errors.NO_GAUGE();\n\n        _mintCrv(gauge, gid);\n        IERC20Upgradeable lpToken = IERC20Upgradeable(gauge.lp_token());\n        lpToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        _ensureApprove(address(lpToken), address(gauge), amount);\n        gauge.deposit(amount);\n\n        uint256 id = encodeId(gid, accCrvPerShares[gid]);\n        _mint(msg.sender, id, amount, \"\");\n        return id;\n    }\n\n    /// @notice Unwrap an ERC1155 token back into its underlying LP token.\n    /// @param id ERC1155 token id.\n    /// @param amount Amount of ERC1155 tokens to unwrap.\n    /// @return rewards CRV rewards earned during the period the LP token was wrapped.\n    function burn(\n        uint256 id,\n        uint256 amount\n    ) external nonReentrant returns (uint256 rewards) {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 gid, uint256 stCrvPerShare) = decodeId(id);\n        _burn(msg.sender, id, amount);\n        ILiquidityGauge gauge = ILiquidityGauge(gaugeController.gauges(gid));\n        require(address(gauge) != address(0), \"gauge not registered\");\n        _mintCrv(gauge, gid);\n        gauge.withdraw(amount);\n        IERC20Upgradeable(gauge.lp_token()).safeTransfer(msg.sender, amount);\n        uint256 stCrv = (stCrvPerShare * amount) / 1e18;\n        uint256 enCrv = (accCrvPerShares[gid] * amount) / 1e18;\n        if (enCrv > stCrv) {\n            rewards = enCrv - stCrv;\n            CRV.safeTransfer(msg.sender, rewards);\n        }\n        return rewards;\n    }\n\n    /// @dev Internal function to mint CRV rewards for a curve gauge.\n    /// @param gauge Curve gauge to mint rewards for.\n    /// @param gid Gauge id.\n    function _mintCrv(ILiquidityGauge gauge, uint256 gid) internal {\n        uint256 balanceBefore = CRV.balanceOf(address(this));\n        ILiquidityGaugeMinter(gauge.minter()).mint(address(gauge));\n        uint256 balanceAfter = CRV.balanceOf(address(this));\n        uint256 gain = balanceAfter - balanceBefore;\n        uint256 supply = gauge.balanceOf(address(this));\n        if (gain > 0 && supply > 0) {\n            accCrvPerShares[gid] += (gain * 1e18) / supply;\n        }\n    }\n}\n"
    },
    "contracts/wrapper/WERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../interfaces/IWERC20.sol\";\n\n/// @title WERC20\n/// @author BlueberryProtocol\n/// @notice Wrapped ERC20 is the wrapper of LP positions\n/// @dev Leveraged LP Tokens will be wrapped here and be held in BlueberryBank and do not generate yields.\n///      LP Tokens are identified by tokenIds encoded from lp token address\ncontract WERC20 is ERC1155Upgradeable, ReentrancyGuardUpgradeable, IWERC20 {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    ///@notice Initializes the ERC1155 and ReentrancyGuard base contracts.\n    function initialize() external initializer {\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WERC20\");\n    }\n\n    /// @dev Encodes a given ERC20 token address into a unique tokenId for ERC1155.\n    /// @param uToken The address of the ERC20 token.\n    /// @return The unique tokenId.\n    function _encodeTokenId(address uToken) internal pure returns (uint) {\n        return uint256(uint160(uToken));\n    }\n\n    /// @dev Decodes a given tokenId back into its corresponding ERC20 token address.\n    /// @param tokenId The tokenId to decode.\n    /// @return The decoded ERC20 token address.\n    function _decodeTokenId(uint tokenId) internal pure returns (address) {\n        return address(uint160(tokenId));\n    }\n\n    /// @notice Fetches the underlying ERC20 token address for a given ERC1155 tokenId.\n    /// @param tokenId The tokenId of the wrapped ERC20.\n    /// @return token The underlying ERC20 token address.\n    function getUnderlyingToken(\n        uint256 tokenId\n    ) external pure override returns (address token) {\n        token = _decodeTokenId(tokenId);\n        if (_encodeTokenId(token) != tokenId)\n            revert Errors.INVALID_TOKEN_ID(tokenId);\n    }\n\n    /// @notice Retrieves pending rewards from the farming pool for a given tokenId.\n    /// @dev Reward tokens can be multiple types.\n    /// @param tokenId The tokenId to check rewards for.\n    /// @param amount The amount of share.\n    /// @return The list of reward addresses and their corresponding amounts.\n    function pendingRewards(\n        uint256 tokenId,\n        uint amount\n    ) public view override returns (address[] memory, uint256[] memory) {}\n\n    /// @notice Fetches the balance of the underlying ERC20 token for a specific user.\n    /// @param token The ERC20 token address.\n    /// @param user The user's address.\n    /// @return The user's balance of the specified ERC20 token.\n    function balanceOfERC20(\n        address token,\n        address user\n    ) external view override returns (uint256) {\n        return balanceOf(user, _encodeTokenId(token));\n    }\n\n    /// @notice Allows users to wrap their ERC20 tokens into the corresponding ERC1155 tokenId.\n    /// @param token The address of the ERC20 token to wrap.\n    /// @param amount The amount of the ERC20 token to wrap.\n    /// @return id The tokenId of the wrapped ERC20 token.\n    function mint(\n        address token,\n        uint256 amount\n    ) external override nonReentrant returns (uint256 id) {\n        uint256 balanceBefore = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        IERC20Upgradeable(token).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        uint256 balanceAfter = IERC20Upgradeable(token).balanceOf(\n            address(this)\n        );\n        id = _encodeTokenId(token);\n        _mint(msg.sender, id, balanceAfter - balanceBefore, \"\");\n    }\n\n    /// @notice Allows users to burn their ERC1155 token to retrieve the original ERC20 tokens.\n    /// @param token The address of the ERC20 token to unwrap.\n    /// @param amount The amount of the ERC20 token to unwrap.\n    function burn(\n        address token,\n        uint256 amount\n    ) external override nonReentrant {\n        _burn(msg.sender, _encodeTokenId(token), amount);\n        IERC20Upgradeable(token).safeTransfer(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/wrapper/WIchiFarm.sol": {
      "content": "// SPDX-License-Identifier: MIT\n/*\n               \n         \n             \n              \n       \n           \n*/\n\npragma solidity 0.8.16;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../utils/BlueBerryErrors.sol\" as Errors;\nimport \"../utils/EnsureApprove.sol\";\nimport \"../libraries/BBMath.sol\";\nimport \"../interfaces/IWIchiFarm.sol\";\nimport \"../interfaces/IERC20Wrapper.sol\";\nimport \"../interfaces/ichi/IIchiV2.sol\";\nimport \"../interfaces/ichi/IIchiFarm.sol\";\n\n/// @title WIchiFarm\n/// @author BlueberryProtocol\n/// @notice Wrapped IchiFarm is the wrapper of ICHI MasterChef\n/// @dev Leveraged ICHI Lp Tokens will be wrapped here and be held in BlueberryBank.\n///      At the same time, Underlying LPs will be deposited to ICHI farming pools and generate yields\n///      LP Tokens are identified by tokenIds encoded from lp token address and accPerShare of deposited time\ncontract WIchiFarm is\n    ERC1155Upgradeable,\n    ReentrancyGuardUpgradeable,\n    EnsureApprove,\n    OwnableUpgradeable,\n    IERC20Wrapper,\n    IWIchiFarm\n{\n    using BBMath for uint256;\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n    using SafeERC20Upgradeable for IIchiV2;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                   PUBLIC STORAGE\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev address of legacy ICHI token\n    IERC20Upgradeable public ICHIv1;\n    /// @dev address of ICHI v2\n    IIchiV2 public ICHI;\n    /// @dev address of ICHI farming contract\n    IIchiFarm public ichiFarm;\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                     CONSTRUCTOR\n    //////////////////////////////////////////////////////////////////////////*/\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////\n                                      FUNCTIONS\n    //////////////////////////////////////////////////////////////////////////*/\n\n    /// @dev Initializes the contract with the given ICHI token addresses.\n    /// @param ichi_ Address of ICHI v2 token.\n    /// @param ichiV1 Address of legacy ICHI token.\n    /// @param ichiFarm_ Address of ICHI farming contract.\n    function initialize(\n        address ichi_,\n        address ichiV1,\n        address ichiFarm_\n    ) external initializer {\n        if (\n            address(ichi_) == address(0) ||\n            address(ichiV1) == address(0) ||\n            address(ichiFarm_) == address(0)\n        ) revert Errors.ZERO_ADDRESS();\n        __ReentrancyGuard_init();\n        __ERC1155_init(\"WIchiFarm\");\n        ICHI = IIchiV2(ichi_);\n        ICHIv1 = IERC20Upgradeable(ichiV1);\n        ichiFarm = IIchiFarm(ichiFarm_);\n    }\n\n    /// @notice Encodes the provided pool ID and ichiPerShare value into a single 256-bit ERC1155 token ID.\n    /// The token ID is structured as follows:\n    /// - The first 16 bits store the pool ID.\n    /// - The remaining 240 bits store the ichiPerShare value.\n    /// @param pid The pool ID to encode. Must be representable in 16 bits.\n    /// @param ichiPerShare Ichi amount per share, multiplied by 1e18. Must be representable in 240-bits.\n    /// @return id The ERC1155 token id that gets minted.\n    function encodeId(\n        uint256 pid,\n        uint256 ichiPerShare\n    ) public pure returns (uint256 id) {\n        if (pid >= (1 << 16)) revert Errors.BAD_PID(pid);\n        if (ichiPerShare >= (1 << 240))\n            revert Errors.BAD_REWARD_PER_SHARE(ichiPerShare);\n        return (pid << 240) | ichiPerShare;\n    }\n\n    /// @notice Decodes the provided ERC1155 token ID into its constituent pool ID and ichiPerShare value.\n    /// The token ID is structured as follows:\n    /// - The first 16 bits store the pool ID.\n    /// - The remaining 240 bits store the ichiPerShare value.\n    /// @param id The ERC1155 token ID to decode.\n    /// @return pid The extracted pool ID (first 16 bits of the token ID) \n    /// @return ichiPerShare The extracted ichiPerShare value (last 240 bits of the token ID).\n    function decodeId(\n        uint256 id\n    ) public pure returns (uint256 pid, uint256 ichiPerShare) {\n        pid = id >> 240; // First 16 bits\n        ichiPerShare = id & ((1 << 240) - 1); // Last 240 bits\n    }\n\n    /// @notice Return the underlying ERC-20 for the given ERC-1155 token id.\n    /// @param id Token id\n    function getUnderlyingToken(\n        uint256 id\n    ) external view override returns (address) {\n        (uint256 pid, ) = decodeId(id);\n        return ichiFarm.lpToken(pid);\n    }\n\n    /// @notice Return pending rewards from the farming pool\n    /// @param tokenId Token Id\n    /// @param amount amount of share\n    function pendingRewards(\n        uint256 tokenId,\n        uint amount\n    )\n        public\n        view\n        override\n        returns (address[] memory tokens, uint256[] memory rewards)\n    {\n        (uint256 pid, uint256 stIchiPerShare) = decodeId(tokenId);\n        uint256 lpDecimals = IERC20MetadataUpgradeable(ichiFarm.lpToken(pid))\n            .decimals();\n        (uint256 enIchiPerShare, , ) = ichiFarm.poolInfo(pid);\n\n        /// Multiple by 1e9 because reward token should be converted from ICHI v1 to ICHI v2\n        /// ICHI v1 decimal: 9, ICHI v2 Decimal: 18\n        uint256 stIchi = 1e9 *\n            (stIchiPerShare * amount).divCeil(10 ** lpDecimals);\n        uint256 enIchi = (1e9 * (enIchiPerShare * amount)) / (10 ** lpDecimals);\n        uint256 ichiRewards = enIchi > stIchi ? enIchi - stIchi : 0;\n\n        tokens = new address[](1);\n        rewards = new uint256[](1);\n        tokens[0] = address(ICHI);\n        rewards[0] = ichiRewards;\n    }\n\n    /// @notice Mint ERC1155 token for the given pool id.\n    /// @param pid Pool id\n    /// @param amount Token amount to wrap\n    /// @return The ERC1155 token id that gets minted.\n    function mint(\n        uint256 pid,\n        uint256 amount\n    ) external nonReentrant returns (uint256) {\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        _ensureApprove(lpToken, address(ichiFarm), amount);\n        ichiFarm.deposit(pid, amount, address(this));\n        (uint256 ichiPerShare, , ) = ichiFarm.poolInfo(pid);\n        uint256 id = encodeId(pid, ichiPerShare);\n        _mint(msg.sender, id, amount, \"\");\n        return id;\n    }\n\n    /// @notice Burn an ERC1155 token to reclaim the original LP tokens and any farming rewards.\n    /// @param id ERC1155 token id\n    /// @param amount Amount of ERC-1155 tokens to burn.\n    /// @return The amount of tokens received as farming rewards.\n    function burn(\n        uint256 id,\n        uint256 amount\n    ) external nonReentrant returns (uint256) {\n        if (amount == type(uint256).max) {\n            amount = balanceOf(msg.sender, id);\n        }\n        (uint256 pid, ) = decodeId(id);\n        _burn(msg.sender, id, amount);\n\n        uint256 ichiRewards = ichiFarm.pendingIchi(pid, address(this));\n        ichiFarm.harvest(pid, address(this));\n        ichiFarm.withdraw(pid, amount, address(this));\n\n        /// Convert Legacy ICHI to ICHI v2\n        if (ichiRewards > 0) {\n            _ensureApprove(address(ICHIv1), address(ICHI), ichiRewards);\n            ICHI.convertToV2(ichiRewards);\n        }\n\n        /// Transfer LP Tokens\n        address lpToken = ichiFarm.lpToken(pid);\n        IERC20Upgradeable(lpToken).safeTransfer(msg.sender, amount);\n\n        /// Transfer Reward Tokens\n        (, uint256[] memory rewards) = pendingRewards(id, amount);\n\n        if (rewards[0] > 0) {\n            /// Transfer minimum amount to prevent reverted tx\n            ICHI.safeTransfer(\n                msg.sender,\n                ICHI.balanceOf(address(this)) >= rewards[0]\n                    ? rewards[0]\n                    : ICHI.balanceOf(address(this))\n            );\n        }\n        return rewards[0];\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}